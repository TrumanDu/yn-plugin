!function () {
    "use strict"; "function" == typeof SuppressedError && SuppressedError; var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function t(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var r, n, u, i, o, a, s, l, c, p, D, d, f, m, g, h, y, E, C, F, A, v, b, x, S, B, T, w, k, N, j, O, I, P, L, _, R, M, $, q, V, U, W, G, z, H, J, X, K, Y, Q, Z, ee, te, re, ne, ue, ie, oe, ae, se, le, ce, pe, De, de, fe, me, ge, he, ye, Ee, Ce, Fe, Ae, ve, be, xe, Se, Be, Te, we, ke, Ne, je, Oe, Ie, Pe, Le, _e, Re, Me, $e, qe = { exports: {} }; qe.exports = (n = (r = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports))(((t, r) => { var n = function (e) { return e && e.Math == Math && e }; r.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || function () { return this }() || Function("return this")() })), u = r(((e, t) => { t.exports = function (e) { try { return !!e() } catch { return !0 } } })), i = r(((e, t) => { var r = u(); t.exports = !r((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })) })), o = r(((e, t) => { var r = u(); t.exports = !r((function () { var e = function () { }.bind(); return "function" != typeof e || e.hasOwnProperty("prototype") })) })), a = r(((e, t) => { var r = o(), n = Function.prototype.call; t.exports = r ? n.bind(n) : function () { return n.apply(n, arguments) } })), s = r((e => { var t = {}.propertyIsEnumerable, r = Object.getOwnPropertyDescriptor, n = r && !t.call({ 1: 2 }, 1); e.f = n ? function (e) { var t = r(this, e); return !!t && t.enumerable } : t })), l = r(((e, t) => { t.exports = function (e, t) { return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t } } })), c = r(((e, t) => { var r = o(), n = Function.prototype, u = n.call, i = r && n.bind.bind(u, u); t.exports = r ? i : function (e) { return function () { return u.apply(e, arguments) } } })), p = r(((e, t) => { var r = c(), n = r({}.toString), u = r("".slice); t.exports = function (e) { return u(n(e), 8, -1) } })), D = r(((e, t) => { var r = c(), n = u(), i = p(), o = Object, a = r("".split); t.exports = n((function () { return !o("z").propertyIsEnumerable(0) })) ? function (e) { return "String" == i(e) ? a(e, "") : o(e) } : o })), d = r(((e, t) => { t.exports = function (e) { return null == e } })), f = r(((e, t) => { var r = d(), n = TypeError; t.exports = function (e) { if (r(e)) throw n("Can't call method on " + e); return e } })), m = r(((e, t) => { var r = D(), n = f(); t.exports = function (e) { return r(n(e)) } })), g = r(((e, t) => { var r = "object" == typeof document && document.all, n = typeof r > "u" && void 0 !== r; t.exports = { all: r, IS_HTMLDDA: n } })), h = r(((e, t) => { var r = g(), n = r.all; t.exports = r.IS_HTMLDDA ? function (e) { return "function" == typeof e || e === n } : function (e) { return "function" == typeof e } })), y = r(((e, t) => { var r = h(), n = g(), u = n.all; t.exports = n.IS_HTMLDDA ? function (e) { return "object" == typeof e ? null !== e : r(e) || e === u } : function (e) { return "object" == typeof e ? null !== e : r(e) } })), E = r(((e, t) => { var r = n(), u = h(), i = function (e) { return u(e) ? e : void 0 }; t.exports = function (e, t) { return arguments.length < 2 ? i(r[e]) : r[e] && r[e][t] } })), C = r(((e, t) => { var r = c(); t.exports = r({}.isPrototypeOf) })), F = r(((e, t) => { var r = E(); t.exports = r("navigator", "userAgent") || "" })), A = r(((e, t) => { var r, u, i = n(), o = F(), a = i.process, s = i.Deno, l = a && a.versions || s && s.version, c = l && l.v8; c && (u = (r = c.split("."))[0] > 0 && r[0] < 4 ? 1 : +(r[0] + r[1])), !u && o && (!(r = o.match(/Edge\/(\d+)/)) || r[1] >= 74) && (r = o.match(/Chrome\/(\d+)/)) && (u = +r[1]), t.exports = u })), v = r(((e, t) => { var r = A(), n = u(); t.exports = !!Object.getOwnPropertySymbols && !n((function () { var e = Symbol(); return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && r && r < 41 })) })), b = r(((e, t) => { var r = v(); t.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator })), x = r(((e, t) => { var r = E(), n = h(), u = C(), i = b(), o = Object; t.exports = i ? function (e) { return "symbol" == typeof e } : function (e) { var t = r("Symbol"); return n(t) && u(t.prototype, o(e)) } })), S = r(((e, t) => { var r = String; t.exports = function (e) { try { return r(e) } catch { return "Object" } } })), B = r(((e, t) => { var r = h(), n = S(), u = TypeError; t.exports = function (e) { if (r(e)) return e; throw u(n(e) + " is not a function") } })), T = r(((e, t) => { var r = B(), n = d(); t.exports = function (e, t) { var u = e[t]; return n(u) ? void 0 : r(u) } })), w = r(((e, t) => { var r = a(), n = h(), u = y(), i = TypeError; t.exports = function (e, t) { var o, a; if ("string" === t && n(o = e.toString) && !u(a = r(o, e)) || n(o = e.valueOf) && !u(a = r(o, e)) || "string" !== t && n(o = e.toString) && !u(a = r(o, e))) return a; throw i("Can't convert object to primitive value") } })), k = r(((e, t) => { t.exports = !1 })), N = r(((e, t) => { var r = n(), u = Object.defineProperty; t.exports = function (e, t) { try { u(r, e, { value: t, configurable: !0, writable: !0 }) } catch { r[e] = t } return t } })), j = r(((e, t) => { var r = n(), u = N(), i = "__core-js_shared__", o = r[i] || u(i, {}); t.exports = o })), O = r(((e, t) => { var r = k(), n = j(); (t.exports = function (e, t) { return n[e] || (n[e] = void 0 !== t ? t : {}) })("versions", []).push({ version: "3.26.1", mode: r ? "pure" : "global", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" }) })), I = r(((e, t) => { var r = f(), n = Object; t.exports = function (e) { return n(r(e)) } })), P = r(((e, t) => { var r = c(), n = I(), u = r({}.hasOwnProperty); t.exports = Object.hasOwn || function (e, t) { return u(n(e), t) } })), L = r(((e, t) => { var r = c(), n = 0, u = Math.random(), i = r(1..toString); t.exports = function (e) { return "Symbol(" + (void 0 === e ? "" : e) + ")_" + i(++n + u, 36) } })), _ = r(((e, t) => { var r = n(), u = O(), i = P(), o = L(), a = v(), s = b(), l = u("wks"), c = r.Symbol, p = c && c.for, D = s ? c : c && c.withoutSetter || o; t.exports = function (e) { if (!i(l, e) || !a && "string" != typeof l[e]) { var t = "Symbol." + e; a && i(c, e) ? l[e] = c[e] : l[e] = s && p ? p(t) : D(t) } return l[e] } })), R = r(((e, t) => { var r = a(), n = y(), u = x(), i = T(), o = w(), s = _(), l = TypeError, c = s("toPrimitive"); t.exports = function (e, t) { if (!n(e) || u(e)) return e; var a, s = i(e, c); if (s) { if (void 0 === t && (t = "default"), a = r(s, e, t), !n(a) || u(a)) return a; throw l("Can't convert object to primitive value") } return void 0 === t && (t = "number"), o(e, t) } })), M = r(((e, t) => { var r = R(), n = x(); t.exports = function (e) { var t = r(e, "string"); return n(t) ? t : t + "" } })), $ = r(((e, t) => { var r = n(), u = y(), i = r.document, o = u(i) && u(i.createElement); t.exports = function (e) { return o ? i.createElement(e) : {} } })), q = r(((e, t) => { var r = i(), n = u(), o = $(); t.exports = !r && !n((function () { return 7 != Object.defineProperty(o("div"), "a", { get: function () { return 7 } }).a })) })), V = r((e => { var t = i(), r = a(), n = s(), u = l(), o = m(), c = M(), p = P(), D = q(), d = Object.getOwnPropertyDescriptor; e.f = t ? d : function (e, t) { if (e = o(e), t = c(t), D) try { return d(e, t) } catch { } if (p(e, t)) return u(!r(n.f, e, t), e[t]) } })), U = r(((e, t) => { var r = i(), n = u(); t.exports = r && n((function () { return 42 != Object.defineProperty((function () { }), "prototype", { value: 42, writable: !1 }).prototype })) })), W = r(((e, t) => { var r = y(), n = String, u = TypeError; t.exports = function (e) { if (r(e)) return e; throw u(n(e) + " is not an object") } })), G = r((e => { var t = i(), r = q(), n = U(), u = W(), o = M(), a = TypeError, s = Object.defineProperty, l = Object.getOwnPropertyDescriptor, c = "enumerable", p = "configurable", D = "writable"; e.f = t ? n ? function (e, t, r) { if (u(e), t = o(t), u(r), "function" == typeof e && "prototype" === t && "value" in r && D in r && !r[D]) { var n = l(e, t); n && n[D] && (e[t] = r.value, r = { configurable: p in r ? r[p] : n[p], enumerable: c in r ? r[c] : n[c], writable: !1 }) } return s(e, t, r) } : s : function (e, t, n) { if (u(e), t = o(t), u(n), r) try { return s(e, t, n) } catch { } if ("get" in n || "set" in n) throw a("Accessors not supported"); return "value" in n && (e[t] = n.value), e } })), z = r(((e, t) => { var r = i(), n = G(), u = l(); t.exports = r ? function (e, t, r) { return n.f(e, t, u(1, r)) } : function (e, t, r) { return e[t] = r, e } })), H = r(((e, t) => { var r = i(), n = P(), u = Function.prototype, o = r && Object.getOwnPropertyDescriptor, a = n(u, "name"), s = a && "something" === function () { }.name, l = a && (!r || r && o(u, "name").configurable); t.exports = { EXISTS: a, PROPER: s, CONFIGURABLE: l } })), J = r(((e, t) => { var r = c(), n = h(), u = j(), i = r(Function.toString); n(u.inspectSource) || (u.inspectSource = function (e) { return i(e) }), t.exports = u.inspectSource })), X = r(((e, t) => { var r = n(), u = h(), i = r.WeakMap; t.exports = u(i) && /native code/.test(String(i)) })), K = r(((e, t) => { var r = O(), n = L(), u = r("keys"); t.exports = function (e) { return u[e] || (u[e] = n(e)) } })), Y = r(((e, t) => { t.exports = {} })), Q = r(((e, t) => { var r, u, i, o, a, s = X(), l = n(), c = y(), p = z(), D = P(), d = j(), f = K(), m = Y(), g = "Object already initialized", h = l.TypeError, E = l.WeakMap, C = function (e) { return i(e) ? u(e) : r(e, {}) }, F = function (e) { return function (t) { var r; if (!c(t) || (r = u(t)).type !== e) throw h("Incompatible receiver, " + e + " required"); return r } }; s || d.state ? ((o = d.state || (d.state = new E)).get = o.get, o.has = o.has, o.set = o.set, r = function (e, t) { if (o.has(e)) throw h(g); return t.facade = e, o.set(e, t), t }, u = function (e) { return o.get(e) || {} }, i = function (e) { return o.has(e) }) : (m[a = f("state")] = !0, r = function (e, t) { if (D(e, a)) throw h(g); return t.facade = e, p(e, a, t), t }, u = function (e) { return D(e, a) ? e[a] : {} }, i = function (e) { return D(e, a) }), t.exports = { set: r, get: u, has: i, enforce: C, getterFor: F } })), Z = r(((e, t) => { var r = u(), n = h(), o = P(), a = i(), s = H().CONFIGURABLE, l = J(), c = Q(), p = c.enforce, D = c.get, d = Object.defineProperty, f = a && !r((function () { return 8 !== d((function () { }), "length", { value: 8 }).length })), m = String(String).split("String"), g = t.exports = function (e, t, r) { "Symbol(" === String(t).slice(0, 7) && (t = "[" + String(t).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), r && r.getter && (t = "get " + t), r && r.setter && (t = "set " + t), (!o(e, "name") || s && e.name !== t) && (a ? d(e, "name", { value: t, configurable: !0 }) : e.name = t), f && r && o(r, "arity") && e.length !== r.arity && d(e, "length", { value: r.arity }); try { r && o(r, "constructor") && r.constructor ? a && d(e, "prototype", { writable: !1 }) : e.prototype && (e.prototype = void 0) } catch { } var n = p(e); return o(n, "source") || (n.source = m.join("string" == typeof t ? t : "")), e }; Function.prototype.toString = g((function () { return n(this) && D(this).source || l(this) }), "toString") })), ee = r(((e, t) => { var r = h(), n = G(), u = Z(), i = N(); t.exports = function (e, t, o, a) { a || (a = {}); var s = a.enumerable, l = void 0 !== a.name ? a.name : t; if (r(o) && u(o, l, a), a.global) s ? e[t] = o : i(t, o); else { try { a.unsafe ? e[t] && (s = !0) : delete e[t] } catch { } s ? e[t] = o : n.f(e, t, { value: o, enumerable: !1, configurable: !a.nonConfigurable, writable: !a.nonWritable }) } return e } })), te = r(((e, t) => { var r = Math.ceil, n = Math.floor; t.exports = Math.trunc || function (e) { var t = +e; return (t > 0 ? n : r)(t) } })), re = r(((e, t) => { var r = te(); t.exports = function (e) { var t = +e; return t != t || 0 === t ? 0 : r(t) } })), ne = r(((e, t) => { var r = re(), n = Math.max, u = Math.min; t.exports = function (e, t) { var i = r(e); return i < 0 ? n(i + t, 0) : u(i, t) } })), ue = r(((e, t) => { var r = re(), n = Math.min; t.exports = function (e) { return e > 0 ? n(r(e), 9007199254740991) : 0 } })), ie = r(((e, t) => { var r = ue(); t.exports = function (e) { return r(e.length) } })), oe = r(((e, t) => { var r = m(), n = ne(), u = ie(), i = function (e) { return function (t, i, o) { var a, s = r(t), l = u(s), c = n(o, l); if (e && i != i) { for (; l > c;)if ((a = s[c++]) != a) return !0 } else for (; l > c; c++)if ((e || c in s) && s[c] === i) return e || c || 0; return !e && -1 } }; t.exports = { includes: i(!0), indexOf: i(!1) } })), ae = r(((e, t) => { var r = c(), n = P(), u = m(), i = oe().indexOf, o = Y(), a = r([].push); t.exports = function (e, t) { var r, s = u(e), l = 0, c = []; for (r in s) !n(o, r) && n(s, r) && a(c, r); for (; t.length > l;)n(s, r = t[l++]) && (~i(c, r) || a(c, r)); return c } })), se = r(((e, t) => { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] })), le = r((e => { var t = ae(), r = se().concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (e) { return t(e, r) } })), ce = r((e => { e.f = Object.getOwnPropertySymbols })), pe = r(((e, t) => { var r = E(), n = c(), u = le(), i = ce(), o = W(), a = n([].concat); t.exports = r("Reflect", "ownKeys") || function (e) { var t = u.f(o(e)), r = i.f; return r ? a(t, r(e)) : t } })), De = r(((e, t) => { var r = P(), n = pe(), u = V(), i = G(); t.exports = function (e, t, o) { for (var a = n(t), s = i.f, l = u.f, c = 0; c < a.length; c++) { var p = a[c]; !r(e, p) && (!o || !r(o, p)) && s(e, p, l(t, p)) } } })), de = r(((e, t) => { var r = u(), n = h(), i = /#|\.prototype\./, o = function (e, t) { var u = s[a(e)]; return u == c || u != l && (n(t) ? r(t) : !!t) }, a = o.normalize = function (e) { return String(e).replace(i, ".").toLowerCase() }, s = o.data = {}, l = o.NATIVE = "N", c = o.POLYFILL = "P"; t.exports = o })), fe = r(((e, t) => { var r = n(), u = V().f, i = z(), o = ee(), a = N(), s = De(), l = de(); t.exports = function (e, t) { var n, c, p, D, d, f = e.target, m = e.global, g = e.stat; if (n = m ? r : g ? r[f] || a(f, {}) : (r[f] || {}).prototype) for (c in t) { if (D = t[c], p = e.dontCallGetSet ? (d = u(n, c)) && d.value : n[c], !l(m ? c : f + (g ? "." : "#") + c, e.forced) && void 0 !== p) { if (typeof D == typeof p) continue; s(D, p) } (e.sham || p && p.sham) && i(D, "sham", !0), o(n, c, D, e) } } })), me = r(((e, t) => { var r = p(); t.exports = Array.isArray || function (e) { return "Array" == r(e) } })), ge = r(((e, t) => { var r = TypeError, n = 9007199254740991; t.exports = function (e) { if (e > n) throw r("Maximum allowed index exceeded"); return e } })), he = r(((e, t) => { var r = p(), n = c(); t.exports = function (e) { if ("Function" === r(e)) return n(e) } })), ye = r(((e, t) => { var r = he(), n = B(), u = o(), i = r(r.bind); t.exports = function (e, t) { return n(e), void 0 === t ? e : u ? i(e, t) : function () { return e.apply(t, arguments) } } })), Ee = r(((e, t) => { var r = me(), n = ie(), u = ge(), i = ye(), o = function (e, t, a, s, l, c, p, D) { for (var d, f, m = l, g = 0, h = !!p && i(p, D); g < s;)g in a && (d = h ? h(a[g], g, t) : a[g], c > 0 && r(d) ? (f = n(d), m = o(e, t, d, f, m, c - 1) - 1) : (u(m + 1), e[m] = d), m++), g++; return m }; t.exports = o })), Ce = r(((e, t) => { var r = {}; r[_()("toStringTag")] = "z", t.exports = "[object z]" === String(r) })), Fe = r(((e, t) => { var r = Ce(), n = h(), u = p(), i = _()("toStringTag"), o = Object, a = "Arguments" == u(function () { return arguments }()), s = function (e, t) { try { return e[t] } catch { } }; t.exports = r ? u : function (e) { var t, r, l; return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (r = s(t = o(e), i)) ? r : a ? u(t) : "Object" == (l = u(t)) && n(t.callee) ? "Arguments" : l } })), Ae = r(((e, t) => { var r = c(), n = u(), i = h(), o = Fe(), a = E(), s = J(), l = function () { }, p = [], D = a("Reflect", "construct"), d = /^\s*(?:class|function)\b/, f = r(d.exec), m = !d.exec(l), g = function (e) { if (!i(e)) return !1; try { return D(l, p, e), !0 } catch { return !1 } }, y = function (e) { if (!i(e)) return !1; switch (o(e)) { case "AsyncFunction": case "GeneratorFunction": case "AsyncGeneratorFunction": return !1 }try { return m || !!f(d, s(e)) } catch { return !0 } }; y.sham = !0, t.exports = !D || n((function () { var e; return g(g.call) || !g(Object) || !g((function () { e = !0 })) || e })) ? y : g })), ve = r(((e, t) => { var r = me(), n = Ae(), u = y(), i = _()("species"), o = Array; t.exports = function (e) { var t; return r(e) && (t = e.constructor, (n(t) && (t === o || r(t.prototype)) || u(t) && null === (t = t[i])) && (t = void 0)), void 0 === t ? o : t } })), be = r(((e, t) => { var r = ve(); t.exports = function (e, t) { return new (r(e))(0 === t ? 0 : t) } })), xe = r((() => { var e = fe(), t = Ee(), r = B(), n = I(), u = ie(), i = be(); e({ target: "Array", proto: !0 }, { flatMap: function (e) { var o, a = n(this), s = u(a); return r(e), (o = i(a, 0)).length = t(o, a, a, s, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), o } }) })), Se = r(((e, t) => { t.exports = {} })), Be = r(((e, t) => { var r = _(), n = Se(), u = r("iterator"), i = Array.prototype; t.exports = function (e) { return void 0 !== e && (n.Array === e || i[u] === e) } })), Te = r(((e, t) => { var r = Fe(), n = T(), u = d(), i = Se(), o = _()("iterator"); t.exports = function (e) { if (!u(e)) return n(e, o) || n(e, "@@iterator") || i[r(e)] } })), we = r(((e, t) => { var r = a(), n = B(), u = W(), i = S(), o = Te(), s = TypeError; t.exports = function (e, t) { var a = arguments.length < 2 ? o(e) : t; if (n(a)) return u(r(a, e)); throw s(i(e) + " is not iterable") } })), ke = r(((e, t) => { var r = a(), n = W(), u = T(); t.exports = function (e, t, i) { var o, a; n(e); try { if (!(o = u(e, "return"))) { if ("throw" === t) throw i; return i } o = r(o, e) } catch (s) { a = !0, o = s } if ("throw" === t) throw i; if (a) throw o; return n(o), i } })), Ne = r(((e, t) => { var r = ye(), n = a(), u = W(), i = S(), o = Be(), s = ie(), l = C(), c = we(), p = Te(), D = ke(), d = TypeError, f = function (e, t) { this.stopped = e, this.result = t }, m = f.prototype; t.exports = function (e, t, a) { var g, h, y, E, C, F, A, v = a && a.that, b = !(!a || !a.AS_ENTRIES), x = !(!a || !a.IS_RECORD), S = !(!a || !a.IS_ITERATOR), B = !(!a || !a.INTERRUPTED), T = r(t, v), w = function (e) { return g && D(g, "normal", e), new f(!0, e) }, k = function (e) { return b ? (u(e), B ? T(e[0], e[1], w) : T(e[0], e[1])) : B ? T(e, w) : T(e) }; if (x) g = e.iterator; else if (S) g = e; else { if (!(h = p(e))) throw d(i(e) + " is not iterable"); if (o(h)) { for (y = 0, E = s(e); E > y; y++)if ((C = k(e[y])) && l(m, C)) return C; return new f(!1) } g = c(e, h) } for (F = x ? e.next : g.next; !(A = n(F, g)).done;) { try { C = k(A.value) } catch (N) { D(g, "throw", N) } if ("object" == typeof C && C && l(m, C)) return C } return new f(!1) } })), je = r(((e, t) => { var r = M(), n = G(), u = l(); t.exports = function (e, t, i) { var o = r(t); o in e ? n.f(e, o, u(0, i)) : e[o] = i } })), Oe = r((() => { var e = fe(), t = Ne(), r = je(); e({ target: "Object", stat: !0 }, { fromEntries: function (e) { var n = {}; return t(e, (function (e, t) { r(n, e, t) }), { AS_ENTRIES: !0 }), n } }) })), Ie = r(((e, t) => { var r = Z(), n = G(); t.exports = function (e, t, u) { return u.get && r(u.get, t, { getter: !0 }), u.set && r(u.set, t, { setter: !0 }), n.f(e, t, u) } })), Pe = r(((e, t) => { var r = W(); t.exports = function () { var e = r(this), t = ""; return e.hasIndices && (t += "d"), e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.unicodeSets && (t += "v"), e.sticky && (t += "y"), t } })), Le = r((() => { var e = n(), t = i(), r = Ie(), o = Pe(), a = u(), s = e.RegExp, l = s.prototype, c = t && a((function () { var e = !0; try { s(".", "d") } catch { e = !1 } var t = {}, r = "", n = e ? "dgimsy" : "gimsy", u = function (e, n) { Object.defineProperty(t, e, { get: function () { return r += n, !0 } }) }, i = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" }; for (var o in e && (i.hasIndices = "d"), i) u(o, i[o]); return Object.getOwnPropertyDescriptor(l, "flags").get.call(t) !== n || r !== n })); c && r(l, "flags", { configurable: !0, get: o }) })), _e = r((() => { var e = fe(), t = n(); e({ global: !0, forced: t.globalThis !== t }, { globalThis: t }) })), Re = r((() => { _e() })), Me = r((() => { var e = fe(), t = Ee(), r = I(), n = ie(), u = re(), i = be(); e({ target: "Array", proto: !0 }, { flat: function () { var e = arguments.length ? arguments[0] : void 0, o = r(this), a = n(o), s = i(o, 0); return s.length = t(s, o, o, a, 0, void 0 === e ? 1 : u(e)), s } }) })), $e = r(((e, t) => {
        var r = ["cliName", "cliCategory", "cliDescription"], n = ["_"], u = ["languageId"]; function i(e, t) { if (null == e) return {}; var r, n, u = o(e, t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); for (n = 0; n < i.length; n++)r = i[n], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (u[r] = e[r]) } return u } function o(e, t) { if (null == e) return {}; var r, n, u = {}, i = Object.keys(e); for (n = 0; n < i.length; n++)r = i[n], !(t.indexOf(r) >= 0) && (u[r] = e[r]); return u } xe(), Oe(), Le(), Re(), Me(); var a, s = Object.create, l = Object.defineProperty, c = Object.getOwnPropertyDescriptor, p = Object.getOwnPropertyNames, D = Object.getPrototypeOf, d = Object.prototype.hasOwnProperty, f = (e, t) => function () { return e && (t = (0, e[p(e)[0]])(e = 0)), t }, m = (e, t) => function () { return t || (0, e[p(e)[0]])((t = { exports: {} }).exports, t), t.exports }, g = (e, t) => { for (var r in t) l(e, r, { get: t[r], enumerable: !0 }) }, h = (e, t, r, n) => { if (t && "object" == typeof t || "function" == typeof t) for (let u of p(t)) !d.call(e, u) && u !== r && l(e, u, { get: () => t[u], enumerable: !(n = c(t, u)) || n.enumerable }); return e }, y = (e, t, r) => (r = null != e ? s(D(e)) : {}, h(!t && e && e.__esModule ? r : l(r, "default", { value: e, enumerable: !0 }), e)), E = e => h(l({}, "__esModule", { value: !0 }), e), C = f({ "<define:process>"() { a = { env: {}, argv: [] } } }), F = m({ "package.json"(e, t) { t.exports = { version: "2.8.8" } } }), A = m({ "node_modules/diff/lib/diff/base.js"(e) { function t() { } function r(e, t, r, n, u) { for (var i = 0, o = t.length, a = 0, s = 0; i < o; i++) { var l = t[i]; if (l.removed) { if (l.value = e.join(n.slice(s, s + l.count)), s += l.count, i && t[i - 1].added) { var c = t[i - 1]; t[i - 1] = t[i], t[i] = c } } else { if (!l.added && u) { var p = r.slice(a, a + l.count); p = p.map((function (e, t) { var r = n[s + t]; return r.length > e.length ? r : e })), l.value = e.join(p) } else l.value = e.join(r.slice(a, a + l.count)); a += l.count, l.added || (s += l.count) } } var D = t[o - 1]; return o > 1 && "string" == typeof D.value && (D.added || D.removed) && e.equals("", D.value) && (t[o - 2].value += D.value, t.pop()), t } function n(e) { return { newPos: e.newPos, components: e.components.slice(0) } } C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t, t.prototype = { diff: function (e, t) { var u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = u.callback; "function" == typeof u && (i = u, u = {}), this.options = u; var o = this; function a(e) { return i ? (setTimeout((function () { i(void 0, e) }), 0), !0) : e } e = this.castInput(e), t = this.castInput(t), e = this.removeEmpty(this.tokenize(e)); var s = (t = this.removeEmpty(this.tokenize(t))).length, l = e.length, c = 1, p = s + l, D = [{ newPos: -1, components: [] }], d = this.extractCommon(D[0], t, e, 0); if (D[0].newPos + 1 >= s && d + 1 >= l) return a([{ value: this.join(t), count: t.length }]); function f() { for (var u = -1 * c; u <= c; u += 2) { var i = void 0, p = D[u - 1], d = D[u + 1], f = (d ? d.newPos : 0) - u; p && (D[u - 1] = void 0); var m = p && p.newPos + 1 < s, g = d && 0 <= f && f < l; if (m || g) { if (!m || g && p.newPos < d.newPos ? (i = n(d), o.pushComponent(i.components, void 0, !0)) : ((i = p).newPos++, o.pushComponent(i.components, !0, void 0)), f = o.extractCommon(i, t, e, u), i.newPos + 1 >= s && f + 1 >= l) return a(r(o, i.components, t, e, o.useLongestToken)); D[u] = i } else D[u] = void 0 } c++ } if (i) !function e() { setTimeout((function () { if (c > p) return i(); f() || e() }), 0) }(); else for (; c <= p;) { var m = f(); if (m) return m } }, pushComponent: function (e, t, r) { var n = e[e.length - 1]; n && n.added === t && n.removed === r ? e[e.length - 1] = { count: n.count + 1, added: t, removed: r } : e.push({ count: 1, added: t, removed: r }) }, extractCommon: function (e, t, r, n) { for (var u = t.length, i = r.length, o = e.newPos, a = o - n, s = 0; o + 1 < u && a + 1 < i && this.equals(t[o + 1], r[a + 1]);)o++, a++, s++; return s && e.components.push({ count: s }), e.newPos = o, a }, equals: function (e, t) { return this.options.comparator ? this.options.comparator(e, t) : e === t || this.options.ignoreCase && e.toLowerCase() === t.toLowerCase() }, removeEmpty: function (e) { for (var t = [], r = 0; r < e.length; r++)e[r] && t.push(e[r]); return t }, castInput: function (e) { return e }, tokenize: function (e) { return e.split("") }, join: function (e) { return e.join("") } } } }), v = m({ "node_modules/diff/lib/diff/array.js"(e) { function t(e) { return e && e.__esModule ? e : { default: e } } C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.diffArrays = n, e.arrayDiff = void 0; var r = new (t(A()).default); function n(e, t, n) { return r.diff(e, t, n) } e.arrayDiff = r, r.tokenize = function (e) { return e.slice() }, r.join = r.removeEmpty = function (e) { return e } } }), b = m({ "src/document/doc-builders.js"(e, t) { function r(e) { return { type: "concat", parts: e } } function n(e) { return { type: "indent", contents: e } } function u(e, t) { return { type: "align", contents: t, n: e } } function i(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return { type: "group", id: t.id, contents: e, break: Boolean(t.shouldBreak), expandedStates: t.expandedStates } } function o(e) { return u(Number.NEGATIVE_INFINITY, e) } function a(e) { return u({ type: "root" }, e) } function s(e) { return u(-1, e) } function l(e, t) { return i(e[0], Object.assign(Object.assign({}, t), {}, { expandedStates: e })) } function c(e) { return { type: "fill", parts: e } } function p(e, t) { return { type: "if-break", breakContents: e, flatContents: t, groupId: (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).groupId } } function D(e, t) { return { type: "indent-if-break", contents: e, groupId: t.groupId, negate: t.negate } } function d(e) { return { type: "line-suffix", contents: e } } C(); var f = { type: "line-suffix-boundary" }, m = { type: "break-parent" }, g = { type: "trim" }, h = { type: "line", hard: !0 }, y = { type: "line", hard: !0, literal: !0 }, E = { type: "line" }, F = { type: "line", soft: !0 }, A = r([h, m]), v = r([y, m]), b = { type: "cursor", placeholder: Symbol("cursor") }; function x(e, t) { let n = []; for (let r = 0; r < t.length; r++)0 !== r && n.push(e), n.push(t[r]); return r(n) } function S(e, t, r) { let i = e; if (t > 0) { for (let e = 0; e < Math.floor(t / r); ++e)i = n(i); i = u(t % r, i), i = u(Number.NEGATIVE_INFINITY, i) } return i } function B(e, t) { return { type: "label", label: e, contents: t } } t.exports = { concat: r, join: x, line: E, softline: F, hardline: A, literalline: v, group: i, conditionalGroup: l, fill: c, lineSuffix: d, lineSuffixBoundary: f, cursor: b, breakParent: m, ifBreak: p, trim: g, indent: n, indentIfBreak: D, align: u, addAlignmentToDoc: S, markAsRoot: a, dedentToRoot: o, dedent: s, hardlineWithoutBreakParent: h, literallineWithoutBreakParent: y, label: B } } }), x = m({ "src/common/end-of-line.js"(e, t) { function r(e) { let t = e.indexOf("\r"); return t >= 0 ? "\n" === e.charAt(t + 1) ? "crlf" : "cr" : "lf" } function n(e) { switch (e) { case "cr": return "\r"; case "crlf": return "\r\n"; default: return "\n" } } function u(e, t) { let r; switch (t) { case "\n": r = /\n/g; break; case "\r": r = /\r/g; break; case "\r\n": r = /\r\n/g; break; default: throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`) }let n = e.match(r); return n ? n.length : 0 } function i(e) { return e.replace(/\r\n?/g, "\n") } C(), t.exports = { guessEndOfLine: r, convertEndOfLineToChars: n, countEndOfLineChars: u, normalizeEndOfLine: i } } }), S = m({ "src/utils/get-last.js"(e, t) { C(); var r = e => e[e.length - 1]; t.exports = r } }); function B() { let { onlyFirst: e = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"); return new RegExp(t, e ? void 0 : "g") } var T = f({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() { C() } }); function w(e) { if ("string" != typeof e) throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``); return e.replace(B(), "") } var k = f({ "node_modules/strip-ansi/index.js"() { C(), T() } }); function N(e) { return !!Number.isInteger(e) && e >= 4352 && (e <= 4447 || 9001 === e || 9002 === e || 11904 <= e && e <= 12871 && 12351 !== e || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) } var j = f({ "node_modules/is-fullwidth-code-point/index.js"() { C() } }), O = m({ "node_modules/emoji-regex/index.js"(e, t) { C(), t.exports = function () { return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g } } }), I = {}; function P(e) { if ("string" != typeof e || 0 === e.length || 0 === (e = w(e)).length) return 0; e = e.replace((0, L.default)(), "  "); let t = 0; for (let r = 0; r < e.length; r++) { let n = e.codePointAt(r); n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (n > 65535 && r++, t += N(n) ? 2 : 1) } return t } g(I, { default: () => P }); var L, _ = f({ "node_modules/string-width/index.js"() { C(), k(), j(), L = y(O()) } }), R = m({ "src/utils/get-string-width.js"(e, t) { C(); var r = (_(), E(I)).default, n = /[^\x20-\x7F]/; function u(e) { return e ? n.test(e) ? r(e) : e.length : 0 } t.exports = u } }), M = m({ "src/document/doc-utils.js"(e, t) { C(); var r = S(), { literalline: n, join: u } = b(), i = e => Array.isArray(e) || e && "concat" === e.type, o = e => { if (Array.isArray(e)) return e; if ("concat" !== e.type && "fill" !== e.type) throw new Error("Expect doc type to be `concat` or `fill`."); return e.parts }, a = {}; function s(e, t, r, n) { let u = [e]; for (; u.length > 0;) { let e = u.pop(); if (e !== a) { if (r && u.push(e, a), !t || !1 !== t(e)) if (i(e) || "fill" === e.type) { let t = o(e); for (let e = t.length - 1; e >= 0; --e)u.push(t[e]) } else if ("if-break" === e.type) e.flatContents && u.push(e.flatContents), e.breakContents && u.push(e.breakContents); else if ("group" === e.type && e.expandedStates) if (n) for (let t = e.expandedStates.length - 1; t >= 0; --t)u.push(e.expandedStates[t]); else u.push(e.contents); else e.contents && u.push(e.contents) } else r(u.pop()) } } function l(e, t) { let r = new Map; return n(e); function n(e) { if (r.has(e)) return r.get(e); let t = u(e); return r.set(e, t), t } function u(e) { if (Array.isArray(e)) return t(e.map(n)); if ("concat" === e.type || "fill" === e.type) { let r = e.parts.map(n); return t(Object.assign(Object.assign({}, e), {}, { parts: r })) } if ("if-break" === e.type) { let r = e.breakContents && n(e.breakContents), u = e.flatContents && n(e.flatContents); return t(Object.assign(Object.assign({}, e), {}, { breakContents: r, flatContents: u })) } if ("group" === e.type && e.expandedStates) { let r = e.expandedStates.map(n), u = r[0]; return t(Object.assign(Object.assign({}, e), {}, { contents: u, expandedStates: r })) } if (e.contents) { let r = n(e.contents); return t(Object.assign(Object.assign({}, e), {}, { contents: r })) } return t(e) } } function c(e, t, r) { let n = r, u = !1; function i(e) { let r = t(e); if (void 0 !== r && (u = !0, n = r), u) return !1 } return s(e, i), n } function p(e) { if ("group" === e.type && e.break || "line" === e.type && e.hard || "break-parent" === e.type) return !0 } function D(e) { return c(e, p, !1) } function d(e) { if (e.length > 0) { let t = r(e); !t.expandedStates && !t.break && (t.break = "propagated") } return null } function f(e) { let t = new Set, r = []; function n(e) { if ("break-parent" === e.type && d(r), "group" === e.type) { if (r.push(e), t.has(e)) return !1; t.add(e) } } function u(e) { "group" === e.type && r.pop().break && d(r) } s(e, n, u, !0) } function m(e) { return "line" !== e.type || e.hard ? "if-break" === e.type ? e.flatContents || "" : e : e.soft ? "" : " " } function g(e) { return l(e, m) } var h = (e, t) => e && "line" === e.type && e.hard && t && "break-parent" === t.type; function y(e) { if (!e) return e; if (i(e) || "fill" === e.type) { let t = o(e); for (; t.length > 1 && h(...t.slice(-2));)t.length -= 2; if (t.length > 0) { let e = y(r(t)); t[t.length - 1] = e } return Array.isArray(e) ? t : Object.assign(Object.assign({}, e), {}, { parts: t }) } switch (e.type) { case "align": case "indent": case "indent-if-break": case "group": case "line-suffix": case "label": { let t = y(e.contents); return Object.assign(Object.assign({}, e), {}, { contents: t }) } case "if-break": { let t = y(e.breakContents), r = y(e.flatContents); return Object.assign(Object.assign({}, e), {}, { breakContents: t, flatContents: r }) } }return e } function E(e) { return y(A(e)) } function F(e) { switch (e.type) { case "fill": if (e.parts.every((e => "" === e))) return ""; break; case "group": if (!(e.contents || e.id || e.break || e.expandedStates)) return ""; if ("group" === e.contents.type && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents; break; case "align": case "indent": case "indent-if-break": case "line-suffix": if (!e.contents) return ""; break; case "if-break": if (!e.flatContents && !e.breakContents) return "" }if (!i(e)) return e; let t = []; for (let n of o(e)) { if (!n) continue; let [e, ...u] = i(n) ? o(n) : [n]; "string" == typeof e && "string" == typeof r(t) ? t[t.length - 1] += e : t.push(e), t.push(...u) } return 0 === t.length ? "" : 1 === t.length ? t[0] : Array.isArray(e) ? t : Object.assign(Object.assign({}, e), {}, { parts: t }) } function A(e) { return l(e, (e => F(e))) } function v(e) { let t = [], n = e.filter(Boolean); for (; n.length > 0;) { let e = n.shift(); if (e) { if (i(e)) { n.unshift(...o(e)); continue } if (t.length > 0 && "string" == typeof r(t) && "string" == typeof e) { t[t.length - 1] += e; continue } t.push(e) } } return t } function x(e) { return l(e, (e => Array.isArray(e) ? v(e) : e.parts ? Object.assign(Object.assign({}, e), {}, { parts: v(e.parts) }) : e)) } function B(e) { return l(e, (e => "string" == typeof e && e.includes("\n") ? T(e) : e)) } function T(e) { return u(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : n, e.split("\n")).parts } function w(e) { if ("line" === e.type) return !0 } function k(e) { return c(e, w, !1) } t.exports = { isConcat: i, getDocParts: o, willBreak: D, traverseDoc: s, findInDoc: c, mapDoc: l, propagateBreaks: f, removeLines: g, stripTrailingHardline: E, normalizeParts: v, normalizeDoc: x, cleanDoc: A, replaceTextEndOfLine: T, replaceEndOfLine: B, canBreak: k } } }), $ = m({ "src/document/doc-printer.js"(e, t) { C(); var r, { convertEndOfLineToChars: n } = x(), u = S(), i = R(), { fill: o, cursor: a, indent: s } = b(), { isConcat: l, getDocParts: c } = M(), p = 1, D = 2; function d() { return { value: "", length: 0, queue: [] } } function f(e, t) { return g(e, { type: "indent" }, t) } function m(e, t, r) { return t === Number.NEGATIVE_INFINITY ? e.root || d() : t < 0 ? g(e, { type: "dedent" }, r) : t ? "root" === t.type ? Object.assign(Object.assign({}, e), {}, { root: e }) : g(e, { type: "string" == typeof t ? "stringAlign" : "numberAlign", n: t }, r) : e } function g(e, t, r) { let n = "dedent" === t.type ? e.queue.slice(0, -1) : [...e.queue, t], u = "", i = 0, o = 0, a = 0; for (let f of n) switch (f.type) { case "indent": c(), r.useTabs ? s(1) : l(r.tabWidth); break; case "stringAlign": c(), u += f.n, i += f.n.length; break; case "numberAlign": o += 1, a += f.n; break; default: throw new Error(`Unexpected type '${f.type}'`) }return D(), Object.assign(Object.assign({}, e), {}, { value: u, length: i, queue: n }); function s(e) { u += "\t".repeat(e), i += r.tabWidth * e } function l(e) { u += " ".repeat(e), i += e } function c() { r.useTabs ? p() : D() } function p() { o > 0 && s(o), d() } function D() { a > 0 && l(a), d() } function d() { o = 0, a = 0 } } function h(e) { if (0 === e.length) return 0; let t = 0; for (; e.length > 0 && "string" == typeof u(e) && /^[\t ]*$/.test(u(e));)t += e.pop().length; if (e.length > 0 && "string" == typeof u(e)) { let r = u(e).replace(/[\t ]*$/, ""); t += u(e).length - r.length, e[e.length - 1] = r } return t } function y(e, t, n, o, a) { let s = t.length, d = [e], f = []; for (; n >= 0;) { if (0 === d.length) { if (0 === s) return !0; d.push(t[--s]); continue } let { mode: e, doc: m } = d.pop(); if ("string" == typeof m) f.push(m), n -= i(m); else if (l(m) || "fill" === m.type) { let t = c(m); for (let r = t.length - 1; r >= 0; r--)d.push({ mode: e, doc: t[r] }) } else switch (m.type) { case "indent": case "align": case "indent-if-break": case "label": d.push({ mode: e, doc: m.contents }); break; case "trim": n += h(f); break; case "group": { if (a && m.break) return !1; let t = m.break ? p : e, r = m.expandedStates && t === p ? u(m.expandedStates) : m.contents; d.push({ mode: t, doc: r }); break } case "if-break": { let t = (m.groupId ? r[m.groupId] || D : e) === p ? m.breakContents : m.flatContents; t && d.push({ mode: e, doc: t }); break } case "line": if (e === p || m.hard) return !0; m.soft || (f.push(" "), n--); break; case "line-suffix": o = !0; break; case "line-suffix-boundary": if (o) return !1 } } return !1 } function E(e, t) { r = {}; let g = t.printWidth, E = n(t.endOfLine), C = 0, F = [{ ind: d(), mode: p, doc: e }], A = [], v = !1, b = []; for (; F.length > 0;) { let { ind: e, mode: n, doc: d } = F.pop(); if ("string" == typeof d) { let e = "\n" !== E ? d.replace(/\n/g, E) : d; A.push(e), C += i(e) } else if (l(d)) { let t = c(d); for (let r = t.length - 1; r >= 0; r--)F.push({ ind: e, mode: n, doc: t[r] }) } else switch (d.type) { case "cursor": A.push(a.placeholder); break; case "indent": F.push({ ind: f(e, t), mode: n, doc: d.contents }); break; case "align": F.push({ ind: m(e, d.n, t), mode: n, doc: d.contents }); break; case "trim": C -= h(A); break; case "group": switch (n) { case D: if (!v) { F.push({ ind: e, mode: d.break ? p : D, doc: d.contents }); break } case p: { v = !1; let t = { ind: e, mode: D, doc: d.contents }, r = g - C, n = b.length > 0; if (!d.break && y(t, F, r, n)) F.push(t); else if (d.expandedStates) { let t = u(d.expandedStates); if (d.break) { F.push({ ind: e, mode: p, doc: t }); break } for (let u = 1; u < d.expandedStates.length + 1; u++) { if (u >= d.expandedStates.length) { F.push({ ind: e, mode: p, doc: t }); break } { let t = d.expandedStates[u], i = { ind: e, mode: D, doc: t }; if (y(i, F, r, n)) { F.push(i); break } } } } else F.push({ ind: e, mode: p, doc: d.contents }); break } }d.id && (r[d.id] = u(F).mode); break; case "fill": { let t = g - C, { parts: r } = d; if (0 === r.length) break; let [u, i] = r, a = { ind: e, mode: D, doc: u }, s = { ind: e, mode: p, doc: u }, l = y(a, [], t, b.length > 0, !0); if (1 === r.length) { l ? F.push(a) : F.push(s); break } let c = { ind: e, mode: D, doc: i }, f = { ind: e, mode: p, doc: i }; if (2 === r.length) { l ? F.push(c, a) : F.push(f, s); break } r.splice(0, 2); let m = { ind: e, mode: n, doc: o(r) }, h = r[0]; y({ ind: e, mode: D, doc: [u, i, h] }, [], t, b.length > 0, !0) ? F.push(m, c, a) : l ? F.push(m, f, a) : F.push(m, f, s); break } case "if-break": case "indent-if-break": { let t = d.groupId ? r[d.groupId] : n; if (t === p) { let t = "if-break" === d.type ? d.breakContents : d.negate ? d.contents : s(d.contents); t && F.push({ ind: e, mode: n, doc: t }) } if (t === D) { let t = "if-break" === d.type ? d.flatContents : d.negate ? s(d.contents) : d.contents; t && F.push({ ind: e, mode: n, doc: t }) } break } case "line-suffix": b.push({ ind: e, mode: n, doc: d.contents }); break; case "line-suffix-boundary": b.length > 0 && F.push({ ind: e, mode: n, doc: { type: "line", hard: !0 } }); break; case "line": switch (n) { case D: if (!d.hard) { d.soft || (A.push(" "), C += 1); break } v = !0; case p: if (b.length > 0) { F.push({ ind: e, mode: n, doc: d }, ...b.reverse()), b.length = 0; break } d.literal ? e.root ? (A.push(E, e.root.value), C = e.root.length) : (A.push(E), C = 0) : (C -= h(A), A.push(E + e.value), C = e.length) }break; case "label": F.push({ ind: e, mode: n, doc: d.contents }) }0 === F.length && b.length > 0 && (F.push(...b.reverse()), b.length = 0) } let x = A.indexOf(a.placeholder); if (-1 !== x) { let e = A.indexOf(a.placeholder, x + 1), t = A.slice(0, x).join(""), r = A.slice(x + 1, e).join(""); return { formatted: t + r + A.slice(e + 1).join(""), cursorNodeStart: t.length, cursorNodeText: r } } return { formatted: A.join("") } } t.exports = { printDocToString: E } } }), q = m({ "src/document/doc-debug.js"(e, t) { C(); var { isConcat: r, getDocParts: n } = M(); function u(e) { if (!e) return ""; if (r(e)) { let t = []; for (let i of n(e)) if (r(i)) t.push(...u(i).parts); else { let e = u(i); "" !== e && t.push(e) } return { type: "concat", parts: t } } return "if-break" === e.type ? Object.assign(Object.assign({}, e), {}, { breakContents: u(e.breakContents), flatContents: u(e.flatContents) }) : "group" === e.type ? Object.assign(Object.assign({}, e), {}, { contents: u(e.contents), expandedStates: e.expandedStates && e.expandedStates.map(u) }) : "fill" === e.type ? { type: "fill", parts: e.parts.map(u) } : e.contents ? Object.assign(Object.assign({}, e), {}, { contents: u(e.contents) }) : e } function i(e) { let t = Object.create(null), i = new Set; return o(u(e)); function o(e, t, u) { if ("string" == typeof e) return JSON.stringify(e); if (r(e)) { let t = n(e).map(o).filter(Boolean); return 1 === t.length ? t[0] : `[${t.join(", ")}]` } if ("line" === e.type) { let r = Array.isArray(u) && u[t + 1] && "break-parent" === u[t + 1].type; return e.literal ? r ? "literalline" : "literallineWithoutBreakParent" : e.hard ? r ? "hardline" : "hardlineWithoutBreakParent" : e.soft ? "softline" : "line" } if ("break-parent" === e.type) return Array.isArray(u) && u[t - 1] && "line" === u[t - 1].type && u[t - 1].hard ? void 0 : "breakParent"; if ("trim" === e.type) return "trim"; if ("indent" === e.type) return "indent(" + o(e.contents) + ")"; if ("align" === e.type) return e.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + o(e.contents) + ")" : e.n < 0 ? "dedent(" + o(e.contents) + ")" : "root" === e.n.type ? "markAsRoot(" + o(e.contents) + ")" : "align(" + JSON.stringify(e.n) + ", " + o(e.contents) + ")"; if ("if-break" === e.type) return "ifBreak(" + o(e.breakContents) + (e.flatContents ? ", " + o(e.flatContents) : "") + (e.groupId ? (e.flatContents ? "" : ', ""') + `, { groupId: ${a(e.groupId)} }` : "") + ")"; if ("indent-if-break" === e.type) { let t = []; e.negate && t.push("negate: true"), e.groupId && t.push(`groupId: ${a(e.groupId)}`); let r = t.length > 0 ? `, { ${t.join(", ")} }` : ""; return `indentIfBreak(${o(e.contents)}${r})` } if ("group" === e.type) { let t = []; e.break && "propagated" !== e.break && t.push("shouldBreak: true"), e.id && t.push(`id: ${a(e.id)}`); let r = t.length > 0 ? `, { ${t.join(", ")} }` : ""; return e.expandedStates ? `conditionalGroup([${e.expandedStates.map((e => o(e))).join(",")}]${r})` : `group(${o(e.contents)}${r})` } if ("fill" === e.type) return `fill([${e.parts.map((e => o(e))).join(", ")}])`; if ("line-suffix" === e.type) return "lineSuffix(" + o(e.contents) + ")"; if ("line-suffix-boundary" === e.type) return "lineSuffixBoundary"; if ("label" === e.type) return `label(${JSON.stringify(e.label)}, ${o(e.contents)})`; throw new Error("Unknown doc type " + e.type) } function a(e) { if ("symbol" != typeof e) return JSON.stringify(String(e)); if (e in t) return t[e]; let r = String(e).slice(7, -1) || "symbol"; for (let n = 0; ; n++) { let u = r + (n > 0 ? ` #${n}` : ""); if (!i.has(u)) return i.add(u), t[e] = `Symbol.for(${JSON.stringify(u)})` } } } t.exports = { printDocToDebug: i } } }), V = m({ "src/document/index.js"(e, t) { C(), t.exports = { builders: b(), printer: $(), utils: M(), debug: q() } } }), U = {}; function W(e) { if ("string" != typeof e) throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } g(U, { default: () => W }); var G = f({ "node_modules/escape-string-regexp/index.js"() { C() } }), z = m({ "node_modules/semver/internal/debug.js"(e, t) { C(); var r = "object" == typeof a && a.env && a.env.NODE_DEBUG && /\bsemver\b/i.test(a.env.NODE_DEBUG) ? function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return console.error("SEMVER", ...t) } : () => { }; t.exports = r } }), H = m({ "node_modules/semver/internal/constants.js"(e, t) { C(); var r = "2.0.0", n = 256, u = Number.MAX_SAFE_INTEGER || 9007199254740991, i = 16; t.exports = { SEMVER_SPEC_VERSION: r, MAX_LENGTH: n, MAX_SAFE_INTEGER: u, MAX_SAFE_COMPONENT_LENGTH: i } } }), J = m({ "node_modules/semver/internal/re.js"(e, t) { C(); var { MAX_SAFE_COMPONENT_LENGTH: r } = H(), n = z(), u = (e = t.exports = {}).re = [], i = e.src = [], o = e.t = {}, a = 0, s = (e, t, r) => { let s = a++; n(e, s, t), o[e] = s, i[s] = t, u[s] = new RegExp(t, r ? "g" : void 0) }; s("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s("MAINVERSION", `(${i[o.NUMERICIDENTIFIER]})\\.(${i[o.NUMERICIDENTIFIER]})\\.(${i[o.NUMERICIDENTIFIER]})`), s("MAINVERSIONLOOSE", `(${i[o.NUMERICIDENTIFIERLOOSE]})\\.(${i[o.NUMERICIDENTIFIERLOOSE]})\\.(${i[o.NUMERICIDENTIFIERLOOSE]})`), s("PRERELEASEIDENTIFIER", `(?:${i[o.NUMERICIDENTIFIER]}|${i[o.NONNUMERICIDENTIFIER]})`), s("PRERELEASEIDENTIFIERLOOSE", `(?:${i[o.NUMERICIDENTIFIERLOOSE]}|${i[o.NONNUMERICIDENTIFIER]})`), s("PRERELEASE", `(?:-(${i[o.PRERELEASEIDENTIFIER]}(?:\\.${i[o.PRERELEASEIDENTIFIER]})*))`), s("PRERELEASELOOSE", `(?:-?(${i[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i[o.PRERELEASEIDENTIFIERLOOSE]})*))`), s("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s("BUILD", `(?:\\+(${i[o.BUILDIDENTIFIER]}(?:\\.${i[o.BUILDIDENTIFIER]})*))`), s("FULLPLAIN", `v?${i[o.MAINVERSION]}${i[o.PRERELEASE]}?${i[o.BUILD]}?`), s("FULL", `^${i[o.FULLPLAIN]}$`), s("LOOSEPLAIN", `[v=\\s]*${i[o.MAINVERSIONLOOSE]}${i[o.PRERELEASELOOSE]}?${i[o.BUILD]}?`), s("LOOSE", `^${i[o.LOOSEPLAIN]}$`), s("GTLT", "((?:<|>)?=?)"), s("XRANGEIDENTIFIERLOOSE", `${i[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s("XRANGEIDENTIFIER", `${i[o.NUMERICIDENTIFIER]}|x|X|\\*`), s("XRANGEPLAIN", `[v=\\s]*(${i[o.XRANGEIDENTIFIER]})(?:\\.(${i[o.XRANGEIDENTIFIER]})(?:\\.(${i[o.XRANGEIDENTIFIER]})(?:${i[o.PRERELEASE]})?${i[o.BUILD]}?)?)?`), s("XRANGEPLAINLOOSE", `[v=\\s]*(${i[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[o.XRANGEIDENTIFIERLOOSE]})(?:${i[o.PRERELEASELOOSE]})?${i[o.BUILD]}?)?)?`), s("XRANGE", `^${i[o.GTLT]}\\s*${i[o.XRANGEPLAIN]}$`), s("XRANGELOOSE", `^${i[o.GTLT]}\\s*${i[o.XRANGEPLAINLOOSE]}$`), s("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), s("COERCERTL", i[o.COERCE], !0), s("LONETILDE", "(?:~>?)"), s("TILDETRIM", `(\\s*)${i[o.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", s("TILDE", `^${i[o.LONETILDE]}${i[o.XRANGEPLAIN]}$`), s("TILDELOOSE", `^${i[o.LONETILDE]}${i[o.XRANGEPLAINLOOSE]}$`), s("LONECARET", "(?:\\^)"), s("CARETTRIM", `(\\s*)${i[o.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", s("CARET", `^${i[o.LONECARET]}${i[o.XRANGEPLAIN]}$`), s("CARETLOOSE", `^${i[o.LONECARET]}${i[o.XRANGEPLAINLOOSE]}$`), s("COMPARATORLOOSE", `^${i[o.GTLT]}\\s*(${i[o.LOOSEPLAIN]})$|^$`), s("COMPARATOR", `^${i[o.GTLT]}\\s*(${i[o.FULLPLAIN]})$|^$`), s("COMPARATORTRIM", `(\\s*)${i[o.GTLT]}\\s*(${i[o.LOOSEPLAIN]}|${i[o.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", s("HYPHENRANGE", `^\\s*(${i[o.XRANGEPLAIN]})\\s+-\\s+(${i[o.XRANGEPLAIN]})\\s*$`), s("HYPHENRANGELOOSE", `^\\s*(${i[o.XRANGEPLAINLOOSE]})\\s+-\\s+(${i[o.XRANGEPLAINLOOSE]})\\s*$`), s("STAR", "(<|>)?=?\\s*\\*"), s("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), s("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$") } }), X = m({ "node_modules/semver/internal/parse-options.js"(e, t) { C(); var r = ["includePrerelease", "loose", "rtl"], n = e => e ? "object" != typeof e ? { loose: !0 } : r.filter((t => e[t])).reduce(((e, t) => (e[t] = !0, e)), {}) : {}; t.exports = n } }), K = m({ "node_modules/semver/internal/identifiers.js"(e, t) { C(); var r = /^[0-9]+$/, n = (e, t) => { let n = r.test(e), u = r.test(t); return n && u && (e = +e, t = +t), e === t ? 0 : n && !u ? -1 : u && !n ? 1 : e < t ? -1 : 1 }, u = (e, t) => n(t, e); t.exports = { compareIdentifiers: n, rcompareIdentifiers: u } } }), Y = m({ "node_modules/semver/classes/semver.js"(e, t) { C(); var r = z(), { MAX_LENGTH: n, MAX_SAFE_INTEGER: u } = H(), { re: i, t: o } = J(), a = X(), { compareIdentifiers: s } = K(), l = class { constructor(e, t) { if (t = a(t), e instanceof l) { if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease) return e; e = e.version } else if ("string" != typeof e) throw new TypeError(`Invalid Version: ${e}`); if (e.length > n) throw new TypeError(`version is longer than ${n} characters`); r("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease; let s = e.trim().match(t.loose ? i[o.LOOSE] : i[o.FULL]); if (!s) throw new TypeError(`Invalid Version: ${e}`); if (this.raw = e, this.major = +s[1], this.minor = +s[2], this.patch = +s[3], this.major > u || this.major < 0) throw new TypeError("Invalid major version"); if (this.minor > u || this.minor < 0) throw new TypeError("Invalid minor version"); if (this.patch > u || this.patch < 0) throw new TypeError("Invalid patch version"); s[4] ? this.prerelease = s[4].split(".").map((e => { if (/^[0-9]+$/.test(e)) { let t = +e; if (t >= 0 && t < u) return t } return e })) : this.prerelease = [], this.build = s[5] ? s[5].split(".") : [], this.format() } format() { return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version } toString() { return this.version } compare(e) { if (r("SemVer.compare", this.version, this.options, e), !(e instanceof l)) { if ("string" == typeof e && e === this.version) return 0; e = new l(e, this.options) } return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e) } compareMain(e) { return e instanceof l || (e = new l(e, this.options)), s(this.major, e.major) || s(this.minor, e.minor) || s(this.patch, e.patch) } comparePre(e) { if (e instanceof l || (e = new l(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1; if (!this.prerelease.length && e.prerelease.length) return 1; if (!this.prerelease.length && !e.prerelease.length) return 0; let t = 0; do { let n = this.prerelease[t], u = e.prerelease[t]; if (r("prerelease compare", t, n, u), void 0 === n && void 0 === u) return 0; if (void 0 === u) return 1; if (void 0 === n) return -1; if (n !== u) return s(n, u) } while (++t) } compareBuild(e) { e instanceof l || (e = new l(e, this.options)); let t = 0; do { let n = this.build[t], u = e.build[t]; if (r("prerelease compare", t, n, u), void 0 === n && void 0 === u) return 0; if (void 0 === u) return 1; if (void 0 === n) return -1; if (n !== u) return s(n, u) } while (++t) } inc(e, t) { switch (e) { case "premajor": this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t); break; case "preminor": this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t); break; case "prepatch": this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t); break; case "prerelease": 0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t); break; case "major": (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = []; break; case "minor": (0 !== this.patch || 0 === this.prerelease.length) && this.minor++, this.patch = 0, this.prerelease = []; break; case "patch": 0 === this.prerelease.length && this.patch++, this.prerelease = []; break; case "pre": if (0 === this.prerelease.length) this.prerelease = [0]; else { let e = this.prerelease.length; for (; --e >= 0;)"number" == typeof this.prerelease[e] && (this.prerelease[e]++, e = -2); -1 === e && this.prerelease.push(0) } t && (0 === s(this.prerelease[0], t) ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]); break; default: throw new Error(`invalid increment argument: ${e}`) }return this.format(), this.raw = this.version, this } }; t.exports = l } }), Q = m({ "node_modules/semver/functions/compare.js"(e, t) { C(); var r = Y(), n = (e, t, n) => new r(e, n).compare(new r(t, n)); t.exports = n } }), Z = m({ "node_modules/semver/functions/lt.js"(e, t) { C(); var r = Q(), n = (e, t, n) => r(e, t, n) < 0; t.exports = n } }), ee = m({ "node_modules/semver/functions/gte.js"(e, t) { C(); var r = Q(), n = (e, t, n) => r(e, t, n) >= 0; t.exports = n } }), te = m({ "src/utils/arrayify.js"(e, t) { C(), t.exports = (e, t) => Object.entries(e).map((e => { let [r, n] = e; return Object.assign({ [t]: r }, n) })) } }), re = m({ "node_modules/outdent/lib/index.js"(e, t) { function r() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t] } function n() { return typeof WeakMap < "u" ? new WeakMap : u() } function u() { return { add: r, delete: r, get: r, set: r, has: function (e) { return !1 } } } C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.outdent = void 0; var i = Object.prototype.hasOwnProperty, o = function (e, t) { return i.call(e, t) }; function a(e, t) { for (var r in t) o(t, r) && (e[r] = t[r]); return e } var s = /^[ \t]*(?:\r\n|\r|\n)/, l = /(?:\r\n|\r|\n)[ \t]*$/, c = /^(?:[\r\n]|$)/, p = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, D = /^[ \t]*[\r\n][ \t\r\n]*$/; function d(e, t, r) { var n = 0, u = e[0].match(p); u && (n = u[1].length); var i = new RegExp("(\\r\\n|\\r|\\n).{0," + n + "}", "g"); t && (e = e.slice(1)); var o = r.newline, a = r.trimLeadingNewline, c = r.trimTrailingNewline, D = "string" == typeof o, d = e.length; return e.map((function (e, t) { return e = e.replace(i, "$1"), 0 === t && a && (e = e.replace(s, "")), t === d - 1 && c && (e = e.replace(l, "")), D && (e = e.replace(/\r\n|\n|\r/g, (function (e) { return o }))), e })) } function f(e, t) { for (var r = "", n = 0, u = e.length; n < u; n++)r += e[n], n < u - 1 && (r += t[n]); return r } function m(e) { return o(e, "raw") && o(e, "length") } function g(e) { var t = n(), r = n(); function u(n) { for (var i = [], o = 1; o < arguments.length; o++)i[o - 1] = arguments[o]; if (m(n)) { var s = n, l = (i[0] === u || i[0] === h) && D.test(s[0]) && c.test(s[1]), p = l ? r : t, y = p.get(s); return y || (y = d(s, l, e), p.set(s, y)), 0 === i.length ? y[0] : f(y, l ? i.slice(1) : i) } return g(a(a({}, e), n || {})) } return a(u, { string: function (t) { return d([t], !1, e)[0] } }) } var h = g({ trimLeadingNewline: !0, trimTrailingNewline: !0 }); if (e.outdent = h, e.default = h, typeof t < "u") try { t.exports = h, Object.defineProperty(h, "__esModule", { value: !0 }), h.default = h, h.outdent = h } catch { } } }), ne = m({
            "src/main/core-options.js"(e, t) {
                C(); var { outdent: r } = re(), n = "Config", u = "Editor", i = "Format", o = "Other", a = "Output", s = "Global", l = "Special", c = {
                    cursorOffset: {
                        since: "1.4.0", category: l, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: r`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: u
                    }, endOfLine: {
                        since: "1.15.0", category: s, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, {
                            value: "auto", description: r`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]
                    }, filepath: { since: "1.4.0", category: l, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: o, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: l, type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: o }, parser: { since: "0.0.10", category: s, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: e => "string" == typeof e || "function" == typeof e, choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: !0, default: [{ value: [] }], category: s, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: e => "string" == typeof e || "object" == typeof e, cliName: "plugin", cliCategory: n }, pluginSearchDirs: {
                        since: "1.13.0", type: "path", array: !0, default: [{ value: [] }], category: s, description: r`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: e => "string" == typeof e || "object" == typeof e, cliName: "plugin-search-dir", cliCategory: n
                    }, printWidth: { since: "0.0.0", category: s, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: {
                        since: "1.4.0", category: l, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: r`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: u
                    }, rangeStart: {
                        since: "1.4.0", category: l, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: r`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: u
                    }, requirePragma: {
                        since: "1.7.0", category: l, type: "boolean", default: !1, description: r`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: o
                    }, tabWidth: { type: "int", category: s, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: s, type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: s, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] }
                }; t.exports = { CATEGORY_CONFIG: n, CATEGORY_EDITOR: u, CATEGORY_FORMAT: i, CATEGORY_OTHER: o, CATEGORY_OUTPUT: a, CATEGORY_GLOBAL: s, CATEGORY_SPECIAL: l, options: c }
            }
        }), ue = m({ "src/main/support.js"(e, t) { C(); var n = { compare: Q(), lt: Z(), gte: ee() }, u = te(), o = F().version, a = ne().options; function s() { let { plugins: e = [], showUnreleased: t = !1, showDeprecated: s = !1, showInternal: c = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, p = o.split("-", 1)[0], D = e.flatMap((e => e.languages || [])).filter(f), d = u(Object.assign({}, ...e.map((e => { let { options: t } = e; return t })), a), "name").filter((e => f(e) && m(e))).sort(((e, t) => e.name === t.name ? 0 : e.name < t.name ? -1 : 1)).map(g).map((t => { t = Object.assign({}, t), Array.isArray(t.default) && (t.default = 1 === t.default.length ? t.default[0].value : t.default.filter(f).sort(((e, t) => n.compare(t.since, e.since)))[0].value), Array.isArray(t.choices) && (t.choices = t.choices.filter((e => f(e) && m(e))), "parser" === t.name && l(t, D, e)); let r = Object.fromEntries(e.filter((e => e.defaultOptions && void 0 !== e.defaultOptions[t.name])).map((e => [e.name, e.defaultOptions[t.name]]))); return Object.assign(Object.assign({}, t), {}, { pluginDefaults: r }) })); return { languages: D, options: d }; function f(e) { return t || !("since" in e) || e.since && n.gte(p, e.since) } function m(e) { return s || !("deprecated" in e) || e.deprecated && n.lt(p, e.deprecated) } function g(e) { return c ? e : i(e, r) } } function l(e, t, r) { let n = new Set(e.choices.map((e => e.value))); for (let u of t) if (u.parsers) for (let t of u.parsers) if (!n.has(t)) { n.add(t); let i = r.find((e => e.parsers && e.parsers[t])), o = u.name; i && i.name && (o += ` (plugin: ${i.name})`), e.choices.push({ value: t, description: o }) } } t.exports = { getSupportInfo: s } } }), ie = m({ "src/utils/is-non-empty-array.js"(e, t) { function r(e) { return Array.isArray(e) && e.length > 0 } C(), t.exports = r } }), oe = m({ "src/utils/text/skip.js"(e, t) { function r(e) { return (t, r, n) => { let u = n && n.backwards; if (!1 === r) return !1; let { length: i } = t, o = r; for (; o >= 0 && o < i;) { let r = t.charAt(o); if (e instanceof RegExp) { if (!e.test(r)) return o } else if (!e.includes(r)) return o; u ? o-- : o++ } return (-1 === o || o === i) && o } } C(); var n = r(/\s/), u = r(" \t"), i = r(",; \t"), o = r(/[^\n\r]/); t.exports = { skipWhitespace: n, skipSpaces: u, skipToLineEnd: i, skipEverythingButNewLine: o } } }), ae = m({ "src/utils/text/skip-inline-comment.js"(e, t) { function r(e, t) { if (!1 === t) return !1; if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r)if ("*" === e.charAt(r) && "/" === e.charAt(r + 1)) return r + 2; return t } C(), t.exports = r } }), se = m({ "src/utils/text/skip-trailing-comment.js"(e, t) { C(); var { skipEverythingButNewLine: r } = oe(); function n(e, t) { return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? r(e, t) : t) } t.exports = n } }), le = m({ "src/utils/text/skip-newline.js"(e, t) { function r(e, t, r) { let n = r && r.backwards; if (!1 === t) return !1; let u = e.charAt(t); if (n) { if ("\r" === e.charAt(t - 1) && "\n" === u) return t - 2; if ("\n" === u || "\r" === u || "\u2028" === u || "\u2029" === u) return t - 1 } else { if ("\r" === u && "\n" === e.charAt(t + 1)) return t + 2; if ("\n" === u || "\r" === u || "\u2028" === u || "\u2029" === u) return t + 1 } return t } C(), t.exports = r } }), ce = m({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, t) { C(); var r = ae(), n = le(), u = se(), { skipSpaces: i } = oe(); function o(e, t) { let o = null, a = t; for (; a !== o;)o = a, a = i(e, a), a = r(e, a), a = u(e, a), a = n(e, a); return a } t.exports = o } }), pe = m({ "src/common/util.js"(e, t) { C(); var { default: r } = (G(), E(U)), n = S(), { getSupportInfo: u } = ue(), i = ie(), o = R(), { skipWhitespace: a, skipSpaces: s, skipToLineEnd: l, skipEverythingButNewLine: c } = oe(), p = ae(), D = se(), d = le(), f = ce(), m = e => e[e.length - 2]; function g(e) { return (t, r, n) => { let u = n && n.backwards; if (!1 === r) return !1; let { length: i } = t, o = r; for (; o >= 0 && o < i;) { let r = t.charAt(o); if (e instanceof RegExp) { if (!e.test(r)) return o } else if (!e.includes(r)) return o; u ? o-- : o++ } return (-1 === o || o === i) && o } } function h(e, t) { let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = s(e, r.backwards ? t - 1 : t, r); return n !== d(e, n, r) } function y(e, t, r) { for (let n = t; n < r; ++n)if ("\n" === e.charAt(n)) return !0; return !1 } function F(e, t, r) { let n = r(t) - 1; return n = s(e, n, { backwards: !0 }), n = d(e, n, { backwards: !0 }), n = s(e, n, { backwards: !0 }), n !== d(e, n, { backwards: !0 }) } function A(e, t) { let r = null, n = t; for (; n !== r;)r = n, n = l(e, n), n = p(e, n), n = s(e, n); return n = D(e, n), n = d(e, n), !1 !== n && h(e, n) } function v(e, t, r) { return A(e, r(t)) } function b(e, t, r) { return f(e, r(t)) } function x(e, t, r) { return e.charAt(b(e, t, r)) } function B(e, t) { let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return s(e, r.backwards ? t - 1 : t, r) !== t } function T(e, t) { let r = 0; for (let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; n < e.length; ++n)"\t" === e[n] ? r = r + t - r % t : r++; return r } function w(e, t) { let r = e.lastIndexOf("\n"); return -1 === r ? 0 : T(e.slice(r + 1).match(/^[\t ]*/)[0], t) } function k(e, t) { let r = { quote: '"', regex: /"/g, escaped: "&quot;" }, n = { quote: "'", regex: /'/g, escaped: "&apos;" }, u = "'" === t ? n : r, i = u === n ? r : n, o = u; return (e.includes(u.quote) || e.includes(i.quote)) && (o = (e.match(u.regex) || []).length > (e.match(i.regex) || []).length ? i : u), o } function N(e, t) { let r = e.slice(1, -1); return j(r, "json" === t.parser || "json5" === t.parser && "preserve" === t.quoteProps && !t.singleQuote ? '"' : t.__isInHtmlAttribute ? "'" : k(r, t.singleQuote ? "'" : '"').quote, !("css" === t.parser || "less" === t.parser || "scss" === t.parser || t.__embeddedInHtml)) } function j(e, t, r) { let n = '"' === t ? "'" : '"', u = /\\(.)|(["'])/gs, i = e.replace(u, ((e, u, i) => u === n ? u : i === t ? "\\" + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(u) ? u : "\\" + u))); return t + i + t } function O(e) { return e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "") } function I(e, t) { let n = e.match(new RegExp(`(${r(t)})+`, "g")); return null === n ? 0 : n.reduce(((e, r) => Math.max(e, r.length / t.length)), 0) } function P(e, t) { let n = e.match(new RegExp(`(${r(t)})+`, "g")); if (null === n) return 0; let u = new Map, i = 0; for (let r of n) { let e = r.length / t.length; u.set(e, !0), e > i && (i = e) } for (let r = 1; r < i; r++)if (!u.get(r)) return r; return i + 1 } function L(e, t) { (e.comments || (e.comments = [])).push(t), t.printed = !1, t.nodeDescription = z(e) } function _(e, t) { t.leading = !0, t.trailing = !1, L(e, t) } function M(e, t, r) { t.leading = !1, t.trailing = !1, r && (t.marker = r), L(e, t) } function $(e, t) { t.leading = !1, t.trailing = !0, L(e, t) } function q(e, t) { let { languages: r } = u({ plugins: t.plugins }), n = r.find((t => { let { name: r } = t; return r.toLowerCase() === e })) || r.find((t => { let { aliases: r } = t; return Array.isArray(r) && r.includes(e) })) || r.find((t => { let { extensions: r } = t; return Array.isArray(r) && r.includes(`.${e}`) })); return n && n.parsers[0] } function V(e) { return e && "front-matter" === e.type } function W(e) { let t = new WeakMap; return function (r) { return t.has(r) || t.set(r, Symbol(e)), t.get(r) } } function z(e) { let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && ("object" == typeof e.id ? e.id.name : e.id) || e.key && ("object" == typeof e.key ? e.key.name : e.key) || e.value && ("object" == typeof e.value ? "" : String(e.value)) || e.operator || ""); return r.length > 20 && (r = r.slice(0, 19) + "â¦"), t + (r ? " " + r : "") } t.exports = { inferParserByLanguage: q, getStringWidth: o, getMaxContinuousCount: I, getMinNotPresentContinuousCount: P, getPenultimate: m, getLast: n, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: b, getNextNonSpaceNonCommentCharacter: x, skip: g, skipWhitespace: a, skipSpaces: s, skipToLineEnd: l, skipEverythingButNewLine: c, skipInlineComment: p, skipTrailingComment: D, skipNewline: d, isNextLineEmptyAfterIndex: A, isNextLineEmpty: v, isPreviousLineEmpty: F, hasNewline: h, hasNewlineInRange: y, hasSpaces: B, getAlignmentSize: T, getIndentSize: w, getPreferredQuote: k, printString: N, printNumber: O, makeString: j, addLeadingComment: _, addDanglingComment: M, addTrailingComment: $, isFrontMatterNode: V, isNonEmptyArray: i, createGroupIdMapper: W } } }), De = {}; function de(e, t) { for (var r = 0, n = e.length - 1; n >= 0; n--) { var u = e[n]; "." === u ? e.splice(n, 1) : ".." === u ? (e.splice(n, 1), r++) : r && (e.splice(n, 1), r--) } if (t) for (; r--; r)e.unshift(".."); return e } function fe() { for (var e = "", t = !1, r = arguments.length - 1; r >= -1 && !t; r--) { var n = r >= 0 ? arguments[r] : "/"; if ("string" != typeof n) throw new TypeError("Arguments to path.resolve must be strings"); n && (e = n + "/" + e, t = "/" === n.charAt(0)) } return (t ? "/" : "") + (e = de(Ae(e.split("/"), (function (e) { return !!e })), !t).join("/")) || "." } function me(e) { var t = ge(e), r = "/" === we(e, -1); return !(e = de(Ae(e.split("/"), (function (e) { return !!e })), !t).join("/")) && !t && (e = "."), e && r && (e += "/"), (t ? "/" : "") + e } function ge(e) { return "/" === e.charAt(0) } function he() { return me(Ae(Array.prototype.slice.call(arguments, 0), (function (e, t) { if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings"); return e })).join("/")) } function ye(e, t) { function r(e) { for (var t = 0; t < e.length && "" === e[t]; t++); for (var r = e.length - 1; r >= 0 && "" === e[r]; r--); return t > r ? [] : e.slice(t, r - t + 1) } e = fe(e).substr(1), t = fe(t).substr(1); for (var n = r(e.split("/")), u = r(t.split("/")), i = Math.min(n.length, u.length), o = i, a = 0; a < i; a++)if (n[a] !== u[a]) { o = a; break } var s = []; for (a = o; a < n.length; a++)s.push(".."); return (s = s.concat(u.slice(o))).join("/") } function Ee(e) { var t = be(e), r = t[0], n = t[1]; return r || n ? (n && (n = n.substr(0, n.length - 1)), r + n) : "." } function Ce(e, t) { var r = be(e)[2]; return t && r.substr(-1 * t.length) === t && (r = r.substr(0, r.length - t.length)), r } function Fe(e) { return be(e)[3] } function Ae(e, t) { if (e.filter) return e.filter(t); for (var r = [], n = 0; n < e.length; n++)t(e[n], n, e) && r.push(e[n]); return r } g(De, { basename: () => Ce, default: () => Te, delimiter: () => Be, dirname: () => Ee, extname: () => Fe, isAbsolute: () => ge, join: () => he, normalize: () => me, relative: () => ye, resolve: () => fe, sep: () => Se }); var ve, be, Se, Be, Te, we, ke = f({ "node-modules-polyfills:path"() { C(), ve = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, be = function (e) { return ve.exec(e).slice(1) }, Te = { extname: Fe, basename: Ce, dirname: Ee, sep: Se = "/", delimiter: Be = ":", relative: ye, join: he, isAbsolute: ge, normalize: me, resolve: fe }, we = "b" === "ab".substr(-1) ? function (e, t, r) { return e.substr(t, r) } : function (e, t, r) { return t < 0 && (t = e.length + t), e.substr(t, r) } } }), Ne = m({ "node-modules-polyfills-commonjs:path"(e, t) { C(); var r = (ke(), E(De)); if (r && r.default) { t.exports = r.default; for (let e in r) t.exports[e] = r[e] } else r && (t.exports = r) } }), je = m({ "src/common/errors.js"(e, t) { C(); var r = class extends Error { }, n = class extends Error { }, u = class extends Error { }, i = class extends Error { }; t.exports = { ConfigError: r, DebugError: n, UndefinedParserError: u, ArgExpansionBailout: i } } }), Ie = {}; function Pe(e, t) { function r() { this.constructor = e } ot(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) } function _e(e, t) { var r = {}; for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var u = 0; for (n = Object.getOwnPropertySymbols(e); u < n.length; u++)t.indexOf(n[u]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[u]) && (r[n[u]] = e[n[u]]) } return r } function $e(e, t, r, n) { var u, i = arguments.length, o = i < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n); else for (var a = e.length - 1; a >= 0; a--)(u = e[a]) && (o = (i < 3 ? u(o) : i > 3 ? u(t, r, o) : u(t, r)) || o); return i > 3 && o && Object.defineProperty(t, r, o), o } function qe(e, t) { return function (r, n) { t(r, n, e) } } function Ve(e, t) { if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t) } function Ue(e, t, r, n) { function u(e) { return e instanceof r ? e : new r((function (t) { t(e) })) } return new (r || (r = Promise))((function (r, i) { function o(e) { try { s(n.next(e)) } catch (t) { i(t) } } function a(e) { try { s(n.throw(e)) } catch (t) { i(t) } } function s(e) { e.done ? r(e.value) : u(e.value).then(o, a) } s((n = n.apply(e, t || [])).next()) })) } function We(e, t) { var r, n, u, i, o = { label: 0, sent: function () { if (1 & u[0]) throw u[1]; return u[1] }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function () { return this }), i; function a(e) { return function (t) { return s([e, t]) } } function s(i) { if (r) throw new TypeError("Generator is already executing."); for (; o;)try { if (r = 1, n && (u = 2 & i[0] ? n.return : i[0] ? n.throw || ((u = n.return) && u.call(n), 0) : n.next) && !(u = u.call(n, i[1])).done) return u; switch (n = 0, u && (i = [2 & i[0], u.value]), i[0]) { case 0: case 1: u = i; break; case 4: return o.label++, { value: i[1], done: !1 }; case 5: o.label++, n = i[1], i = [0]; continue; case 7: i = o.ops.pop(), o.trys.pop(); continue; default: if (!(u = (u = o.trys).length > 0 && u[u.length - 1]) && (6 === i[0] || 2 === i[0])) { o = 0; continue } if (3 === i[0] && (!u || i[1] > u[0] && i[1] < u[3])) { o.label = i[1]; break } if (6 === i[0] && o.label < u[1]) { o.label = u[1], u = i; break } if (u && o.label < u[2]) { o.label = u[2], o.ops.push(i); break } u[2] && o.ops.pop(), o.trys.pop(); continue }i = t.call(e, o) } catch (a) { i = [6, a], n = 0 } finally { r = u = 0 } if (5 & i[0]) throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 } } } function Ge(e, t, r, n) { void 0 === n && (n = r), e[n] = t[r] } function ze(e, t) { for (var r in e) "default" !== r && !t.hasOwnProperty(r) && (t[r] = e[r]) } function He(e) { var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function Je(e, t) { var r = "function" == typeof Symbol && e[Symbol.iterator]; if (!r) return e; var n, u, i = r.call(e), o = []; try { for (; (void 0 === t || t-- > 0) && !(n = i.next()).done;)o.push(n.value) } catch (a) { u = { error: a } } finally { try { n && !n.done && (r = i.return) && r.call(i) } finally { if (u) throw u.error } } return o } function Xe() { for (var e = [], t = 0; t < arguments.length; t++)e = e.concat(Je(arguments[t])); return e } function Ke() { for (var e = 0, t = 0, r = arguments.length; t < r; t++)e += arguments[t].length; var n = Array(e), u = 0; for (t = 0; t < r; t++)for (var i = arguments[t], o = 0, a = i.length; o < a; o++, u++)n[u] = i[o]; return n } function Ye(e) { return this instanceof Ye ? (this.v = e, this) : new Ye(e) } function Qe(e, t, r) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, u = r.apply(e, t || []), i = []; return n = {}, o("next"), o("throw"), o("return"), n[Symbol.asyncIterator] = function () { return this }, n; function o(e) { u[e] && (n[e] = function (t) { return new Promise((function (r, n) { i.push([e, t, r, n]) > 1 || a(e, t) })) }) } function a(e, t) { try { s(u[e](t)) } catch (r) { p(i[0][3], r) } } function s(e) { e.value instanceof Ye ? Promise.resolve(e.value.v).then(l, c) : p(i[0][2], e) } function l(e) { a("next", e) } function c(e) { a("throw", e) } function p(e, t) { e(t), i.shift(), i.length && a(i[0][0], i[0][1]) } } function Ze(e) { var t, r; return t = {}, n("next"), n("throw", (function (e) { throw e })), n("return"), t[Symbol.iterator] = function () { return this }, t; function n(n, u) { t[n] = e[n] ? function (t) { return (r = !r) ? { value: Ye(e[n](t)), done: "return" === n } : u ? u(t) : t } : u } } function et(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t, r = e[Symbol.asyncIterator]; return r ? r.call(e) : (e = "function" == typeof He ? He(e) : e[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function () { return this }, t); function n(r) { t[r] = e[r] && function (t) { return new Promise((function (n, i) { u(n, i, (t = e[r](t)).done, t.value) })) } } function u(e, t, r, n) { Promise.resolve(n).then((function (t) { e({ value: t, done: r }) }), t) } } function tt(e, t) { return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e } function rt(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t } function nt(e) { return e && e.__esModule ? e : { default: e } } function ut(e, t) { if (!t.has(e)) throw new TypeError("attempted to get private field on non-instance"); return t.get(e) } function it(e, t, r) { if (!t.has(e)) throw new TypeError("attempted to set private field on non-instance"); return t.set(e, r), r } g(Ie, { __assign: () => at, __asyncDelegator: () => Ze, __asyncGenerator: () => Qe, __asyncValues: () => et, __await: () => Ye, __awaiter: () => Ue, __classPrivateFieldGet: () => ut, __classPrivateFieldSet: () => it, __createBinding: () => Ge, __decorate: () => $e, __exportStar: () => ze, __extends: () => Pe, __generator: () => We, __importDefault: () => nt, __importStar: () => rt, __makeTemplateObject: () => tt, __metadata: () => Ve, __param: () => qe, __read: () => Je, __rest: () => _e, __spread: () => Xe, __spreadArrays: () => Ke, __values: () => He }); var ot, at, st = f({ "node_modules/tslib/tslib.es6.js"() { C(), ot = function (e, t) { return (ot = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]) })(e, t) }, at = function () { return at = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++)for (var u in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, u) && (e[u] = t[u]); return e }, at.apply(this, arguments) } } }), lt = m({ "node_modules/vnopts/lib/descriptors/api.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.apiDescriptor = { key: e => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(t) { if (null === t || "object" != typeof t) return JSON.stringify(t); if (Array.isArray(t)) return `[${t.map((t => e.apiDescriptor.value(t))).join(", ")}]`; let r = Object.keys(t); return 0 === r.length ? "{}" : `{ ${r.map((r => `${e.apiDescriptor.key(r)}: ${e.apiDescriptor.value(t[r])}`)).join(", ")} }` }, pair: t => { let { key: r, value: n } = t; return e.apiDescriptor.value({ [r]: n }) } } } }), ct = m({ "node_modules/vnopts/lib/descriptors/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }), (st(), E(Ie)).__exportStar(lt(), e) } }), pt = m({ "scripts/build/shims/chalk.cjs"(e, t) { C(); var r = e => e; r.grey = r, r.red = r, r.bold = r, r.yellow = r, r.blue = r, r.default = r, t.exports = r } }), Dt = m({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = pt(); e.commonDeprecatedHandler = (e, r, n) => { let { descriptor: u } = n, i = [`${t.default.yellow("string" == typeof e ? u.key(e) : u.pair(e))} is deprecated`]; return r && i.push(`we now treat it as ${t.default.blue("string" == typeof r ? u.key(r) : u.pair(r))}`), i.join("; ") + "." } } }), dt = m({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }), (st(), E(Ie)).__exportStar(Dt(), e) } }), ft = m({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = pt(); e.commonInvalidHandler = (e, r, n) => [`Invalid ${t.default.red(n.descriptor.key(e))} value.`, `Expected ${t.default.blue(n.schemas[e].expected(n))},`, `but received ${t.default.red(n.descriptor.value(r))}.`].join(" ") } }), mt = m({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }), (st(), E(Ie)).__exportStar(ft(), e) } }), gt = m({ "node_modules/vnopts/node_modules/leven/index.js"(e, t) { C(); var r = [], n = []; t.exports = function (e, t) { if (e === t) return 0; var u = e; e.length > t.length && (e = t, t = u); var i = e.length, o = t.length; if (0 === i) return o; if (0 === o) return i; for (; i > 0 && e.charCodeAt(~-i) === t.charCodeAt(~-o);)i--, o--; if (0 === i) return o; for (var a = 0; a < i && e.charCodeAt(a) === t.charCodeAt(a);)a++; if (o -= a, 0 == (i -= a)) return o; for (var s, l, c, p, D = 0, d = 0; D < i;)n[a + D] = e.charCodeAt(a + D), r[D] = ++D; for (; d < o;)for (s = t.charCodeAt(a + d), c = d++, l = d, D = 0; D < i; D++)p = s === n[a + D] ? c : c + 1, c = r[D], l = r[D] = c > l ? p > l ? l + 1 : p : p > c ? c + 1 : p; return l } } }), ht = m({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = pt(), r = gt(); e.levenUnknownHandler = (e, n, u) => { let { descriptor: i, logger: o, schemas: a } = u, s = [`Ignored unknown option ${t.default.yellow(i.pair({ key: e, value: n }))}.`], l = Object.keys(a).sort().find((t => r(e, t) < 3)); l && s.push(`Did you mean ${t.default.blue(i.key(l))}?`), o.warn(s.join(" ")) } } }), yt = m({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }), (st(), E(Ie)).__exportStar(ht(), e) } }), Et = m({ "node_modules/vnopts/lib/handlers/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = (st(), E(Ie)); t.__exportStar(dt(), e), t.__exportStar(mt(), e), t.__exportStar(yt(), e) } }), Ct = m({ "node_modules/vnopts/lib/schema.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"]; function r(e, r) { let i = new e(r), o = Object.create(i); for (let a of t) a in r && (o[a] = u(r[a], i, n.prototype[a].length)); return o } e.createSchema = r; var n = class { constructor(e) { this.name = e.name } static create(e) { return r(this, e) } default(e) { } expected(e) { return "nothing" } validate(e, t) { return !1 } deprecated(e, t) { return !1 } forward(e, t) { } redirect(e, t) { } overlap(e, t, r) { return e } preprocess(e, t) { return e } postprocess(e, t) { return e } }; function u(e, t, r) { return "function" == typeof e ? function () { for (var n = arguments.length, u = new Array(n), i = 0; i < n; i++)u[i] = arguments[i]; return e(...u.slice(0, r - 1), t, ...u.slice(r - 1)) } : () => e } e.Schema = n } }), Ft = m({ "node_modules/vnopts/lib/schemas/alias.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Ct(), r = class extends t.Schema { constructor(e) { super(e), this._sourceName = e.sourceName } expected(e) { return e.schemas[this._sourceName].expected(e) } validate(e, t) { return t.schemas[this._sourceName].validate(e, t) } redirect(e, t) { return this._sourceName } }; e.AliasSchema = r } }), At = m({ "node_modules/vnopts/lib/schemas/any.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Ct(), r = class extends t.Schema { expected() { return "anything" } validate() { return !0 } }; e.AnySchema = r } }), vt = m({ "node_modules/vnopts/lib/schemas/array.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = (st(), E(Ie)), r = Ct(), n = class extends r.Schema { constructor(e) { var { valueSchema: r, name: n = r.name } = e, u = t.__rest(e, ["valueSchema", "name"]); super(Object.assign({}, u, { name: n })), this._valueSchema = r } expected(e) { return `an array of ${this._valueSchema.expected(e)}` } validate(e, t) { if (!Array.isArray(e)) return !1; let r = []; for (let n of e) { let e = t.normalizeValidateResult(this._valueSchema.validate(n, t), n); !0 !== e && r.push(e.value) } return 0 === r.length || { value: r } } deprecated(e, t) { let r = []; for (let n of e) { let e = t.normalizeDeprecatedResult(this._valueSchema.deprecated(n, t), n); !1 !== e && r.push(...e.map((e => { let { value: t } = e; return { value: [t] } }))) } return r } forward(e, t) { let r = []; for (let n of e) { let e = t.normalizeForwardResult(this._valueSchema.forward(n, t), n); r.push(...e.map(u)) } return r } redirect(e, t) { let r = [], n = []; for (let i of e) { let e = t.normalizeRedirectResult(this._valueSchema.redirect(i, t), i); "remain" in e && r.push(e.remain), n.push(...e.redirect.map(u)) } return 0 === r.length ? { redirect: n } : { redirect: n, remain: r } } overlap(e, t) { return e.concat(t) } }; function u(e) { let { from: t, to: r } = e; return { from: [t], to: r } } e.ArraySchema = n } }), bt = m({ "node_modules/vnopts/lib/schemas/boolean.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Ct(), r = class extends t.Schema { expected() { return "true or false" } validate(e) { return "boolean" == typeof e } }; e.BooleanSchema = r } }), xt = m({ "node_modules/vnopts/lib/utils.js"(e) { function t(e, t) { let r = Object.create(null); for (let n of e) { let e = n[t]; if (r[e]) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`); r[e] = n } return r } function r(e, t) { let r = new Map; for (let n of e) { let e = n[t]; if (r.has(e)) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`); r.set(e, n) } return r } function n() { let e = Object.create(null); return t => { let r = JSON.stringify(t); return !!e[r] || (e[r] = !0, !1) } } function u(e, t) { let r = [], n = []; for (let u of e) t(u) ? r.push(u) : n.push(u); return [r, n] } function i(e) { return e === Math.floor(e) } function o(e, t) { if (e === t) return 0; let r = typeof e, n = typeof t, u = ["undefined", "object", "boolean", "number", "string"]; return r !== n ? u.indexOf(r) - u.indexOf(n) : "string" !== r ? Number(e) - Number(t) : e.localeCompare(t) } function a(e) { return void 0 === e ? {} : e } function s(e, t) { return !0 === e || (!1 === e ? { value: t } : e) } function l(e, t) { return !1 !== e && (!0 === e ? !!(arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) || [{ value: t }] : "value" in e ? [e] : 0 !== e.length && e) } function c(e, t) { return "string" == typeof e || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to } } function p(e, t) { return void 0 === e ? [] : Array.isArray(e) ? e.map((e => c(e, t))) : [c(e, t)] } function D(e, t) { let r = p("object" == typeof e && "redirect" in e ? e.redirect : e, t); return 0 === r.length ? { remain: t, redirect: r } : "object" == typeof e && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r } } C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.recordFromArray = t, e.mapFromArray = r, e.createAutoChecklist = n, e.partition = u, e.isInt = i, e.comparePrimitive = o, e.normalizeDefaultResult = a, e.normalizeValidateResult = s, e.normalizeDeprecatedResult = l, e.normalizeTransferResult = c, e.normalizeForwardResult = p, e.normalizeRedirectResult = D } }), St = m({ "node_modules/vnopts/lib/schemas/choice.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Ct(), r = xt(), n = class extends t.Schema { constructor(e) { super(e), this._choices = r.mapFromArray(e.choices.map((e => e && "object" == typeof e ? e : { value: e })), "value") } expected(e) { let { descriptor: t } = e, n = Array.from(this._choices.keys()).map((e => this._choices.get(e))).filter((e => !e.deprecated)).map((e => e.value)).sort(r.comparePrimitive).map(t.value), u = n.slice(0, -2), i = n.slice(-2); return u.concat(i.join(" or ")).join(", ") } validate(e) { return this._choices.has(e) } deprecated(e) { let t = this._choices.get(e); return !(!t || !t.deprecated) && { value: e } } forward(e) { let t = this._choices.get(e); return t ? t.forward : void 0 } redirect(e) { let t = this._choices.get(e); return t ? t.redirect : void 0 } }; e.ChoiceSchema = n } }), Bt = m({ "node_modules/vnopts/lib/schemas/number.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Ct(), r = class extends t.Schema { expected() { return "a number" } validate(e, t) { return "number" == typeof e } }; e.NumberSchema = r } }), Tt = m({ "node_modules/vnopts/lib/schemas/integer.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = xt(), r = Bt(), n = class extends r.NumberSchema { expected() { return "an integer" } validate(e, r) { return !0 === r.normalizeValidateResult(super.validate(e, r), e) && t.isInt(e) } }; e.IntegerSchema = n } }), wt = m({ "node_modules/vnopts/lib/schemas/string.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Ct(), r = class extends t.Schema { expected() { return "a string" } validate(e) { return "string" == typeof e } }; e.StringSchema = r } }), kt = m({ "node_modules/vnopts/lib/schemas/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = (st(), E(Ie)); t.__exportStar(Ft(), e), t.__exportStar(At(), e), t.__exportStar(vt(), e), t.__exportStar(bt(), e), t.__exportStar(St(), e), t.__exportStar(Tt(), e), t.__exportStar(Bt(), e), t.__exportStar(wt(), e) } }), Nt = m({ "node_modules/vnopts/lib/defaults.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = lt(), r = Dt(), n = mt(), u = ht(); e.defaultDescriptor = t.apiDescriptor, e.defaultUnknownHandler = u.levenUnknownHandler, e.defaultInvalidHandler = n.commonInvalidHandler, e.defaultDeprecatedHandler = r.commonDeprecatedHandler } }), jt = m({ "node_modules/vnopts/lib/normalize.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Nt(), r = xt(); e.normalize = (e, t, r) => new n(t, r).normalize(e); var n = class { constructor(e, n) { let { logger: u = console, descriptor: i = t.defaultDescriptor, unknown: o = t.defaultUnknownHandler, invalid: a = t.defaultInvalidHandler, deprecated: s = t.defaultDeprecatedHandler } = n || {}; this._utils = { descriptor: i, logger: u || { warn: () => { } }, schemas: r.recordFromArray(e, "name"), normalizeDefaultResult: r.normalizeDefaultResult, normalizeDeprecatedResult: r.normalizeDeprecatedResult, normalizeForwardResult: r.normalizeForwardResult, normalizeRedirectResult: r.normalizeRedirectResult, normalizeValidateResult: r.normalizeValidateResult }, this._unknownHandler = o, this._invalidHandler = a, this._deprecatedHandler = s, this.cleanHistory() } cleanHistory() { this._hasDeprecationWarned = r.createAutoChecklist() } normalize(e) { let t = {}, n = [e], u = () => { for (; 0 !== n.length;) { let e = n.shift(), r = this._applyNormalization(e, t); n.push(...r) } }; u(); for (let i of Object.keys(this._utils.schemas)) { let e = this._utils.schemas[i]; if (!(i in t)) { let t = r.normalizeDefaultResult(e.default(this._utils)); "value" in t && n.push({ [i]: t.value }) } } u(); for (let r of Object.keys(this._utils.schemas)) { let e = this._utils.schemas[r]; r in t && (t[r] = e.postprocess(t[r], this._utils)) } return t } _applyNormalization(e, t) { let n = [], [u, i] = r.partition(Object.keys(e), (e => e in this._utils.schemas)); for (let o of u) { let u = this._utils.schemas[o], i = u.preprocess(e[o], this._utils), a = r.normalizeValidateResult(u.validate(i, this._utils), i); if (!0 !== a) { let { value: e } = a, t = this._invalidHandler(o, e, this._utils); throw "string" == typeof t ? new Error(t) : t } let s = e => { let { from: t, to: r } = e; n.push("string" == typeof r ? { [r]: t } : { [r.key]: r.value }) }, l = e => { let { value: t, redirectTo: n } = e, a = r.normalizeDeprecatedResult(u.deprecated(t, this._utils), i, !0); if (!1 !== a) if (!0 === a) this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, n, this._utils)); else for (let { value: r } of a) { let e = { key: o, value: r }; if (!this._hasDeprecationWarned(e)) { let t = "string" == typeof n ? { key: n, value: r } : n; this._utils.logger.warn(this._deprecatedHandler(e, t, this._utils)) } } }; r.normalizeForwardResult(u.forward(i, this._utils), i).forEach(s); let c = r.normalizeRedirectResult(u.redirect(i, this._utils), i); if (c.redirect.forEach(s), "remain" in c) { let e = c.remain; t[o] = o in t ? u.overlap(t[o], e, this._utils) : e, l({ value: e }) } for (let { from: e, to: t } of c.redirect) l({ value: e, redirectTo: t }) } for (let r of i) { let u = e[r], i = this._unknownHandler(r, u, this._utils); if (i) for (let e of Object.keys(i)) { let r = { [e]: i[e] }; e in this._utils.schemas ? n.push(r) : Object.assign(t, r) } } return n } }; e.Normalizer = n } }), Ot = m({ "node_modules/vnopts/lib/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = (st(), E(Ie)); t.__exportStar(ct(), e), t.__exportStar(Et(), e), t.__exportStar(kt(), e), t.__exportStar(jt(), e), t.__exportStar(Ct(), e) } }), It = m({ "src/main/options-normalizer.js"(e, t) { C(); var r, u = Ot(), o = S(), a = { key: e => 1 === e.length ? `-${e}` : `--${e}`, value: e => u.apiDescriptor.value(e), pair: e => { let { key: t, value: r } = e; return !1 === r ? `--no-${t}` : !0 === r ? a.key(t) : "" === r ? `${a.key(t)} without an argument` : `${a.key(t)}=${r}` } }, s = e => { let { colorsModule: t, levenshteinDistance: r } = e; return class extends u.ChoiceSchema { constructor(e) { let { name: t, flags: r } = e; super({ name: t, choices: r }), this._flags = [...r].sort() } preprocess(e, n) { if ("string" == typeof e && e.length > 0 && !this._flags.includes(e)) { let u = this._flags.find((t => r(t, e) < 3)); if (u) return n.logger.warn([`Unknown flag ${t.yellow(n.descriptor.value(e))},`, `did you mean ${t.blue(n.descriptor.value(u))}?`].join(" ")), u } return e } expected() { return "a flag" } } }; function l(e, t) { let { logger: o = !1, isCLI: s = !1, passThrough: l = !1, colorsModule: p = null, levenshteinDistance: D = null } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, d = l ? Array.isArray(l) ? (e, t) => l.includes(e) ? { [e]: t } : void 0 : (e, t) => ({ [e]: t }) : (e, t, r) => { let o = i(r.schemas, n); return u.levenUnknownHandler(e, t, Object.assign(Object.assign({}, r), {}, { schemas: o })) }, f = s ? a : u.apiDescriptor, m = c(t, { isCLI: s, colorsModule: p, levenshteinDistance: D }), g = new u.Normalizer(m, { logger: o, unknown: d, descriptor: f }), h = !1 !== o; h && r && (g._hasDeprecationWarned = r); let y = g.normalize(e); return h && (r = g._hasDeprecationWarned), s && !1 === y["plugin-search"] && (y["plugin-search-dir"] = !1), y } function c(e, t) { let { isCLI: r, colorsModule: n, levenshteinDistance: i } = t, o = []; r && o.push(u.AnySchema.create({ name: "_" })); for (let a of e) o.push(p(a, { isCLI: r, optionInfos: e, colorsModule: n, levenshteinDistance: i })), a.alias && r && o.push(u.AliasSchema.create({ name: a.alias, sourceName: a.name })); return o } function p(e, t) { let { isCLI: r, optionInfos: n, colorsModule: i, levenshteinDistance: a } = t, { name: l } = e; if ("plugin-search-dir" === l || "pluginSearchDirs" === l) return u.AnySchema.create({ name: l, preprocess: e => (!1 === e || (e = Array.isArray(e) ? e : [e]), e), validate: e => !1 === e || e.every((e => "string" == typeof e)), expected: () => "false or paths to plugin search dir" }); let c, p = { name: l }, D = {}; switch (e.type) { case "int": c = u.IntegerSchema, r && (p.preprocess = Number); break; case "string": case "path": c = u.StringSchema; break; case "choice": c = u.ChoiceSchema, p.choices = e.choices.map((t => "object" == typeof t && t.redirect ? Object.assign(Object.assign({}, t), {}, { redirect: { to: { key: e.name, value: t.redirect } } }) : t)); break; case "boolean": c = u.BooleanSchema; break; case "flag": c = s({ colorsModule: i, levenshteinDistance: a }), p.flags = n.flatMap((e => [e.alias, e.description && e.name, e.oppositeDescription && `no-${e.name}`].filter(Boolean))); break; default: throw new Error(`Unexpected type ${e.type}`) }if (e.exception ? p.validate = (t, r, n) => e.exception(t) || r.validate(t, n) : p.validate = (e, t, r) => void 0 === e || t.validate(e, r), e.redirect && (D.redirect = t => t ? { to: { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (D.deprecated = !0), r && !e.array) { let e = p.preprocess || (e => e); p.preprocess = (t, r, n) => r.preprocess(e(Array.isArray(t) ? o(t) : t), n) } return e.array ? u.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, r ? { preprocess: e => Array.isArray(e) ? e : [e] } : {}), D), {}, { valueSchema: c.create(p) })) : c.create(Object.assign(Object.assign({}, p), D)) } function D(e, t, r) { return l(e, t, r) } function d(e, t, r) { return l(e, t, Object.assign({ isCLI: !0 }, r)) } t.exports = { normalizeApiOptions: D, normalizeCliOptions: d } } }), Pt = m({ "src/language-js/loc.js"(e, t) { C(); var r = ie(); function n(e) { var t, u; let i = e.range ? e.range[0] : e.start, o = null !== (t = null === (u = e.declaration) || void 0 === u ? void 0 : u.decorators) && void 0 !== t ? t : e.decorators; return r(o) ? Math.min(n(o[0]), i) : i } function u(e) { return e.range ? e.range[1] : e.end } function i(e, t) { let r = n(e); return Number.isInteger(r) && r === n(t) } function o(e, t) { let r = u(e); return Number.isInteger(r) && r === u(t) } function a(e, t) { return i(e, t) && o(e, t) } t.exports = { locStart: n, locEnd: u, hasSameLocStart: i, hasSameLoc: a } } }), Lt = m({ "src/main/load-parser.js"(e, t) { C(), t.exports = () => { } } }), _t = m({ "scripts/build/shims/babel-highlight.cjs"(e, t) { C(); var r = pt(), n = { shouldHighlight: () => !1, getChalk: () => r }; t.exports = n } }), Rt = m({ "node_modules/@babel/code-frame/lib/index.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.codeFrameColumns = o, e.default = s; var t = _t(), r = !1; function n(e) { return { gutter: e.grey, marker: e.red.bold, message: e.red.bold } } var u = /\r\n|[\n\r\u2028\u2029]/; function i(e, t, r) { let n = Object.assign({ column: 0, line: -1 }, e.start), u = Object.assign({}, n, e.end), { linesAbove: i = 2, linesBelow: o = 3 } = r || {}, a = n.line, s = n.column, l = u.line, c = u.column, p = Math.max(a - (i + 1), 0), D = Math.min(t.length, l + o); -1 === a && (p = 0), -1 === l && (D = t.length); let d = l - a, f = {}; if (d) for (let m = 0; m <= d; m++) { let e = m + a; if (s) if (0 === m) { let r = t[e - 1].length; f[e] = [s, r - s + 1] } else if (m === d) f[e] = [0, c]; else { let r = t[e - m].length; f[e] = [0, r] } else f[e] = !0 } else f[a] = s === c ? !s || [s, 0] : [s, c - s]; return { start: p, end: D, markerLines: f } } function o(e, r) { let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, a = (o.highlightCode || o.forceColor) && (0, t.shouldHighlight)(o), s = (0, t.getChalk)(o), l = n(s), c = (e, t) => a ? e(t) : t, p = e.split(u), { start: D, end: d, markerLines: f } = i(r, p, o), m = r.start && "number" == typeof r.start.column, g = String(d).length, h = (a ? (0, t.default)(e, o) : e).split(u, d).slice(D, d).map(((e, t) => { let r = D + 1 + t, n = ` ${` ${r}`.slice(-g)} |`, u = f[r], i = !f[r + 1]; if (u) { let t = ""; if (Array.isArray(u)) { let r = e.slice(0, Math.max(u[0] - 1, 0)).replace(/[^\t]/g, " "), a = u[1] || 1; t = ["\n ", c(l.gutter, n.replace(/\d/g, " ")), " ", r, c(l.marker, "^").repeat(a)].join(""), i && o.message && (t += " " + c(l.message, o.message)) } return [c(l.marker, ">"), c(l.gutter, n), e.length > 0 ? ` ${e}` : "", t].join("") } return ` ${c(l.gutter, n)}${e.length > 0 ? ` ${e}` : ""}` })).join("\n"); return o.message && !m && (h = `${" ".repeat(g + 1)}${o.message}\n${h}`), a ? s.reset(h) : h } function s(e, t, n) { let u = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; if (!r) { r = !0; let e = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`."; a.emitWarning ? a.emitWarning(e, "DeprecationWarning") : (new Error(e).name = "DeprecationWarning", console.warn(new Error(e))) } return o(e, { start: { column: n = Math.max(n, 0), line: t } }, u) } } }), Mt = m({ "src/main/parser.js"(e, t) { C(); var { ConfigError: r } = je(), n = Pt(); Lt(); var { locStart: u, locEnd: i } = n, o = Object.getOwnPropertyNames, a = Object.getOwnPropertyDescriptor; function s(e) { let t = {}; for (let r of e.plugins) if (r.parsers) for (let e of o(r.parsers)) Object.defineProperty(t, e, a(r.parsers, e)); return t } function l(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s(e); if ("function" == typeof e.parser) return { parse: e.parser, astFormat: "estree", locStart: u, locEnd: i }; if ("string" == typeof e.parser) { if (Object.prototype.hasOwnProperty.call(t, e.parser)) return t[e.parser]; throw new r(`Couldn't resolve parser "${e.parser}". Parsers must be explicitly added to the standalone bundle.`) } } function c(e, t) { let r = s(t), n = Object.defineProperties({}, Object.fromEntries(Object.keys(r).map((e => [e, { enumerable: !0, get: () => r[e].parse }])))), u = l(t, r); try { return u.preprocess && (e = u.preprocess(e, t)), { text: e, ast: u.parse(e, n, t) } } catch (i) { let { loc: t } = i; if (t) { let { codeFrameColumns: r } = Rt(); throw i.codeFrame = r(e, t, { highlightCode: !0 }), i.message += "\n" + i.codeFrame, i } throw i } } t.exports = { parse: c, resolveParser: l } } }), $t = m({ "src/main/options.js"(e, t) { C(); var r = Ne(), { UndefinedParserError: n } = je(), { getSupportInfo: u } = ue(), i = It(), { resolveParser: o } = Mt(), a = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null }; function s(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = Object.assign({}, e), s = u({ plugins: e.plugins, showUnreleased: !0, showDeprecated: !0 }).options, p = Object.assign(Object.assign({}, a), Object.fromEntries(s.filter((e => void 0 !== e.default)).map((e => [e.name, e.default])))); if (!r.parser) if (r.filepath) { if (r.parser = c(r.filepath, r.plugins), !r.parser) throw new n(`No parser could be inferred for file: ${r.filepath}`) } else (t.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), r.parser = "babel"; let D = o(i.normalizeApiOptions(r, [s.find((e => "parser" === e.name))], { passThrough: !0, logger: !1 })); r.astFormat = D.astFormat, r.locEnd = D.locEnd, r.locStart = D.locStart; let d = l(r); r.printer = d.printers[r.astFormat]; let f = Object.fromEntries(s.filter((e => e.pluginDefaults && void 0 !== e.pluginDefaults[d.name])).map((e => [e.name, e.pluginDefaults[d.name]]))), m = Object.assign(Object.assign({}, p), f); for (let [n, u] of Object.entries(m)) (null === r[n] || void 0 === r[n]) && (r[n] = u); return "json" === r.parser && (r.trailingComma = "none"), i.normalizeApiOptions(r, s, Object.assign({ passThrough: Object.keys(a) }, t)) } function l(e) { let { astFormat: t } = e; if (!t) throw new Error("getPlugin() requires astFormat to be set"); let r = e.plugins.find((e => e.printers && e.printers[t])); if (!r) throw new Error(`Couldn't find plugin for AST format "${t}"`); return r } function c(e, t) { let n = r.basename(e).toLowerCase(), i = u({ plugins: t }).languages.filter((e => null !== e.since)).find((e => e.extensions && e.extensions.some((e => n.endsWith(e))) || e.filenames && e.filenames.some((e => e.toLowerCase() === n)))); return i && i.parsers[0] } t.exports = { normalize: s, hiddenDefaults: a, inferParser: c } } }), qt = m({ "src/main/massage-ast.js"(e, t) { function r(e, t, n) { if (Array.isArray(e)) return e.map((e => r(e, t, n))).filter(Boolean); if (!e || "object" != typeof e) return e; let u, i = t.printer.massageAstNode; u = i && i.ignoredProperties ? i.ignoredProperties : new Set; let o = {}; for (let [a, s] of Object.entries(e)) !u.has(a) && "function" != typeof s && (o[a] = r(s, t, e)); if (i) { let t = i(e, o, n); if (null === t) return; if (t) return t } return o } C(), t.exports = r } }), Vt = m({ "scripts/build/shims/assert.cjs"(e, t) { C(); var r = () => { }; r.ok = r, r.strictEqual = r, t.exports = r } }), Ut = m({ "src/main/comments.js"(e, t) { C(); var r = Vt(), { builders: { line: n, hardline: u, breakParent: i, indent: o, lineSuffix: a, join: s, cursor: l } } = V(), { hasNewline: c, skipNewline: p, skipSpaces: D, isPreviousLineEmpty: d, addLeadingComment: f, addDanglingComment: m, addTrailingComment: g } = pe(), h = new WeakMap; function y(e, t, r) { if (!e) return; let { printer: n, locStart: u, locEnd: i } = t; if (r) { if (n.canAttachComment && n.canAttachComment(e)) { let t; for (t = r.length - 1; t >= 0 && !(u(r[t]) <= u(e) && i(r[t]) <= i(e)); --t); return void r.splice(t + 1, 0, e) } } else if (h.has(e)) return h.get(e); let o = n.getCommentChildNodes && n.getCommentChildNodes(e, t) || "object" == typeof e && Object.entries(e).filter((e => { let [t] = e; return "enclosingNode" !== t && "precedingNode" !== t && "followingNode" !== t && "tokens" !== t && "comments" !== t && "parent" !== t })).map((e => { let [, t] = e; return t })); if (o) { r || (r = [], h.set(e, r)); for (let e of o) y(e, t, r); return r } } function E(e, t, r, n) { let u, i, { locStart: o, locEnd: a } = r, s = o(t), l = a(t), c = y(e, r), p = 0, D = c.length; for (; p < D;) { let e = p + D >> 1, n = c[e], d = o(n), f = a(n); if (d <= s && l <= f) return E(n, t, r, n); if (f <= s) u = n, p = e + 1; else { if (!(l <= d)) throw new Error("Comment location overlaps with node location"); i = n, D = e } } if (n && "TemplateLiteral" === n.type) { let { quasis: e } = n, o = T(e, t, r); u && T(e, u, r) !== o && (u = null), i && T(e, i, r) !== o && (i = null) } return { enclosingNode: n, precedingNode: u, followingNode: i } } var F = () => !1; function A(e, t, r, n) { if (!Array.isArray(e)) return; let u = [], { locStart: i, locEnd: o, printer: { handleComments: a = {} } } = n, { avoidAstMutation: s, ownLine: l = F, endOfLine: c = F, remaining: p = F } = a, D = e.map(((u, i) => Object.assign(Object.assign({}, E(t, u, n)), {}, { comment: u, text: r, options: n, ast: t, isLastComment: e.length - 1 === i }))); for (let [d, h] of D.entries()) { let e, { comment: t, precedingNode: r, enclosingNode: n, followingNode: a, text: y, options: E, ast: C, isLastComment: F } = h; if ("json" === E.parser || "json5" === E.parser || "__js_expression" === E.parser || "__vue_expression" === E.parser || "__vue_ts_expression" === E.parser) { if (i(t) - i(C) <= 0) { f(C, t); continue } if (o(t) - o(C) >= 0) { g(C, t); continue } } if (s ? e = [h] : (t.enclosingNode = n, t.precedingNode = r, t.followingNode = a, e = [t, y, E, C, F]), b(y, E, D, d)) t.placement = "ownLine", l(...e) || (a ? f(a, t) : r ? g(r, t) : m(n || C, t)); else if (x(y, E, D, d)) t.placement = "endOfLine", c(...e) || (r ? g(r, t) : a ? f(a, t) : m(n || C, t)); else if (t.placement = "remaining", !p(...e)) if (r && a) { let e = u.length; e > 0 && u[e - 1].followingNode !== a && S(u, y, E), u.push(h) } else r ? g(r, t) : a ? f(a, t) : m(n || C, t) } if (S(u, r, n), !s) for (let d of e) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode } var v = e => !/[\S\n\u2028\u2029]/.test(e); function b(e, t, r, n) { let { comment: u, precedingNode: i } = r[n], { locStart: o, locEnd: a } = t, s = o(u); if (i) for (let l = n - 1; l >= 0; l--) { let { comment: t, precedingNode: n } = r[l]; if (n !== i || !v(e.slice(a(t), s))) break; s = o(t) } return c(e, s, { backwards: !0 }) } function x(e, t, r, n) { let { comment: u, followingNode: i } = r[n], { locStart: o, locEnd: a } = t, s = a(u); if (i) for (let l = n + 1; l < r.length; l++) { let { comment: t, followingNode: n } = r[l]; if (n !== i || !v(e.slice(s, o(t)))) break; s = a(t) } return c(e, s) } function S(e, t, n) { let u = e.length; if (0 === u) return; let i, { precedingNode: o, followingNode: a, enclosingNode: s } = e[0], l = n.printer.getGapRegex && n.printer.getGapRegex(s) || /^[\s(]*$/, c = n.locStart(a); for (i = u; i > 0; --i) { let { comment: u, precedingNode: s, followingNode: p } = e[i - 1]; r.strictEqual(s, o), r.strictEqual(p, a); let D = t.slice(n.locEnd(u), c); if (!l.test(D)) break; c = n.locStart(u) } for (let [r, { comment: p }] of e.entries()) r < i ? g(o, p) : f(a, p); for (let r of [o, a]) r.comments && r.comments.length > 1 && r.comments.sort(((e, t) => n.locStart(e) - n.locStart(t))); e.length = 0 } function B(e, t) { return e.getValue().printed = !0, t.printer.printComment(e, t) } function T(e, t, r) { let n = r.locStart(t) - 1; for (let u = 1; u < e.length; ++u)if (n < r.locStart(e[u])) return u - 1; return 0 } function w(e, t) { let r = e.getValue(), i = [B(e, t)], { printer: o, originalText: a, locStart: s, locEnd: l } = t; if (o.isBlockComment && o.isBlockComment(r)) { let e = c(a, l(r)) ? c(a, s(r), { backwards: !0 }) ? u : n : " "; i.push(e) } else i.push(u); let d = p(a, D(a, l(r))); return !1 !== d && c(a, d) && i.push(u), i } function k(e, t) { let r = e.getValue(), n = B(e, t), { printer: o, originalText: s, locStart: l } = t, p = o.isBlockComment && o.isBlockComment(r); if (c(s, l(r), { backwards: !0 })) { let e = d(s, r, l); return a([u, e ? u : "", n]) } let D = [" ", n]; return p || (D = [a(D), i]), D } function N(e, t, r, n) { let i = [], a = e.getValue(); return a && a.comments && (e.each((() => { let r = e.getValue(); !r.leading && !r.trailing && (!n || n(r)) && i.push(B(e, t)) }), "comments"), 0 !== i.length) ? r ? s(u, i) : o([u, s(u, i)]) : "" } function j(e, t, r) { let n = e.getValue(); if (!n) return {}; let u = n.comments || []; r && (u = u.filter((e => !r.has(e)))); let i = n === t.cursorNode; if (0 === u.length) { let e = i ? l : ""; return { leading: e, trailing: e } } let o = [], a = []; return e.each((() => { let n = e.getValue(); if (r && r.has(n)) return; let { leading: u, trailing: i } = n; u ? o.push(w(e, t)) : i && a.push(k(e, t)) }), "comments"), i && (o.unshift(l), a.push(l)), { leading: o, trailing: a } } function O(e, t, r, n) { let { leading: u, trailing: i } = j(e, r, n); return u || i ? [u, t, i] : t } function I(e) { if (e) for (let t of e) { if (!t.printed) throw new Error('Comment "' + t.value.trim() + '" was not printed. Please report this error!'); delete t.printed } } t.exports = { attach: A, printComments: O, printCommentsSeparately: j, printDanglingComments: N, getSortedChildNodes: y, ensureAllCommentsPrinted: I } } }), Wt = m({ "src/common/ast-path.js"(e, t) { C(); var r = S(); function n(e, t) { let r = u(e.stack, t); return -1 === r ? null : e.stack[r] } function u(e, t) { for (let r = e.length - 1; r >= 0; r -= 2) { let n = e[r]; if (n && !Array.isArray(n) && --t < 0) return r } return -1 } var i = class { constructor(e) { this.stack = [e] } getName() { let { stack: e } = this, { length: t } = e; return t > 1 ? e[t - 2] : null } getValue() { return r(this.stack) } getNode() { return n(this, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) } getParentNode() { return n(this, (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) + 1) } call(e) { let { stack: t } = this, { length: n } = t, u = r(t); for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)o[a - 1] = arguments[a]; for (let r of o) u = u[r], t.push(r, u); let s = e(this); return t.length = n, s } callParent(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = u(this.stack, t + 1), n = this.stack.splice(r + 1), i = e(this); return this.stack.push(...n), i } each(e) { let { stack: t } = this, { length: n } = t, u = r(t); for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)o[a - 1] = arguments[a]; for (let r of o) u = u[r], t.push(r, u); for (let r = 0; r < u.length; ++r)t.push(r, u[r]), e(this, r, u), t.length -= 2; t.length = n } map(e) { let t = []; for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), u = 1; u < r; u++)n[u - 1] = arguments[u]; return this.each(((r, n, u) => { t[n] = e(r, n, u) }), ...n), t } try(e) { let { stack: t } = this, r = [...t]; try { return e() } finally { t.length = 0, t.push(...r) } } match() { let e = this.stack.length - 1, t = null, r = this.stack[e--]; for (var n = arguments.length, u = new Array(n), i = 0; i < n; i++)u[i] = arguments[i]; for (let o of u) { if (void 0 === r) return !1; let n = null; if ("number" == typeof t && (n = t, t = this.stack[e--], r = this.stack[e--]), o && !o(r, t, n)) return !1; t = this.stack[e--], r = this.stack[e--] } return !0 } findAncestor(e) { let t = this.stack.length - 1, r = null, n = this.stack[t--]; for (; n;) { let u = null; if ("number" == typeof r && (u = r, r = this.stack[t--], n = this.stack[t--]), null !== r && e(n, r, u)) return n; r = this.stack[t--], n = this.stack[t--] } } }; t.exports = i } }), Gt = m({ "src/main/multiparser.js"(e, t) { C(); var { utils: { stripTrailingHardline: r } } = V(), { normalize: n } = $t(), u = Ut(); function i(e, t, r, n) { if (r.printer.embed && "auto" === r.embeddedLanguageFormatting) return r.printer.embed(e, t, ((e, t, u) => o(e, t, r, n, u)), r) } function o(e, t, i, o) { let { stripTrailingHardline: a = !1 } = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}, s = n(Object.assign(Object.assign(Object.assign({}, i), t), {}, { parentParser: i.parser, originalText: e }), { passThrough: !0 }), l = Mt().parse(e, s), { ast: c } = l; e = l.text; let p = c.comments; delete c.comments, u.attach(p, c, e, s), s[Symbol.for("comments")] = p || [], s[Symbol.for("tokens")] = c.tokens || []; let D = o(c, s); return u.ensureAllCommentsPrinted(p), a ? "string" == typeof D ? D.replace(/(?:\r?\n)*$/, "") : r(D) : D } t.exports = { printSubtree: i } } }), zt = m({ "src/main/ast-to-doc.js"(e, t) { C(); var r = Wt(), { builders: { hardline: n, addAlignmentToDoc: u }, utils: { propagateBreaks: i } } = V(), { printComments: o } = Ut(), a = Gt(); function s(e, t) { let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, { printer: a } = t; a.preprocess && (e = a.preprocess(e, t)); let s = new Map, l = new r(e), p = D(); return o > 0 && (p = u([n, p], o, t.tabWidth)), i(p), p; function D(e, t) { return void 0 === e || e === l ? d(t) : Array.isArray(e) ? l.call((() => d(t)), ...e) : l.call((() => d(t)), e) } function d(e) { let r = l.getValue(), n = r && "object" == typeof r && void 0 === e; if (n && s.has(r)) return s.get(r); let u = c(l, t, D, e); return n && s.set(r, u), u } } function l(e, t) { let { originalText: r, [Symbol.for("comments")]: n, locStart: u, locEnd: i } = t, o = u(e), a = i(e), s = new Set; for (let l of n) u(l) >= o && i(l) <= a && (l.printed = !0, s.add(l)); return { doc: r.slice(o, a), printedComments: s } } function c(e, t, r, n) { let u, i, c = e.getValue(), { printer: p } = t; if (p.hasPrettierIgnore && p.hasPrettierIgnore(e)) ({ doc: u, printedComments: i } = l(c, t)); else { if (c) try { u = a.printSubtree(e, r, t, s) } catch (D) { if (globalThis.PRETTIER_DEBUG) throw D } u || (u = p.print(e, t, r, n)) } return (!p.willPrintOwnComments || !p.willPrintOwnComments(e, t)) && (u = o(e, u, t, i)), u } t.exports = s } }), Ht = m({ "src/main/range-util.js"(e, t) { C(); var r = Vt(), n = Ut(), u = e => { let { parser: t } = e; return "json" === t || "json5" === t || "json-stringify" === t }; function i(e, t) { let r = [e.node, ...e.parentNodes], n = new Set([t.node, ...t.parentNodes]); return r.find((e => c.has(e.type) && n.has(e))) } function o(e) { let t = e.length - 1; for (; ;) { let r = e[t]; if (!r || "Program" !== r.type && "File" !== r.type) break; t-- } return e.slice(0, t + 1) } function a(e, t, r) { let { locStart: n, locEnd: u } = r, i = e.node, a = t.node; if (i === a) return { startNode: i, endNode: a }; let s = n(e.node); for (let c of o(t.parentNodes)) { if (!(n(c) >= s)) break; a = c } let l = u(t.node); for (let c of o(e.parentNodes)) { if (!(u(c) <= l)) break; if (i = c, i === a) break } return { startNode: i, endNode: a } } function s(e, t, r, u) { let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], o = arguments.length > 5 ? arguments[5] : void 0, { locStart: a, locEnd: l } = r, c = a(e), p = l(e); if (!(t > p || t < c || "rangeEnd" === o && t === c || "rangeStart" === o && t === p)) { for (let a of n.getSortedChildNodes(e, r)) { let n = s(a, t, r, u, [e, ...i], o); if (n) return n } if (!u || u(e, i[0])) return { node: e, parentNodes: i } } } function l(e, t) { return "DeclareExportDeclaration" !== t && "TypeParameterDeclaration" !== e && ("Directive" === e || "TypeAlias" === e || "TSExportAssignment" === e || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration")) } var c = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), p = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]); function D(e, t, r) { if (!t) return !1; switch (e.parser) { case "flow": case "babel": case "babel-flow": case "babel-ts": case "typescript": case "acorn": case "espree": case "meriyah": case "__babel_estree": return l(t.type, r && r.type); case "json": case "json5": case "json-stringify": return c.has(t.type); case "graphql": return p.has(t.kind); case "vue": return "root" !== t.tag }return !1 } function d(e, t, n) { let { rangeStart: o, rangeEnd: l, locStart: c, locEnd: p } = t; r.ok(l > o); let d = e.slice(o, l).search(/\S/), f = -1 === d; if (!f) for (o += d; l > o && !/\S/.test(e[l - 1]); --l); let m, g, h = s(n, o, t, ((e, r) => D(t, e, r)), [], "rangeStart"), y = f ? h : s(n, l, t, (e => D(t, e)), [], "rangeEnd"); if (!h || !y) return { rangeStart: 0, rangeEnd: 0 }; if (u(t)) { let e = i(h, y); m = e, g = e } else ({ startNode: m, endNode: g } = a(h, y, t)); return { rangeStart: Math.min(c(m), c(g)), rangeEnd: Math.max(p(m), p(g)) } } t.exports = { calculateRange: d, findNodeAtOffset: s } } }), Jt = m({ "src/main/core.js"(e, t) { C(); var { diffArrays: r } = v(), { printer: { printDocToString: n }, debug: { printDocToDebug: u } } = V(), { getAlignmentSize: i } = pe(), { guessEndOfLine: o, convertEndOfLineToChars: a, countEndOfLineChars: s, normalizeEndOfLine: l } = x(), c = $t().normalize, p = qt(), D = Ut(), d = Mt(), f = zt(), m = Ht(), g = "\ufeff", h = Symbol("cursor"); function y(e, t, r) { let n = t.comments; return n && (delete t.comments, D.attach(n, t, e, r)), r[Symbol.for("comments")] = n || [], r[Symbol.for("tokens")] = t.tokens || [], r.originalText = e, n } function E(e, t) { let u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; if (!e || 0 === e.trim().length) return { formatted: "", cursorOffset: -1, comments: [] }; let { ast: i, text: o } = d.parse(e, t); if (t.cursorOffset >= 0) { let e = m.findNodeAtOffset(i, t.cursorOffset, t); e && e.node && (t.cursorNode = e.node) } let s = y(o, i, t), l = f(i, t, u), c = n(l, t); if (D.ensureAllCommentsPrinted(s), u > 0) { let e = c.formatted.trim(); void 0 !== c.cursorNodeStart && (c.cursorNodeStart -= c.formatted.indexOf(e)), c.formatted = e + a(t.endOfLine) } if (t.cursorOffset >= 0) { let e, n, u, i, a; if (t.cursorNode && c.cursorNodeText ? (e = t.locStart(t.cursorNode), n = o.slice(e, t.locEnd(t.cursorNode)), u = t.cursorOffset - e, i = c.cursorNodeStart, a = c.cursorNodeText) : (e = 0, n = o, u = t.cursorOffset, i = 0, a = c.formatted), n === a) return { formatted: c.formatted, cursorOffset: i + u, comments: s }; let l = [...n]; l.splice(u, 0, h); let p = [...a], D = r(l, p), d = i; for (let t of D) if (t.removed) { if (t.value.includes(h)) break } else d += t.count; return { formatted: c.formatted, cursorOffset: d, comments: s } } return { formatted: c.formatted, cursorOffset: -1, comments: s } } function F(e, t) { let { ast: r, text: n } = d.parse(e, t), { rangeStart: u, rangeEnd: o } = m.calculateRange(n, t, r), l = n.slice(u, o), c = Math.min(u, n.lastIndexOf("\n", u) + 1), p = n.slice(c, u).match(/^\s*/)[0], D = i(p, t.tabWidth), f = E(l, Object.assign(Object.assign({}, t), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > u && t.cursorOffset <= o ? t.cursorOffset - u : -1, endOfLine: "lf" }), D), g = f.formatted.trimEnd(), { cursorOffset: h } = t; h > o ? h += g.length - l.length : f.cursorOffset >= 0 && (h = f.cursorOffset + u); let y = n.slice(0, u) + g + n.slice(o); if ("lf" !== t.endOfLine) { let e = a(t.endOfLine); h >= 0 && "\r\n" === e && (h += s(y.slice(0, h), "\n")), y = y.replace(/\n/g, e) } return { formatted: y, cursorOffset: h, comments: f.comments } } function A(e, t, r) { return "number" != typeof t || Number.isNaN(t) || t < 0 || t > e.length ? r : t } function b(e, t) { let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t; return r = A(e, r, -1), n = A(e, n, 0), u = A(e, u, e.length), Object.assign(Object.assign({}, t), {}, { cursorOffset: r, rangeStart: n, rangeEnd: u }) } function S(e, t) { let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i } = b(e, t), a = e.charAt(0) === g; if (a && (e = e.slice(1), r--, n--, u--), "auto" === i && (i = o(e)), e.includes("\r")) { let t = t => s(e.slice(0, Math.max(t, 0)), "\r\n"); r -= t(r), n -= t(n), u -= t(u), e = l(e) } return { hasBOM: a, text: e, options: b(e, Object.assign(Object.assign({}, t), {}, { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i })) } } function B(e, t) { let r = d.resolveParser(t); return !r.hasPragma || r.hasPragma(e) } function T(e, t) { let r, { hasBOM: n, text: u, options: i } = S(e, c(t)); return i.rangeStart >= i.rangeEnd && "" !== u || i.requirePragma && !B(u, i) ? { formatted: e, cursorOffset: t.cursorOffset, comments: [] } : (i.rangeStart > 0 || i.rangeEnd < u.length ? r = F(u, i) : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !B(u, i) && (u = i.printer.insertPragma(u)), r = E(u, i)), n && (r.formatted = g + r.formatted, r.cursorOffset >= 0 && r.cursorOffset++), r) } t.exports = { formatWithCursor: T, parse(e, t, r) { let { text: n, options: u } = S(e, c(t)), i = d.parse(n, u); return r && (i.ast = p(i.ast, u)), i }, formatAST(e, t) { t = c(t); let r = f(e, t); return n(r, t) }, formatDoc: (e, t) => T(u(e), Object.assign(Object.assign({}, t), {}, { parser: "__js_expression" })).formatted, printToDoc(e, t) { t = c(t); let { ast: r, text: n } = d.parse(e, t); return y(n, r, t), f(r, t) }, printDocToString: (e, t) => n(e, c(t)) } } }), Xt = m({ "src/common/util-shared.js"(e, t) { C(); var { getMaxContinuousCount: r, getStringWidth: n, getAlignmentSize: u, getIndentSize: i, skip: o, skipWhitespace: a, skipSpaces: s, skipNewline: l, skipToLineEnd: c, skipEverythingButNewLine: p, skipInlineComment: D, skipTrailingComment: d, hasNewline: f, hasNewlineInRange: m, hasSpaces: g, isNextLineEmpty: h, isNextLineEmptyAfterIndex: y, isPreviousLineEmpty: E, getNextNonSpaceNonCommentCharacterIndex: F, makeString: A, addLeadingComment: v, addDanglingComment: b, addTrailingComment: x } = pe(); t.exports = { getMaxContinuousCount: r, getStringWidth: n, getAlignmentSize: u, getIndentSize: i, skip: o, skipWhitespace: a, skipSpaces: s, skipNewline: l, skipToLineEnd: c, skipEverythingButNewLine: p, skipInlineComment: D, skipTrailingComment: d, hasNewline: f, hasNewlineInRange: m, hasSpaces: g, isNextLineEmpty: h, isNextLineEmptyAfterIndex: y, isPreviousLineEmpty: E, getNextNonSpaceNonCommentCharacterIndex: F, makeString: A, addLeadingComment: v, addDanglingComment: b, addTrailingComment: x } } }), Kt = m({ "src/utils/create-language.js"(e, t) { C(), t.exports = function (e, t) { let { languageId: r } = e, n = i(e, u); return Object.assign(Object.assign({ linguistLanguageId: r }, n), t(e)) } } }), Yt = m({ "node_modules/esutils/lib/ast.js"(e, t) { C(), function () { function e(e) { if (null == e) return !1; switch (e.type) { case "ArrayExpression": case "AssignmentExpression": case "BinaryExpression": case "CallExpression": case "ConditionalExpression": case "FunctionExpression": case "Identifier": case "Literal": case "LogicalExpression": case "MemberExpression": case "NewExpression": case "ObjectExpression": case "SequenceExpression": case "ThisExpression": case "UnaryExpression": case "UpdateExpression": return !0 }return !1 } function r(e) { if (null == e) return !1; switch (e.type) { case "DoWhileStatement": case "ForInStatement": case "ForStatement": case "WhileStatement": return !0 }return !1 } function n(e) { if (null == e) return !1; switch (e.type) { case "BlockStatement": case "BreakStatement": case "ContinueStatement": case "DebuggerStatement": case "DoWhileStatement": case "EmptyStatement": case "ExpressionStatement": case "ForInStatement": case "ForStatement": case "IfStatement": case "LabeledStatement": case "ReturnStatement": case "SwitchStatement": case "ThrowStatement": case "TryStatement": case "VariableDeclaration": case "WhileStatement": case "WithStatement": return !0 }return !1 } function u(e) { return n(e) || null != e && "FunctionDeclaration" === e.type } function i(e) { switch (e.type) { case "IfStatement": return null != e.alternate ? e.alternate : e.consequent; case "LabeledStatement": case "ForStatement": case "ForInStatement": case "WhileStatement": case "WithStatement": return e.body }return null } function o(e) { var t; if ("IfStatement" !== e.type || null == e.alternate) return !1; t = e.consequent; do { if ("IfStatement" === t.type && null == t.alternate) return !0; t = i(t) } while (t); return !1 } t.exports = { isExpression: e, isStatement: n, isIterationStatement: r, isSourceElement: u, isProblematicIfStatement: o, trailingStatement: i } }() } }), Qt = m({ "node_modules/esutils/lib/code.js"(e, t) { C(), function () { var e, r, n, u, i, o; function a(e) { return 48 <= e && e <= 57 } function s(e) { return 48 <= e && e <= 57 || 97 <= e && e <= 102 || 65 <= e && e <= 70 } function l(e) { return e >= 48 && e <= 55 } function c(e) { return 32 === e || 9 === e || 11 === e || 12 === e || 160 === e || e >= 5760 && n.indexOf(e) >= 0 } function p(e) { return 10 === e || 13 === e || 8232 === e || 8233 === e } function D(e) { return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(Math.floor((e - 65536) / 1024) + 55296) + String.fromCharCode((e - 65536) % 1024 + 56320) } for (r = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, e = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, n = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], u = new Array(128), o = 0; o < 128; ++o)u[o] = o >= 97 && o <= 122 || o >= 65 && o <= 90 || 36 === o || 95 === o; for (i = new Array(128), o = 0; o < 128; ++o)i[o] = o >= 97 && o <= 122 || o >= 65 && o <= 90 || o >= 48 && o <= 57 || 36 === o || 95 === o; function d(e) { return e < 128 ? u[e] : r.NonAsciiIdentifierStart.test(D(e)) } function f(e) { return e < 128 ? i[e] : r.NonAsciiIdentifierPart.test(D(e)) } function m(t) { return t < 128 ? u[t] : e.NonAsciiIdentifierStart.test(D(t)) } function g(t) { return t < 128 ? i[t] : e.NonAsciiIdentifierPart.test(D(t)) } t.exports = { isDecimalDigit: a, isHexDigit: s, isOctalDigit: l, isWhiteSpace: c, isLineTerminator: p, isIdentifierStartES5: d, isIdentifierPartES5: f, isIdentifierStartES6: m, isIdentifierPartES6: g } }() } }), Zt = m({ "node_modules/esutils/lib/keyword.js"(e, t) { C(), function () { var e = Qt(); function r(e) { switch (e) { case "implements": case "interface": case "package": case "private": case "protected": case "public": case "static": case "let": return !0; default: return !1 } } function n(e, t) { return !(!t && "yield" === e) && u(e, t) } function u(e, t) { if (t && r(e)) return !0; switch (e.length) { case 2: return "if" === e || "in" === e || "do" === e; case 3: return "var" === e || "for" === e || "new" === e || "try" === e; case 4: return "this" === e || "else" === e || "case" === e || "void" === e || "with" === e || "enum" === e; case 5: return "while" === e || "break" === e || "catch" === e || "throw" === e || "const" === e || "yield" === e || "class" === e || "super" === e; case 6: return "return" === e || "typeof" === e || "delete" === e || "switch" === e || "export" === e || "import" === e; case 7: return "default" === e || "finally" === e || "extends" === e; case 8: return "function" === e || "continue" === e || "debugger" === e; case 10: return "instanceof" === e; default: return !1 } } function i(e, t) { return "null" === e || "true" === e || "false" === e || n(e, t) } function o(e, t) { return "null" === e || "true" === e || "false" === e || u(e, t) } function a(e) { return "eval" === e || "arguments" === e } function s(t) { var r, n, u; if (0 === t.length || (u = t.charCodeAt(0), !e.isIdentifierStartES5(u))) return !1; for (r = 1, n = t.length; r < n; ++r)if (u = t.charCodeAt(r), !e.isIdentifierPartES5(u)) return !1; return !0 } function l(e, t) { return 1024 * (e - 55296) + (t - 56320) + 65536 } function c(t) { var r, n, u, i, o; if (0 === t.length) return !1; for (o = e.isIdentifierStartES6, r = 0, n = t.length; r < n; ++r) { if (55296 <= (u = t.charCodeAt(r)) && u <= 56319) { if (++r >= n || !(56320 <= (i = t.charCodeAt(r)) && i <= 57343)) return !1; u = l(u, i) } if (!o(u)) return !1; o = e.isIdentifierPartES6 } return !0 } function p(e, t) { return s(e) && !i(e, t) } function D(e, t) { return c(e) && !o(e, t) } t.exports = { isKeywordES5: n, isKeywordES6: u, isReservedWordES5: i, isReservedWordES6: o, isRestrictedWord: a, isIdentifierNameES5: s, isIdentifierNameES6: c, isIdentifierES5: p, isIdentifierES6: D } }() } }), er = m({ "node_modules/esutils/lib/utils.js"(e) { C(), e.ast = Yt(), e.code = Qt(), e.keyword = Zt() } }), tr = m({ "src/language-js/utils/is-block-comment.js"(e, t) { C(); var r = new Set(["Block", "CommentBlock", "MultiLine"]), n = e => r.has(null == e ? void 0 : e.type); t.exports = n } }), rr = m({ "src/language-js/utils/is-node-matches.js"(e, t) { function r(e, t) { let r = t.split("."); for (let n = r.length - 1; n >= 0; n--) { let t = r[n]; if (0 === n) return "Identifier" === e.type && e.name === t; if ("MemberExpression" !== e.type || e.optional || e.computed || "Identifier" !== e.property.type || e.property.name !== t) return !1; e = e.object } } function n(e, t) { return t.some((t => r(e, t))) } C(), t.exports = n } }), nr = m({ "src/language-js/utils/index.js"(e, t) { C(); var r = er().keyword.isIdentifierNameES5, { getLast: n, hasNewline: u, skipWhitespace: i, isNonEmptyArray: o, isNextLineEmptyAfterIndex: a, getStringWidth: s } = pe(), { locStart: l, locEnd: c, hasSameLocStart: p } = Pt(), D = tr(), d = rr(), f = "(?:(?=.)\\s)", m = new RegExp(`^${f}*:`), g = new RegExp(`^${f}*::`); function h(e) { var t, r; return (null === (t = e.extra) || void 0 === t ? void 0 : t.parenthesized) && D(null === (r = e.trailingComments) || void 0 === r ? void 0 : r[0]) && m.test(e.trailingComments[0].value) } function y(e) { let t = null == e ? void 0 : e[0]; return D(t) && g.test(t.value) } function E(e, t) { if (!e || "object" != typeof e) return !1; if (Array.isArray(e)) return e.some((e => E(e, t))); let r = t(e); return "boolean" == typeof r ? r : Object.values(e).some((e => E(e, t))) } function F(e) { return "AssignmentExpression" === e.type || "BinaryExpression" === e.type || "LogicalExpression" === e.type || "NGPipeExpression" === e.type || "ConditionalExpression" === e.type || K(e) || Y(e) || "SequenceExpression" === e.type || "TaggedTemplateExpression" === e.type || "BindExpression" === e.type || "UpdateExpression" === e.type && !e.prefix || Ue(e) || "TSNonNullExpression" === e.type } function A(e) { var t, r, n, u, i, o; return e.expressions ? e.expressions[0] : null !== (t = null !== (r = null !== (n = null !== (u = null !== (i = null !== (o = e.left) && void 0 !== o ? o : e.test) && void 0 !== i ? i : e.callee) && void 0 !== u ? u : e.object) && void 0 !== n ? n : e.tag) && void 0 !== r ? r : e.argument) && void 0 !== t ? t : e.expression } function v(e, t) { if (t.expressions) return ["expressions", 0]; if (t.left) return ["left"]; if (t.test) return ["test"]; if (t.object) return ["object"]; if (t.callee) return ["callee"]; if (t.tag) return ["tag"]; if (t.argument) return ["argument"]; if (t.expression) return ["expression"]; throw new Error("Unexpected node has no left side.") } function b(e) { return e = new Set(e), t => e.has(null == t ? void 0 : t.type) } var x = b(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), S = b(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]); function B(e) { let t = e.getParentNode(); return "declaration" === e.getName() && S(t) ? t : null } var T = b(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]); function w(e) { return "NumericLiteral" === e.type || "Literal" === e.type && "number" == typeof e.value } function k(e) { return "UnaryExpression" === e.type && ("+" === e.operator || "-" === e.operator) && w(e.argument) } function N(e) { return "StringLiteral" === e.type || "Literal" === e.type && "string" == typeof e.value } var j = b(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), O = b(["FunctionExpression", "ArrowFunctionExpression"]); function I(e) { return "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type && "BlockStatement" === e.body.type } function P(e) { return K(e) && "Identifier" === e.callee.type && ["async", "inject", "fakeAsync", "waitForAsync"].includes(e.callee.name) } var L = b(["JSXElement", "JSXFragment"]); function _(e, t) { if ("markdown" !== e.parentParser && "mdx" !== e.parentParser) return !1; let r = t.getNode(); if (!r.expression || !L(r.expression)) return !1; let n = t.getParentNode(); return "Program" === n.type && 1 === n.body.length } function R(e) { return "get" === e.kind || "set" === e.kind } function M(e) { return R(e) || p(e, e.value) } function $(e) { return !("ObjectTypeProperty" !== e.type && "ObjectTypeInternalSlot" !== e.type || "FunctionTypeAnnotation" !== e.value.type || e.static || M(e)) } function q(e) { return !("TypeAnnotation" !== e.type && "TSTypeAnnotation" !== e.type || "FunctionTypeAnnotation" !== e.typeAnnotation.type || e.static || p(e, e.typeAnnotation)) } var V = b(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]); function U(e) { return Y(e) || "BindExpression" === e.type && Boolean(e.object) } var W = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]); function G(e) { return !(!e || ("GenericTypeAnnotation" !== e.type && "TSTypeReference" !== e.type || e.typeParameters) && !W.has(e.type)) } function z(e) { let t = /^(?:before|after)(?:Each|All)$/; return "Identifier" === e.callee.type && t.test(e.callee.name) && 1 === e.arguments.length } var H = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"]; function J(e) { return d(e, H) } function X(e, t) { if ("CallExpression" !== e.type) return !1; if (1 === e.arguments.length) { if (P(e) && t && X(t)) return O(e.arguments[0]); if (z(e)) return P(e.arguments[0]) } else if ((2 === e.arguments.length || 3 === e.arguments.length) && ("TemplateLiteral" === e.arguments[0].type || N(e.arguments[0])) && J(e.callee)) return !(e.arguments[2] && !w(e.arguments[2])) && ((2 === e.arguments.length ? O(e.arguments[1]) : I(e.arguments[1]) && Se(e.arguments[1]).length <= 1) || P(e.arguments[1])); return !1 } var K = b(["CallExpression", "OptionalCallExpression"]), Y = b(["MemberExpression", "OptionalMemberExpression"]); function Q(e) { let t = "expressions"; "TSTemplateLiteralType" === e.type && (t = "types"); let r = e[t]; return 0 !== r.length && r.every((e => { if (Le(e)) return !1; if ("Identifier" === e.type || "ThisExpression" === e.type) return !0; if (Y(e)) { let t = e; for (; Y(t);)if ("Identifier" !== t.property.type && "Literal" !== t.property.type && "StringLiteral" !== t.property.type && "NumericLiteral" !== t.property.type || (t = t.object, Le(t))) return !1; return "Identifier" === t.type || "ThisExpression" === t.type } return !1 })) } function Z(e, t) { return "+" === e || "-" === e ? e + t : t } function ee(e, t) { let r = l(t), n = i(e, c(t)); return !1 !== n && "/*" === e.slice(r, r + 2) && "*/" === e.slice(n, n + 2) } function te(e, t) { return L(t) ? je(t) : Le(t, Ie.Leading, (t => u(e, c(t)))) } function re(e, t) { return "json" !== t.parser && N(e.key) && De(e.key).slice(1, -1) === e.key.value && (r(e.key.value) && !("babel-ts" === t.parser && "ClassProperty" === e.type || "typescript" === t.parser && "PropertyDefinition" === e.type) || ne(e.key.value) && String(Number(e.key.value)) === e.key.value && ("babel" === t.parser || "acorn" === t.parser || "espree" === t.parser || "meriyah" === t.parser || "__babel_estree" === t.parser)) } function ne(e) { return /^(?:\d+|\d+\.\d+)$/.test(e) } function ue(e, t) { let r = /^[fx]?(?:describe|it|test)$/; return "TaggedTemplateExpression" === t.type && t.quasi === e && "MemberExpression" === t.tag.type && "Identifier" === t.tag.property.type && "each" === t.tag.property.name && ("Identifier" === t.tag.object.type && r.test(t.tag.object.name) || "MemberExpression" === t.tag.object.type && "Identifier" === t.tag.object.property.type && ("only" === t.tag.object.property.name || "skip" === t.tag.object.property.name) && "Identifier" === t.tag.object.object.type && r.test(t.tag.object.object.name)) } function ie(e) { return e.quasis.some((e => e.value.raw.includes("\n"))) } function oe(e, t) { return ("TemplateLiteral" === e.type && ie(e) || "TaggedTemplateExpression" === e.type && ie(e.quasi)) && !u(t, l(e), { backwards: !0 }) } function ae(e) { if (!Le(e)) return !1; let t = n(_e(e, Ie.Dangling)); return t && !D(t) } function se(e) { if (e.length <= 1) return !1; let t = 0; for (let r of e) if (O(r)) { if (t += 1, t > 1) return !0 } else if (K(r)) for (let e of r.arguments) if (O(e)) return !0; return !1 } function le(e) { let t = e.getValue(), r = e.getParentNode(); return K(t) && K(r) && r.callee === t && t.arguments.length > r.arguments.length && r.arguments.length > 0 } function ce(e, t) { if (t >= 2) return !1; let r = e => ce(e, t + 1), n = "Literal" === e.type && "regex" in e && e.regex.pattern || "RegExpLiteral" === e.type && e.pattern; if (n && s(n) > 5) return !1; if ("Literal" === e.type || "BigIntLiteral" === e.type || "DecimalLiteral" === e.type || "BooleanLiteral" === e.type || "NullLiteral" === e.type || "NumericLiteral" === e.type || "RegExpLiteral" === e.type || "StringLiteral" === e.type || "Identifier" === e.type || "ThisExpression" === e.type || "Super" === e.type || "PrivateName" === e.type || "PrivateIdentifier" === e.type || "ArgumentPlaceholder" === e.type || "Import" === e.type) return !0; if ("TemplateLiteral" === e.type) return e.quasis.every((e => !e.value.raw.includes("\n"))) && e.expressions.every(r); if ("ObjectExpression" === e.type) return e.properties.every((e => !e.computed && (e.shorthand || e.value && r(e.value)))); if ("ArrayExpression" === e.type) return e.elements.every((e => null === e || r(e))); if (Me(e)) return ("ImportExpression" === e.type || ce(e.callee, t)) && we(e).every(r); if (Y(e)) return ce(e.object, t) && ce(e.property, t); let u = { "!": !0, "-": !0, "+": !0, "~": !0 }; if ("UnaryExpression" === e.type && u[e.operator]) return ce(e.argument, t); let i = { "++": !0, "--": !0 }; return "UpdateExpression" === e.type && i[e.operator] ? ce(e.argument, t) : "TSNonNullExpression" === e.type && ce(e.expression, t) } function De(e) { var t, r; return null !== (t = null === (r = e.extra) || void 0 === r ? void 0 : r.raw) && void 0 !== t ? t : e.raw } function de(e) { return e } function fe(e) { return e.filepath && /\.tsx$/i.test(e.filepath) } function me(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "es5"; return "es5" === e.trailingComma && "es5" === t || "all" === e.trailingComma && ("all" === t || "es5" === t) } function ge(e, t) { switch (e.type) { case "BinaryExpression": case "LogicalExpression": case "AssignmentExpression": case "NGPipeExpression": return ge(e.left, t); case "MemberExpression": case "OptionalMemberExpression": return ge(e.object, t); case "TaggedTemplateExpression": return "FunctionExpression" !== e.tag.type && ge(e.tag, t); case "CallExpression": case "OptionalCallExpression": return "FunctionExpression" !== e.callee.type && ge(e.callee, t); case "ConditionalExpression": return ge(e.test, t); case "UpdateExpression": return !e.prefix && ge(e.argument, t); case "BindExpression": return e.object && ge(e.object, t); case "SequenceExpression": return ge(e.expressions[0], t); case "TSSatisfiesExpression": case "TSAsExpression": case "TSNonNullExpression": return ge(e.expression, t); default: return t(e) } } var he = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, ye = { "*": !0, "/": !0, "%": !0 }, Ee = { ">>": !0, ">>>": !0, "<<": !0 }; function Ce(e, t) { return !(Ae(t) !== Ae(e) || "**" === e || he[e] && he[t] || "%" === t && ye[e] || "%" === e && ye[t] || t !== e && ye[t] && ye[e] || Ee[e] && Ee[t]) } var Fe = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap(((e, t) => e.map((e => [e, t]))))); function Ae(e) { return Fe.get(e) } function ve(e) { return Boolean(Ee[e]) || "|" === e || "^" === e || "&" === e } function be(e) { var t; if (e.rest) return !0; let r = Se(e); return "RestElement" === (null === (t = n(r)) || void 0 === t ? void 0 : t.type) } var xe = new WeakMap; function Se(e) { if (xe.has(e)) return xe.get(e); let t = []; return e.this && t.push(e.this), Array.isArray(e.parameters) ? t.push(...e.parameters) : Array.isArray(e.params) && t.push(...e.params), e.rest && t.push(e.rest), xe.set(e, t), t } function Be(e, t) { let r = e.getValue(), n = 0, u = e => t(e, n++); r.this && e.call(u, "this"), Array.isArray(r.parameters) ? e.each(u, "parameters") : Array.isArray(r.params) && e.each(u, "params"), r.rest && e.call(u, "rest") } var Te = new WeakMap; function we(e) { if (Te.has(e)) return Te.get(e); let t = e.arguments; return "ImportExpression" === e.type && (t = [e.source], e.attributes && t.push(e.attributes)), Te.set(e, t), t } function ke(e, t) { let r = e.getValue(); "ImportExpression" === r.type ? (e.call((e => t(e, 0)), "source"), r.attributes && e.call((e => t(e, 1)), "attributes")) : e.each(t, "arguments") } function Ne(e) { return "prettier-ignore" === e.value.trim() && !e.unignore } function je(e) { return e && (e.prettierIgnore || Le(e, Ie.PrettierIgnore)) } function Oe(e) { return je(e.getValue()) } var Ie = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Pe = (e, t) => { if ("function" == typeof e && (t = e, e = 0), e || t) return (r, n, u) => !(e & Ie.Leading && !r.leading || e & Ie.Trailing && !r.trailing || e & Ie.Dangling && (r.leading || r.trailing) || e & Ie.Block && !D(r) || e & Ie.Line && !x(r) || e & Ie.First && 0 !== n || e & Ie.Last && n !== u.length - 1 || e & Ie.PrettierIgnore && !Ne(r) || t && !t(r)) }; function Le(e, t, r) { if (!o(null == e ? void 0 : e.comments)) return !1; let n = Pe(t, r); return !n || e.comments.some(n) } function _e(e, t, r) { if (!Array.isArray(null == e ? void 0 : e.comments)) return []; let n = Pe(t, r); return n ? e.comments.filter(n) : e.comments } var Re = (e, t) => { let { originalText: r } = t; return a(r, c(e)) }; function Me(e) { return K(e) || "NewExpression" === e.type || "ImportExpression" === e.type } function $e(e) { return e && ("ObjectProperty" === e.type || "Property" === e.type && !e.method && "init" === e.kind) } function qe(e) { return Boolean(e.__isUsingHackPipeline) } var Ve = Symbol("ifWithoutBlockAndSameLineComment"); function Ue(e) { return "TSAsExpression" === e.type || "TSSatisfiesExpression" === e.type } t.exports = { getFunctionParameters: Se, iterateFunctionParametersPath: Be, getCallArguments: we, iterateCallArgumentsPath: ke, hasRestParameter: be, getLeftSide: A, getLeftSidePathName: v, getParentExportDeclaration: B, getTypeScriptMappedTypeModifier: Z, hasFlowAnnotationComment: y, hasFlowShorthandAnnotationComment: h, hasLeadingOwnLineComment: te, hasNakedLeftSide: F, hasNode: E, hasIgnoreComment: Oe, hasNodeIgnoreComment: je, identity: de, isBinaryish: V, isCallLikeExpression: Me, isEnabledHackPipeline: qe, isLineComment: x, isPrettierIgnoreComment: Ne, isCallExpression: K, isMemberExpression: Y, isExportDeclaration: S, isFlowAnnotationComment: ee, isFunctionCompositionArgs: se, isFunctionNotation: M, isFunctionOrArrowExpression: O, isGetterOrSetter: R, isJestEachTemplateLiteral: ue, isJsxNode: L, isLiteral: T, isLongCurriedCallExpression: le, isSimpleCallArgument: ce, isMemberish: U, isNumericLiteral: w, isSignedNumericLiteral: k, isObjectProperty: $e, isObjectType: j, isObjectTypePropertyAFunction: $, isSimpleType: G, isSimpleNumber: ne, isSimpleTemplateLiteral: Q, isStringLiteral: N, isStringPropSafeToUnquote: re, isTemplateOnItsOwnLine: oe, isTestCall: X, isTheOnlyJsxElementInMarkdown: _, isTSXFile: fe, isTypeAnnotationAFunction: q, isNextLineEmpty: Re, needsHardlineAfterDanglingComment: ae, rawText: De, shouldPrintComma: me, isBitwiseOperator: ve, shouldFlatten: Ce, startsWithNoLookaheadToken: ge, getPrecedence: Ae, hasComment: Le, getComments: _e, CommentCheckFlags: Ie, markerForIfWithoutBlockAndSameLineComment: Ve, isTSTypeExpression: Ue } } }), ur = m({ "src/language-js/print/template-literal.js"(e, t) { C(); var r = S(), { getStringWidth: n, getIndentSize: u } = pe(), { builders: { join: i, hardline: o, softline: a, group: s, indent: l, align: c, lineSuffixBoundary: p, addAlignmentToDoc: D }, printer: { printDocToString: d }, utils: { mapDoc: f } } = V(), { isBinaryish: m, isJestEachTemplateLiteral: g, isSimpleTemplateLiteral: h, hasComment: y, isMemberExpression: E, isTSTypeExpression: F } = nr(); function A(e, t, r) { let n = e.getValue(); if ("TemplateLiteral" === n.type && g(n, e.getParentNode())) { let n = v(e, r, t); if (n) return n } let i = "expressions"; "TSTemplateLiteralType" === n.type && (i = "types"); let o = [], f = e.map(t, i), C = h(n); return C && (f = f.map((e => d(e, Object.assign(Object.assign({}, r), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted))), o.push(p, "`"), e.each((e => { let d = e.getName(); if (o.push(t()), d < f.length) { let { tabWidth: t } = r, g = e.getValue(), h = u(g.value.raw, t), A = f[d]; if (!C) { let e = n[i][d]; (y(e) || E(e) || "ConditionalExpression" === e.type || "SequenceExpression" === e.type || F(e) || m(e)) && (A = [l([a, A]), a]) } let v = 0 === h && g.value.raw.endsWith("\n") ? c(Number.NEGATIVE_INFINITY, A) : D(A, h, t); o.push(s(["${", v, p, "}"])) } }), "quasis"), o.push("`"), o } function v(e, t, u) { let a = e.getNode(), s = a.quasis[0].value.raw.trim().split(/\s*\|\s*/); if (s.length > 1 || s.some((e => e.length > 0))) { t.__inJestEach = !0; let c = e.map(u, "expressions"); t.__inJestEach = !1; let D = [], f = c.map((e => "${" + d(e, Object.assign(Object.assign({}, t), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}")), m = [{ hasLineBreak: !1, cells: [] }]; for (let e = 1; e < a.quasis.length; e++) { let t = r(m), n = f[e - 1]; t.cells.push(n), n.includes("\n") && (t.hasLineBreak = !0), a.quasis[e].value.raw.includes("\n") && m.push({ hasLineBreak: !1, cells: [] }) } let g = Math.max(s.length, ...m.map((e => e.cells.length))), h = Array.from({ length: g }).fill(0), y = [{ cells: s }, ...m.filter((e => e.cells.length > 0))]; for (let { cells: e } of y.filter((e => !e.hasLineBreak))) for (let [t, r] of e.entries()) h[t] = Math.max(h[t], n(r)); return D.push(p, "`", l([o, i(o, y.map((e => i(" | ", e.cells.map(((t, r) => e.hasLineBreak ? t : t + " ".repeat(h[r] - n(t))))))))]), o, "`"), D } } function b(e, t) { let r = e.getValue(), n = t(); return y(r) && (n = s([l([a, n]), a])), ["${", n, p, "}"] } function x(e, t) { return e.map((e => b(e, t)), "expressions") } function B(e, t) { return f(e, (e => "string" == typeof e ? t ? e.replace(/(\\*)`/g, "$1$1\\`") : T(e) : e)) } function T(e) { return e.replace(/([\\`]|\${)/g, "\\$1") } t.exports = { printTemplateLiteral: A, printTemplateExpressions: x, escapeTemplateCharacters: B, uncookTemplateElementValue: T } } }), ir = m({ "src/language-js/embed/markdown.js"(e, t) { C(); var { builders: { indent: r, softline: n, literalline: u, dedentToRoot: i } } = V(), { escapeTemplateCharacters: o } = ur(); function a(e, t, a) { let l = e.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, ((e, t) => "\\".repeat(t.length / 2) + "`")), c = s(l), p = "" !== c; p && (l = l.replace(new RegExp(`^${c}`, "gm"), "")); let D = o(a(l, { parser: "markdown", __inJsTemplate: !0 }, { stripTrailingHardline: !0 }), !0); return ["`", p ? r([n, D]) : [u, i(D)], n, "`"] } function s(e) { let t = e.match(/^([^\S\n]*)\S/m); return null === t ? "" : t[1] } t.exports = a } }), or = m({ "src/language-js/embed/css.js"(e, t) { C(); var { isNonEmptyArray: r } = pe(), { builders: { indent: n, hardline: u, softline: i }, utils: { mapDoc: o, replaceEndOfLine: a, cleanDoc: s } } = V(), { printTemplateExpressions: l } = ur(); function c(e, t, r) { let n = e.getValue(), u = n.quasis.map((e => e.value.raw)), i = 0; return p(r(u.reduce(((e, t, r) => 0 === r ? t : e + "@prettier-placeholder-" + i++ + "-id" + t), ""), { parser: "scss" }, { stripTrailingHardline: !0 }), n, l(e, t)) } function p(e, t, r) { if (1 === t.quasis.length && !t.quasis[0].value.raw.trim()) return "``"; let o = D(e, r); if (!o) throw new Error("Couldn't insert all the expressions"); return ["`", n([u, o]), i, "`"] } function D(e, t) { if (!r(t)) return e; let n = 0, u = o(s(e), (e => "string" == typeof e && e.includes("@prettier-placeholder") ? e.split(/@prettier-placeholder-(\d+)-id/).map(((e, r) => r % 2 == 0 ? a(e) : (n++, t[e]))) : e)); return t.length === n ? u : null } t.exports = c } }), ar = m({ "src/language-js/embed/graphql.js"(e, t) { C(); var { builders: { indent: r, join: n, hardline: u } } = V(), { escapeTemplateCharacters: i, printTemplateExpressions: o } = ur(); function a(e, t, a) { let l = e.getValue(), c = l.quasis.length; if (1 === c && "" === l.quasis[0].value.raw.trim()) return "``"; let p = o(e, t), D = []; for (let r = 0; r < c; r++) { let e = 0 === r, t = r === c - 1, n = l.quasis[r].value.cooked, u = n.split("\n"), o = u.length, d = p[r], f = o > 2 && "" === u[0].trim() && "" === u[1].trim(), m = o > 2 && "" === u[o - 1].trim() && "" === u[o - 2].trim(), g = u.every((e => /^\s*(?:#[^\n\r]*)?$/.test(e))); if (!t && /#[^\n\r]*$/.test(u[o - 1])) return null; let h = null; h = g ? s(u) : a(n, { parser: "graphql" }, { stripTrailingHardline: !0 }), h ? (h = i(h, !1), !e && f && D.push(""), D.push(h), !t && m && D.push("")) : !e && !t && f && D.push(""), d && D.push(d) } return ["`", r([u, n(u, D)]), u, "`"] } function s(e) { let t = [], r = !1, i = e.map((e => e.trim())); for (let [n, o] of i.entries()) "" !== o && ("" === i[n - 1] && r ? t.push([u, o]) : t.push(o), r = !0); return 0 === t.length ? null : n(u, t) } t.exports = a } }), sr = m({ "src/language-js/embed/html.js"(e, t) { C(); var { builders: { indent: r, line: n, hardline: u, group: i }, utils: { mapDoc: o } } = V(), { printTemplateExpressions: a, uncookTemplateElementValue: s } = ur(), l = 0; function c(e, t, c, p, D) { let { parser: d } = D, f = e.getValue(), m = l; l = l + 1 >>> 0; let g = e => `PRETTIER_HTML_PLACEHOLDER_${e}_${m}_IN_JS`, h = f.quasis.map(((e, t, r) => t === r.length - 1 ? e.value.cooked : e.value.cooked + g(t))).join(""), y = a(e, t); if (0 === y.length && 0 === h.trim().length) return "``"; let E = new RegExp(g("(\\d+)"), "g"), C = 0, F = c(h, { parser: d, __onHtmlRoot(e) { C = e.children.length } }, { stripTrailingHardline: !0 }), A = o(F, (e => { if ("string" != typeof e) return e; let t = [], r = e.split(E); for (let n = 0; n < r.length; n++) { let e = r[n]; if (n % 2 == 0) { e && (e = s(e), p.__embeddedInHtml && (e = e.replace(/<\/(script)\b/gi, "<\\/$1")), t.push(e)); continue } let u = Number(e); t.push(y[u]) } return t })), v = /^\s/.test(h) ? " " : "", b = /\s$/.test(h) ? " " : "", x = "ignore" === p.htmlWhitespaceSensitivity ? u : v && b ? n : null; return i(x ? ["`", r([x, i(A)]), x, "`"] : ["`", v, C > 1 ? r(i(A)) : i(A), b, "`"]) } t.exports = c } }), lr = m({ "src/language-js/embed.js"(e, t) { C(); var { hasComment: r, CommentCheckFlags: n, isObjectProperty: u } = nr(), i = ir(), o = or(), a = ar(), s = sr(); function l(e) { return D(e) || g(e) || h(e) || d(e) ? "css" : F(e) ? "graphql" : v(e) ? "html" : f(e) ? "angular" : p(e) ? "markdown" : void 0 } function c(e, t, r, n) { let u = e.getValue(); if ("TemplateLiteral" !== u.type || b(u)) return; let c = l(e); if (c) { if ("markdown" === c) return i(e, t, r); if ("css" === c) return o(e, t, r); if ("graphql" === c) return a(e, t, r); if ("html" === c || "angular" === c) return s(e, t, r, n, { parser: c }) } } function p(e) { let t = e.getValue(), r = e.getParentNode(); return r && "TaggedTemplateExpression" === r.type && 1 === t.quasis.length && "Identifier" === r.tag.type && ("md" === r.tag.name || "markdown" === r.tag.name) } function D(e) { let t = e.getValue(), r = e.getParentNode(), n = e.getParentNode(1); return n && t.quasis && "JSXExpressionContainer" === r.type && "JSXElement" === n.type && "style" === n.openingElement.name.name && n.openingElement.attributes.some((e => "jsx" === e.name.name)) || r && "TaggedTemplateExpression" === r.type && "Identifier" === r.tag.type && "css" === r.tag.name || r && "TaggedTemplateExpression" === r.type && "MemberExpression" === r.tag.type && "css" === r.tag.object.name && ("global" === r.tag.property.name || "resolve" === r.tag.property.name) } function d(e) { return e.match((e => "TemplateLiteral" === e.type), ((e, t) => "ArrayExpression" === e.type && "elements" === t), ((e, t) => u(e) && "Identifier" === e.key.type && "styles" === e.key.name && "value" === t), ...m) } function f(e) { return e.match((e => "TemplateLiteral" === e.type), ((e, t) => u(e) && "Identifier" === e.key.type && "template" === e.key.name && "value" === t), ...m) } var m = [(e, t) => "ObjectExpression" === e.type && "properties" === t, (e, t) => "CallExpression" === e.type && "Identifier" === e.callee.type && "Component" === e.callee.name && "arguments" === t, (e, t) => "Decorator" === e.type && "expression" === t]; function g(e) { let t = e.getParentNode(); if (!t || "TaggedTemplateExpression" !== t.type) return !1; let r = "ParenthesizedExpression" === t.tag.type ? t.tag.expression : t.tag; switch (r.type) { case "MemberExpression": return y(r.object) || E(r); case "CallExpression": return y(r.callee) || "MemberExpression" === r.callee.type && ("MemberExpression" === r.callee.object.type && (y(r.callee.object.object) || E(r.callee.object)) || "CallExpression" === r.callee.object.type && y(r.callee.object.callee)); case "Identifier": return "css" === r.name; default: return !1 } } function h(e) { let t = e.getParentNode(), r = e.getParentNode(1); return r && "JSXExpressionContainer" === t.type && "JSXAttribute" === r.type && "JSXIdentifier" === r.name.type && "css" === r.name.name } function y(e) { return "Identifier" === e.type && "styled" === e.name } function E(e) { return /^[A-Z]/.test(e.object.name) && "extend" === e.property.name } function F(e) { let t = e.getValue(), r = e.getParentNode(); return A(t, "GraphQL") || r && ("TaggedTemplateExpression" === r.type && ("MemberExpression" === r.tag.type && "graphql" === r.tag.object.name && "experimental" === r.tag.property.name || "Identifier" === r.tag.type && ("gql" === r.tag.name || "graphql" === r.tag.name)) || "CallExpression" === r.type && "Identifier" === r.callee.type && "graphql" === r.callee.name) } function A(e, t) { return r(e, n.Block | n.Leading, (e => { let { value: r } = e; return r === ` ${t} ` })) } function v(e) { return A(e.getValue(), "HTML") || e.match((e => "TemplateLiteral" === e.type), ((e, t) => "TaggedTemplateExpression" === e.type && "Identifier" === e.tag.type && "html" === e.tag.name && "quasi" === t)) } function b(e) { let { quasis: t } = e; return t.some((e => { let { value: { cooked: t } } = e; return null === t })) } t.exports = c } }), cr = m({ "src/language-js/clean.js"(e, t) { C(); var r = tr(), n = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), u = e => { for (let t of e.quasis) delete t.value }; function i(e, t, n) { if ("Program" === e.type && delete t.sourceType, ("BigIntLiteral" === e.type || "BigIntLiteralTypeAnnotation" === e.type) && t.value && (t.value = t.value.toLowerCase()), ("BigIntLiteral" === e.type || "Literal" === e.type) && t.bigint && (t.bigint = t.bigint.toLowerCase()), "DecimalLiteral" === e.type && (t.value = Number(t.value)), "Literal" === e.type && t.decimal && (t.decimal = Number(t.decimal)), "EmptyStatement" === e.type || "JSXText" === e.type || "JSXExpressionContainer" === e.type && ("Literal" === e.expression.type || "StringLiteral" === e.expression.type) && " " === e.expression.value) return null; if (("Property" === e.type || "ObjectProperty" === e.type || "MethodDefinition" === e.type || "ClassProperty" === e.type || "ClassMethod" === e.type || "PropertyDefinition" === e.type || "TSDeclareMethod" === e.type || "TSPropertySignature" === e.type || "ObjectTypeProperty" === e.type) && "object" == typeof e.key && e.key && ("Literal" === e.key.type || "NumericLiteral" === e.key.type || "StringLiteral" === e.key.type || "Identifier" === e.key.type) && delete t.key, "JSXElement" === e.type && "style" === e.openingElement.name.name && e.openingElement.attributes.some((e => "jsx" === e.name.name))) for (let { type: r, expression: a } of t.children) "JSXExpressionContainer" === r && "TemplateLiteral" === a.type && u(a); "JSXAttribute" === e.type && "css" === e.name.name && "JSXExpressionContainer" === e.value.type && "TemplateLiteral" === e.value.expression.type && u(t.value.expression), "JSXAttribute" === e.type && e.value && "Literal" === e.value.type && /["']|&quot;|&apos;/.test(e.value.value) && (t.value.value = t.value.value.replace(/["']|&quot;|&apos;/g, '"')); let i = e.expression || e.callee; if ("Decorator" === e.type && "CallExpression" === i.type && "Component" === i.callee.name && 1 === i.arguments.length) { let r = e.expression.arguments[0].properties; for (let [e, n] of t.expression.arguments[0].properties.entries()) switch (r[e].key.name) { case "styles": "ArrayExpression" === n.value.type && u(n.value.elements[0]); break; case "template": "TemplateLiteral" === n.value.type && u(n.value) } } var o; return "TaggedTemplateExpression" === e.type && ("MemberExpression" === e.tag.type || "Identifier" === e.tag.type && ("gql" === e.tag.name || "graphql" === e.tag.name || "css" === e.tag.name || "md" === e.tag.name || "markdown" === e.tag.name || "html" === e.tag.name) || "CallExpression" === e.tag.type) && u(t.quasi), "TemplateLiteral" === e.type && ((null === (o = e.leadingComments) || void 0 === o ? void 0 : o.some((e => r(e) && ["GraphQL", "HTML"].some((t => e.value === ` ${t} `))))) || "CallExpression" === n.type && "graphql" === n.callee.name || !e.leadingComments) && u(t), "InterpreterDirective" === e.type && (t.value = t.value.trimEnd()), "TSIntersectionType" !== e.type && "TSUnionType" !== e.type || 1 !== e.types.length ? void 0 : t.types[0] } i.ignoredProperties = n, t.exports = i } }), pr = {}; function Dr() { if (typeof Sr > "u") { var e = new ArrayBuffer(2), t = new Uint8Array(e), r = new Uint16Array(e); if (t[0] = 1, t[1] = 2, 258 === r[0]) Sr = "BE"; else { if (513 !== r[0]) throw new Error("unable to figure out endianess"); Sr = "LE" } } return Sr } function dr() { return typeof globalThis.location < "u" ? globalThis.location.hostname : "" } function fr() { return [] } function mr() { return 0 } function gr() { return Number.MAX_VALUE } function hr() { return Number.MAX_VALUE } function yr() { return [] } function Er() { return "Browser" } function Cr() { return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "" } function Fr() { } function Ar() { } function vr() { return "javascript" } function br() { return "browser" } function xr() { return "/tmp" } g(pr, { EOL: () => Tr, arch: () => vr, cpus: () => yr, default: () => wr, endianness: () => Dr, freemem: () => gr, getNetworkInterfaces: () => Ar, hostname: () => dr, loadavg: () => fr, networkInterfaces: () => Fr, platform: () => br, release: () => Cr, tmpDir: () => xr, tmpdir: () => Br, totalmem: () => hr, type: () => Er, uptime: () => mr }); var Sr, Br, Tr, wr, kr = f({ "node-modules-polyfills:os"() { C(), wr = { EOL: Tr = "\n", tmpdir: Br = xr, tmpDir: xr, networkInterfaces: Fr, getNetworkInterfaces: Ar, release: Cr, type: Er, cpus: yr, totalmem: hr, freemem: gr, uptime: mr, loadavg: fr, hostname: dr, endianness: Dr } } }), Nr = m({ "node-modules-polyfills-commonjs:os"(e, t) { C(); var r = (kr(), E(pr)); if (r && r.default) { t.exports = r.default; for (let e in r) t.exports[e] = r[e] } else r && (t.exports = r) } }), jr = m({ "node_modules/detect-newline/index.js"(e, t) { C(); var r = e => { if ("string" != typeof e) throw new TypeError("Expected a string"); let t = e.match(/(?:\r?\n)/g) || []; if (0 === t.length) return; let r = t.filter((e => "\r\n" === e)).length; return r > t.length - r ? "\r\n" : "\n" }; t.exports = r, t.exports.graceful = e => "string" == typeof e && r(e) || "\n" } }), Or = m({ "node_modules/jest-docblock/build/index.js"(e) { function t() { let e = Nr(); return t = function () { return e }, e } function r() { let e = n(jr()); return r = function () { return e }, e } function n(e) { return e && e.__esModule ? e : { default: e } } C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.extract = d, e.parse = m, e.parseWithComments = g, e.print = h, e.strip = f; var u = /\*\/$/, i = /^\/\*\*?/, o = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, l = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, c = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p = /(\r?\n|^) *\* ?/g, D = []; function d(e) { let t = e.match(o); return t ? t[0].trimLeft() : "" } function f(e) { let t = e.match(o); return t && t[0] ? e.substring(t[0].length) : e } function m(e) { return g(e).pragmas } function g(e) { let n = (0, r().default)(e) || t().EOL; e = e.replace(i, "").replace(u, "").replace(p, "$1"); let o = ""; for (; o !== e;)o = e, e = e.replace(l, `${n}$1 $2${n}`); e = e.replace(s, "").trimRight(); let d, f = Object.create(null), m = e.replace(c, "").replace(s, "").trimRight(); for (; d = c.exec(e);) { let e = d[2].replace(a, ""); "string" == typeof f[d[1]] || Array.isArray(f[d[1]]) ? f[d[1]] = D.concat(f[d[1]], e) : f[d[1]] = e } return { comments: m, pragmas: f } } function h(e) { let { comments: n = "", pragmas: u = {} } = e, i = (0, r().default)(n) || t().EOL, o = "/**", a = " *", s = " */", l = Object.keys(u), c = l.map((e => y(e, u[e]))).reduce(((e, t) => e.concat(t)), []).map((e => `${a} ${e}${i}`)).join(""); if (!n) { if (0 === l.length) return ""; if (1 === l.length && !Array.isArray(u[l[0]])) { let e = u[l[0]]; return `${o} ${y(l[0], e)[0]}${s}` } } let p = n.split(i).map((e => `${a} ${e}`)).join(i) + i; return o + i + (n ? p : "") + (n && l.length ? a + i : "") + c + s } function y(e, t) { return D.concat(t).map((t => `@${e} ${t}`.trim())) } } }), Ir = m({ "src/language-js/utils/get-shebang.js"(e, t) { function r(e) { if (!e.startsWith("#!")) return ""; let t = e.indexOf("\n"); return -1 === t ? e : e.slice(0, t) } C(), t.exports = r } }), Pr = m({ "src/language-js/pragma.js"(e, t) { C(); var { parseWithComments: r, strip: n, extract: u, print: i } = Or(), { normalizeEndOfLine: o } = x(), a = Ir(); function s(e) { let t = a(e); t && (e = e.slice(t.length + 1)); let n = u(e), { pragmas: i, comments: o } = r(n); return { shebang: t, text: e, pragmas: i, comments: o } } function l(e) { let t = Object.keys(s(e).pragmas); return t.includes("prettier") || t.includes("format") } function c(e) { let { shebang: t, text: r, pragmas: u, comments: a } = s(e), l = n(r), c = i({ pragmas: Object.assign({ format: "" }, u), comments: a.trimStart() }); return (t ? `${t}\n` : "") + o(c) + (l.startsWith("\n") ? "\n" : "\n\n") + l } t.exports = { hasPragma: l, insertPragma: c } } }), Lr = m({ "src/language-js/utils/is-type-cast-comment.js"(e, t) { C(); var r = tr(); function n(e) { return r(e) && "*" === e.value[0] && /@(?:type|satisfies)\b/.test(e.value) } t.exports = n } }), _r = m({ "src/language-js/comments.js"(e, t) { C(); var { getLast: r, hasNewline: n, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: u, getNextNonSpaceNonCommentCharacter: i, hasNewlineInRange: o, addLeadingComment: a, addTrailingComment: s, addDanglingComment: l, getNextNonSpaceNonCommentCharacterIndex: c, isNonEmptyArray: p } = pe(), { getFunctionParameters: D, isPrettierIgnoreComment: d, isJsxNode: f, hasFlowShorthandAnnotationComment: m, hasFlowAnnotationComment: g, hasIgnoreComment: h, isCallLikeExpression: y, getCallArguments: E, isCallExpression: F, isMemberExpression: A, isObjectProperty: v, isLineComment: b, getComments: x, CommentCheckFlags: S, markerForIfWithoutBlockAndSameLineComment: B } = nr(), { locStart: T, locEnd: w } = Pt(), k = tr(), N = Lr(); function j(e) { return [de, Q, q, R, M, $, G, ie, re, ue, oe, ae, H, Z, ee].some((t => t(e))) } function O(e) { return [_, Q, V, oe, R, M, $, G, Z, te, ne, ue, ce, ee, me].some((t => t(e))) } function I(e) { return [de, R, M, U, Y, H, ue, K, X, fe, ee, De].some((t => t(e))) } function P(e, t) { let r = (e.body || e.properties).find((e => { let { type: t } = e; return "EmptyStatement" !== t })); r ? a(r, t) : l(e, t) } function L(e, t) { "BlockStatement" === e.type ? P(e, t) : a(e, t) } function _(e) { let { comment: t, followingNode: r } = e; return !(!r || !N(t) || (a(r, t), 0)) } function R(e) { let { comment: t, precedingNode: r, enclosingNode: n, followingNode: u, text: o } = e; if ("IfStatement" !== (null == n ? void 0 : n.type) || !u) return !1; if (")" === i(o, t, w)) return s(r, t), !0; if (r === n.consequent && u === n.alternate) { if ("BlockStatement" === r.type) s(r, t); else { let e = "SingleLine" === t.type || t.loc.start.line === t.loc.end.line, u = t.loc.start.line === r.loc.start.line; e && u ? l(r, t, B) : l(n, t) } return !0 } return "BlockStatement" === u.type ? (P(u, t), !0) : "IfStatement" === u.type ? (L(u.consequent, t), !0) : n.consequent === u && (a(u, t), !0) } function M(e) { let { comment: t, precedingNode: r, enclosingNode: n, followingNode: u, text: o } = e; return !("WhileStatement" !== (null == n ? void 0 : n.type) || !u || (")" === i(o, t, w) ? (s(r, t), 0) : "BlockStatement" === u.type ? (P(u, t), 0) : n.body !== u || (a(u, t), 0))) } function $(e) { let { comment: t, precedingNode: r, enclosingNode: n, followingNode: u } = e; return !("TryStatement" !== (null == n ? void 0 : n.type) && "CatchClause" !== (null == n ? void 0 : n.type) || !u || ("CatchClause" === n.type && r ? (s(r, t), 0) : "BlockStatement" === u.type ? (P(u, t), 0) : "TryStatement" === u.type ? (L(u.finalizer, t), 0) : "CatchClause" !== u.type || (L(u.body, t), 0))) } function q(e) { let { comment: t, enclosingNode: r, followingNode: n } = e; return !(!A(r) || "Identifier" !== (null == n ? void 0 : n.type) || (a(r, t), 0)) } function V(e) { let { comment: t, precedingNode: r, enclosingNode: n, followingNode: u, text: i } = e, s = r && !o(i, w(r), T(t)); return !(r && s || "ConditionalExpression" !== (null == n ? void 0 : n.type) && "TSConditionalType" !== (null == n ? void 0 : n.type) || !u || (a(u, t), 0)) } function U(e) { let { comment: t, precedingNode: r, enclosingNode: n } = e; return !(!v(n) || !n.shorthand || n.key !== r || "AssignmentPattern" !== n.value.type || (s(n.value.left, t), 0)) } var W = new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]); function G(e) { let { comment: t, precedingNode: n, enclosingNode: u, followingNode: i } = e; if (W.has(null == u ? void 0 : u.type)) { if (p(u.decorators) && (!i || "Decorator" !== i.type)) return s(r(u.decorators), t), !0; if (u.body && i === u.body) return P(u.body, t), !0; if (i) { if (u.superClass && i === u.superClass && n && (n === u.id || n === u.typeParameters)) return s(n, t), !0; for (let e of ["implements", "extends", "mixins"]) if (u[e] && i === u[e][0]) return !n || n !== u.id && n !== u.typeParameters && n !== u.superClass ? l(u, t, e) : s(n, t), !0 } } return !1 } var z = new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]); function H(e) { let { comment: t, precedingNode: r, enclosingNode: n, text: u } = e; return !!(n && r && "(" === i(u, t, w) && ("Property" === n.type || "TSDeclareMethod" === n.type || "TSAbstractMethodDefinition" === n.type) && "Identifier" === r.type && n.key === r && ":" !== i(u, r, w) || "Decorator" === (null == r ? void 0 : r.type) && z.has(null == n ? void 0 : n.type)) && (s(r, t), !0) } var J = new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]); function X(e) { let { comment: t, precedingNode: r, enclosingNode: n, text: u } = e; return !("(" !== i(u, t, w) || !r || !J.has(null == n ? void 0 : n.type) || (s(r, t), 0)) } function K(e) { let { comment: t, enclosingNode: r, text: n } = e; if ("ArrowFunctionExpression" !== (null == r ? void 0 : r.type)) return !1; let u = c(n, t, w); return !1 !== u && "=>" === n.slice(u, u + 2) && (l(r, t), !0) } function Y(e) { let { comment: t, enclosingNode: r, text: n } = e; return !(")" !== i(n, t, w) || (r && (ge(r) && 0 === D(r).length || y(r) && 0 === E(r).length) ? (l(r, t), 0) : "MethodDefinition" !== (null == r ? void 0 : r.type) && "TSAbstractMethodDefinition" !== (null == r ? void 0 : r.type) || 0 !== D(r.value).length || (l(r.value, t), 0))) } function Q(e) { let { comment: t, precedingNode: n, enclosingNode: o, followingNode: a, text: l } = e; if ("FunctionTypeParam" === (null == n ? void 0 : n.type) && "FunctionTypeAnnotation" === (null == o ? void 0 : o.type) && "FunctionTypeParam" !== (null == a ? void 0 : a.type) || ("Identifier" === (null == n ? void 0 : n.type) || "AssignmentPattern" === (null == n ? void 0 : n.type)) && o && ge(o) && ")" === i(l, t, w)) return s(n, t), !0; if ("FunctionDeclaration" === (null == o ? void 0 : o.type) && "BlockStatement" === (null == a ? void 0 : a.type)) { let e = (() => { let e = D(o); if (e.length > 0) return u(l, w(r(e))); let t = u(l, w(o.id)); return !1 !== t && u(l, t + 1) })(); if (T(t) > e) return P(a, t), !0 } return !1 } function Z(e) { let { comment: t, enclosingNode: r } = e; return "LabeledStatement" === (null == r ? void 0 : r.type) && (a(r, t), !0) } function ee(e) { let { comment: t, enclosingNode: r } = e; return !("ContinueStatement" !== (null == r ? void 0 : r.type) && "BreakStatement" !== (null == r ? void 0 : r.type) || r.label || (s(r, t), 0)) } function te(e) { let { comment: t, precedingNode: r, enclosingNode: n } = e; return !!(F(n) && r && n.callee === r && n.arguments.length > 0) && (a(n.arguments[0], t), !0) } function re(e) { let { comment: t, precedingNode: r, enclosingNode: n, followingNode: u } = e; return "UnionTypeAnnotation" === (null == n ? void 0 : n.type) || "TSUnionType" === (null == n ? void 0 : n.type) ? (d(t) && (u.prettierIgnore = !0, t.unignore = !0), !!r && (s(r, t), !0)) : (("UnionTypeAnnotation" === (null == u ? void 0 : u.type) || "TSUnionType" === (null == u ? void 0 : u.type)) && d(t) && (u.types[0].prettierIgnore = !0, t.unignore = !0), !1) } function ne(e) { let { comment: t, enclosingNode: r } = e; return !!v(r) && (a(r, t), !0) } function ue(e) { let { comment: t, enclosingNode: r, followingNode: n, ast: u, isLastComment: i } = e; return u && u.body && 0 === u.body.length ? (i ? l(u, t) : a(u, t), !0) : "Program" !== (null == r ? void 0 : r.type) || 0 !== (null == r ? void 0 : r.body.length) || p(r.directives) ? "Program" === (null == n ? void 0 : n.type) && 0 === (null == n ? void 0 : n.body.length) && "ModuleExpression" === (null == r ? void 0 : r.type) && (l(n, t), !0) : (i ? l(r, t) : a(r, t), !0) } function ie(e) { let { comment: t, enclosingNode: r } = e; return ("ForInStatement" === (null == r ? void 0 : r.type) || "ForOfStatement" === (null == r ? void 0 : r.type)) && (a(r, t), !0) } function oe(e) { let { comment: t, precedingNode: r, enclosingNode: u, text: i } = e; if ("ImportSpecifier" === (null == u ? void 0 : u.type) || "ExportSpecifier" === (null == u ? void 0 : u.type)) return a(u, t), !0; let o = "ImportSpecifier" === (null == r ? void 0 : r.type) && "ImportDeclaration" === (null == u ? void 0 : u.type), l = "ExportSpecifier" === (null == r ? void 0 : r.type) && "ExportNamedDeclaration" === (null == u ? void 0 : u.type); return !(!o && !l || !n(i, w(t)) || (s(r, t), 0)) } function ae(e) { let { comment: t, enclosingNode: r } = e; return "AssignmentPattern" === (null == r ? void 0 : r.type) && (a(r, t), !0) } var se = new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), le = new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]); function ce(e) { let { comment: t, enclosingNode: r, followingNode: n } = e; return !(!se.has(null == r ? void 0 : r.type) || !n || !le.has(n.type) && !k(t) || (a(n, t), 0)) } function De(e) { let { comment: t, enclosingNode: r, followingNode: n, text: u } = e; return !(n || "TSMethodSignature" !== (null == r ? void 0 : r.type) && "TSDeclareFunction" !== (null == r ? void 0 : r.type) && "TSAbstractMethodDefinition" !== (null == r ? void 0 : r.type) || ";" !== i(u, t, w) || (s(r, t), 0)) } function de(e) { let { comment: t, enclosingNode: r, followingNode: n } = e; if (d(t) && "TSMappedType" === (null == r ? void 0 : r.type) && "TSTypeParameter" === (null == n ? void 0 : n.type) && n.constraint) return r.prettierIgnore = !0, t.unignore = !0, !0 } function fe(e) { let { comment: t, precedingNode: r, enclosingNode: n, followingNode: u } = e; return !("TSMappedType" !== (null == n ? void 0 : n.type) || ("TSTypeParameter" === (null == u ? void 0 : u.type) && u.name ? (a(u.name, t), 0) : "TSTypeParameter" !== (null == r ? void 0 : r.type) || !r.constraint || (s(r.constraint, t), 0))) } function me(e) { let { comment: t, enclosingNode: r, followingNode: n } = e; return !(!r || "SwitchCase" !== r.type || r.test || !n || n !== r.consequent[0] || ("BlockStatement" === n.type && b(t) ? P(n, t) : l(r, t), 0)) } function ge(e) { return "ArrowFunctionExpression" === e.type || "FunctionExpression" === e.type || "FunctionDeclaration" === e.type || "ObjectMethod" === e.type || "ClassMethod" === e.type || "TSDeclareFunction" === e.type || "TSCallSignatureDeclaration" === e.type || "TSConstructSignatureDeclaration" === e.type || "TSMethodSignature" === e.type || "TSConstructorType" === e.type || "TSFunctionType" === e.type || "TSDeclareMethod" === e.type } function he(e, t) { if (("typescript" === t.parser || "flow" === t.parser || "acorn" === t.parser || "espree" === t.parser || "meriyah" === t.parser || "__babel_estree" === t.parser) && "MethodDefinition" === e.type && e.value && "FunctionExpression" === e.value.type && 0 === D(e.value).length && !e.value.returnType && !p(e.value.typeParameters) && e.value.body) return [...e.decorators || [], e.key, e.value.body] } function ye(e) { let t = e.getValue(), r = e.getParentNode(), n = e => g(x(e, S.Leading)) || g(x(e, S.Trailing)); return (t && (f(t) || m(t) || F(r) && n(t)) || r && ("JSXSpreadAttribute" === r.type || "JSXSpreadChild" === r.type || "UnionTypeAnnotation" === r.type || "TSUnionType" === r.type || ("ClassDeclaration" === r.type || "ClassExpression" === r.type) && r.superClass === t)) && (!h(e) || "UnionTypeAnnotation" === r.type || "TSUnionType" === r.type) } t.exports = { handleOwnLineComment: j, handleEndOfLineComment: O, handleRemainingComment: I, getCommentChildNodes: he, willPrintOwnComments: ye } } }), Rr = m({ "src/language-js/needs-parens.js"(e, t) { C(); var r = S(), n = ie(), { getFunctionParameters: u, getLeftSidePathName: i, hasFlowShorthandAnnotationComment: o, hasNakedLeftSide: a, hasNode: s, isBitwiseOperator: l, startsWithNoLookaheadToken: c, shouldFlatten: p, getPrecedence: D, isCallExpression: d, isMemberExpression: f, isObjectProperty: m, isTSTypeExpression: g } = nr(); function h(e, t) { let r = e.getParentNode(); if (!r) return !1; let i = e.getName(), a = e.getNode(); if (t.__isInHtmlInterpolation && !t.bracketSpacing && A(a) && v(e)) return !0; if (y(a)) return !1; if ("flow" !== t.parser && o(e.getValue())) return !0; if ("Identifier" === a.type) { if (a.extra && a.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(a.name) || "left" === i && ("async" === a.name && !r.await || "let" === a.name) && "ForOfStatement" === r.type) return !0; if ("let" === a.name) { var s; let t = null === (s = e.findAncestor((e => "ForOfStatement" === e.type))) || void 0 === s ? void 0 : s.left; if (t && c(t, (e => e === a))) return !0 } if ("object" === i && "let" === a.name && "MemberExpression" === r.type && r.computed && !r.optional) { let t = e.findAncestor((e => "ExpressionStatement" === e.type || "ForStatement" === e.type || "ForInStatement" === e.type)), r = t ? "ExpressionStatement" === t.type ? t.expression : "ForStatement" === t.type ? t.init : t.left : void 0; if (r && c(r, (e => e === a))) return !0 } return !1 } if ("ObjectExpression" === a.type || "FunctionExpression" === a.type || "ClassExpression" === a.type || "DoExpression" === a.type) { var h; let t = null === (h = e.findAncestor((e => "ExpressionStatement" === e.type))) || void 0 === h ? void 0 : h.expression; if (t && c(t, (e => e === a))) return !0 } switch (r.type) { case "ParenthesizedExpression": return !1; case "ClassDeclaration": case "ClassExpression": if ("superClass" === i && ("ArrowFunctionExpression" === a.type || "AssignmentExpression" === a.type || "AwaitExpression" === a.type || "BinaryExpression" === a.type || "ConditionalExpression" === a.type || "LogicalExpression" === a.type || "NewExpression" === a.type || "ObjectExpression" === a.type || "SequenceExpression" === a.type || "TaggedTemplateExpression" === a.type || "UnaryExpression" === a.type || "UpdateExpression" === a.type || "YieldExpression" === a.type || "TSNonNullExpression" === a.type)) return !0; break; case "ExportDefaultDeclaration": return b(e, t) || "SequenceExpression" === a.type; case "Decorator": if ("expression" === i) { if (f(a) && a.computed) return !0; let e = !1, r = !1, n = a; for (; n;)switch (n.type) { case "MemberExpression": r = !0, n = n.object; break; case "CallExpression": if (r || e) return "typescript" !== t.parser; e = !0, n = n.callee; break; case "Identifier": return !1; case "TaggedTemplateExpression": return "typescript" !== t.parser; default: return !0 }return !0 } break; case "ArrowFunctionExpression": if ("body" === i && "SequenceExpression" !== a.type && c(a, (e => "ObjectExpression" === e.type))) return !0 }switch (a.type) { case "UpdateExpression": if ("UnaryExpression" === r.type) return a.prefix && ("++" === a.operator && "+" === r.operator || "--" === a.operator && "-" === r.operator); case "UnaryExpression": switch (r.type) { case "UnaryExpression": return a.operator === r.operator && ("+" === a.operator || "-" === a.operator); case "BindExpression": case "TaggedTemplateExpression": case "TSNonNullExpression": return !0; case "MemberExpression": case "OptionalMemberExpression": return "object" === i; case "NewExpression": case "CallExpression": case "OptionalCallExpression": return "callee" === i; case "BinaryExpression": return "left" === i && "**" === r.operator; default: return !1 }case "BinaryExpression": if ("UpdateExpression" === r.type || "in" === a.operator && E(e)) return !0; if ("|>" === a.operator && a.extra && a.extra.parenthesized) { let t = e.getParentNode(1); if ("BinaryExpression" === t.type && "|>" === t.operator) return !0 } case "TSTypeAssertion": case "TSAsExpression": case "TSSatisfiesExpression": case "LogicalExpression": switch (r.type) { case "TSSatisfiesExpression": case "TSAsExpression": return !g(a); case "ConditionalExpression": return g(a); case "CallExpression": case "NewExpression": case "OptionalCallExpression": return "callee" === i; case "ClassExpression": case "ClassDeclaration": return "superClass" === i; case "TSTypeAssertion": case "TaggedTemplateExpression": case "UnaryExpression": case "JSXSpreadAttribute": case "SpreadElement": case "SpreadProperty": case "BindExpression": case "AwaitExpression": case "TSNonNullExpression": case "UpdateExpression": return !0; case "MemberExpression": case "OptionalMemberExpression": return "object" === i; case "AssignmentExpression": case "AssignmentPattern": return "left" === i && ("TSTypeAssertion" === a.type || g(a)); case "LogicalExpression": if ("LogicalExpression" === a.type) return r.operator !== a.operator; case "BinaryExpression": { let { operator: e, type: t } = a; if (!e && "TSTypeAssertion" !== t) return !0; let n = D(e), u = r.operator, o = D(u); return o > n || "right" === i && o === n || o === n && !p(u, e) || (o < n && "%" === e ? "+" === u || "-" === u : !!l(u)) } default: return !1 }case "SequenceExpression": switch (r.type) { case "ReturnStatement": case "ForStatement": return !1; case "ExpressionStatement": return "expression" !== i; case "ArrowFunctionExpression": return "body" !== i; default: return !0 }case "YieldExpression": if ("UnaryExpression" === r.type || "AwaitExpression" === r.type || g(r) || "TSNonNullExpression" === r.type) return !0; case "AwaitExpression": switch (r.type) { case "TaggedTemplateExpression": case "UnaryExpression": case "LogicalExpression": case "SpreadElement": case "SpreadProperty": case "TSAsExpression": case "TSSatisfiesExpression": case "TSNonNullExpression": case "BindExpression": return !0; case "MemberExpression": case "OptionalMemberExpression": return "object" === i; case "NewExpression": case "CallExpression": case "OptionalCallExpression": return "callee" === i; case "ConditionalExpression": return "test" === i; case "BinaryExpression": return !(!a.argument && "|>" === r.operator); default: return !1 }case "TSConditionalType": case "TSFunctionType": case "TSConstructorType": if ("extendsType" === i && "TSConditionalType" === r.type) { if ("TSConditionalType" === a.type) return !0; let { typeAnnotation: e } = a.returnType || a.typeAnnotation; if ("TSTypePredicate" === e.type && e.typeAnnotation && (e = e.typeAnnotation.typeAnnotation), "TSInferType" === e.type && e.typeParameter.constraint) return !0 } if ("checkType" === i && "TSConditionalType" === r.type) return !0; case "TSUnionType": case "TSIntersectionType": if (("TSUnionType" === r.type || "TSIntersectionType" === r.type) && r.types.length > 1 && (!a.types || a.types.length > 1)) return !0; case "TSInferType": if ("TSInferType" === a.type && "TSRestType" === r.type) return !1; case "TSTypeOperator": return "TSArrayType" === r.type || "TSOptionalType" === r.type || "TSRestType" === r.type || "objectType" === i && "TSIndexedAccessType" === r.type || "TSTypeOperator" === r.type || "TSTypeAnnotation" === r.type && e.getParentNode(1).type.startsWith("TSJSDoc"); case "TSTypeQuery": return "objectType" === i && "TSIndexedAccessType" === r.type || "elementType" === i && "TSArrayType" === r.type; case "TypeofTypeAnnotation": return "objectType" === i && ("IndexedAccessType" === r.type || "OptionalIndexedAccessType" === r.type) || "elementType" === i && "ArrayTypeAnnotation" === r.type; case "ArrayTypeAnnotation": return "NullableTypeAnnotation" === r.type; case "IntersectionTypeAnnotation": case "UnionTypeAnnotation": return "ArrayTypeAnnotation" === r.type || "NullableTypeAnnotation" === r.type || "IntersectionTypeAnnotation" === r.type || "UnionTypeAnnotation" === r.type || "objectType" === i && ("IndexedAccessType" === r.type || "OptionalIndexedAccessType" === r.type); case "NullableTypeAnnotation": return "ArrayTypeAnnotation" === r.type || "objectType" === i && ("IndexedAccessType" === r.type || "OptionalIndexedAccessType" === r.type); case "FunctionTypeAnnotation": { let t = "NullableTypeAnnotation" === r.type ? e.getParentNode(1) : r; return "UnionTypeAnnotation" === t.type || "IntersectionTypeAnnotation" === t.type || "ArrayTypeAnnotation" === t.type || "objectType" === i && ("IndexedAccessType" === t.type || "OptionalIndexedAccessType" === t.type) || "NullableTypeAnnotation" === t.type || "FunctionTypeParam" === r.type && null === r.name && u(a).some((e => e.typeAnnotation && "NullableTypeAnnotation" === e.typeAnnotation.type)) } case "OptionalIndexedAccessType": return "objectType" === i && "IndexedAccessType" === r.type; case "StringLiteral": case "NumericLiteral": case "Literal": if ("string" == typeof a.value && "ExpressionStatement" === r.type && !r.directive) { let t = e.getParentNode(1); return "Program" === t.type || "BlockStatement" === t.type } return "object" === i && "MemberExpression" === r.type && "number" == typeof a.value; case "AssignmentExpression": { let t = e.getParentNode(1); return "body" === i && "ArrowFunctionExpression" === r.type || ("key" !== i || "ClassProperty" !== r.type && "PropertyDefinition" !== r.type || !r.computed) && ("init" !== i && "update" !== i || "ForStatement" !== r.type) && ("ExpressionStatement" === r.type ? "ObjectPattern" === a.left.type : !("key" === i && "TSPropertySignature" === r.type || "AssignmentExpression" === r.type || "SequenceExpression" === r.type && t && "ForStatement" === t.type && (t.init === r || t.update === r) || "value" === i && "Property" === r.type && t && "ObjectPattern" === t.type && t.properties.includes(r) || "NGChainedExpression" === r.type)) } case "ConditionalExpression": switch (r.type) { case "TaggedTemplateExpression": case "UnaryExpression": case "SpreadElement": case "SpreadProperty": case "BinaryExpression": case "LogicalExpression": case "NGPipeExpression": case "ExportDefaultDeclaration": case "AwaitExpression": case "JSXSpreadAttribute": case "TSTypeAssertion": case "TypeCastExpression": case "TSAsExpression": case "TSSatisfiesExpression": case "TSNonNullExpression": return !0; case "NewExpression": case "CallExpression": case "OptionalCallExpression": return "callee" === i; case "ConditionalExpression": return "test" === i; case "MemberExpression": case "OptionalMemberExpression": return "object" === i; default: return !1 }case "FunctionExpression": switch (r.type) { case "NewExpression": case "CallExpression": case "OptionalCallExpression": return "callee" === i; case "TaggedTemplateExpression": return !0; default: return !1 }case "ArrowFunctionExpression": switch (r.type) { case "BinaryExpression": return "|>" !== r.operator || a.extra && a.extra.parenthesized; case "NewExpression": case "CallExpression": case "OptionalCallExpression": return "callee" === i; case "MemberExpression": case "OptionalMemberExpression": return "object" === i; case "TSAsExpression": case "TSSatisfiesExpression": case "TSNonNullExpression": case "BindExpression": case "TaggedTemplateExpression": case "UnaryExpression": case "LogicalExpression": case "AwaitExpression": case "TSTypeAssertion": return !0; case "ConditionalExpression": return "test" === i; default: return !1 }case "ClassExpression": return !!n(a.decorators) || "NewExpression" === r.type && "callee" === i; case "OptionalMemberExpression": case "OptionalCallExpression": { let t = e.getParentNode(1); if ("object" === i && "MemberExpression" === r.type || "callee" === i && ("CallExpression" === r.type || "NewExpression" === r.type) || "TSNonNullExpression" === r.type && "MemberExpression" === t.type && t.object === r) return !0 } case "CallExpression": case "MemberExpression": case "TaggedTemplateExpression": case "TSNonNullExpression": if ("callee" === i && ("BindExpression" === r.type || "NewExpression" === r.type)) { let e = a; for (; e;)switch (e.type) { case "CallExpression": case "OptionalCallExpression": return !0; case "MemberExpression": case "OptionalMemberExpression": case "BindExpression": e = e.object; break; case "TaggedTemplateExpression": e = e.tag; break; case "TSNonNullExpression": e = e.expression; break; default: return !1 } } return !1; case "BindExpression": return "callee" === i && ("BindExpression" === r.type || "NewExpression" === r.type) || "object" === i && f(r); case "NGPipeExpression": return !("NGRoot" === r.type || "NGMicrosyntaxExpression" === r.type || "ObjectProperty" === r.type && (!a.extra || !a.extra.parenthesized) || "ArrayExpression" === r.type || d(r) && r.arguments[i] === a || "right" === i && "NGPipeExpression" === r.type || "property" === i && "MemberExpression" === r.type || "AssignmentExpression" === r.type); case "JSXFragment": case "JSXElement": return "callee" === i || "left" === i && "BinaryExpression" === r.type && "<" === r.operator || "ArrayExpression" !== r.type && "ArrowFunctionExpression" !== r.type && "AssignmentExpression" !== r.type && "AssignmentPattern" !== r.type && "BinaryExpression" !== r.type && "NewExpression" !== r.type && "ConditionalExpression" !== r.type && "ExpressionStatement" !== r.type && "JsExpressionRoot" !== r.type && "JSXAttribute" !== r.type && "JSXElement" !== r.type && "JSXExpressionContainer" !== r.type && "JSXFragment" !== r.type && "LogicalExpression" !== r.type && !d(r) && !m(r) && "ReturnStatement" !== r.type && "ThrowStatement" !== r.type && "TypeCastExpression" !== r.type && "VariableDeclarator" !== r.type && "YieldExpression" !== r.type; case "TypeAnnotation": return "returnType" === i && "ArrowFunctionExpression" === r.type && F(a) }return !1 } function y(e) { return "BlockStatement" === e.type || "BreakStatement" === e.type || "ClassBody" === e.type || "ClassDeclaration" === e.type || "ClassMethod" === e.type || "ClassProperty" === e.type || "PropertyDefinition" === e.type || "ClassPrivateProperty" === e.type || "ContinueStatement" === e.type || "DebuggerStatement" === e.type || "DeclareClass" === e.type || "DeclareExportAllDeclaration" === e.type || "DeclareExportDeclaration" === e.type || "DeclareFunction" === e.type || "DeclareInterface" === e.type || "DeclareModule" === e.type || "DeclareModuleExports" === e.type || "DeclareVariable" === e.type || "DoWhileStatement" === e.type || "EnumDeclaration" === e.type || "ExportAllDeclaration" === e.type || "ExportDefaultDeclaration" === e.type || "ExportNamedDeclaration" === e.type || "ExpressionStatement" === e.type || "ForInStatement" === e.type || "ForOfStatement" === e.type || "ForStatement" === e.type || "FunctionDeclaration" === e.type || "IfStatement" === e.type || "ImportDeclaration" === e.type || "InterfaceDeclaration" === e.type || "LabeledStatement" === e.type || "MethodDefinition" === e.type || "ReturnStatement" === e.type || "SwitchStatement" === e.type || "ThrowStatement" === e.type || "TryStatement" === e.type || "TSDeclareFunction" === e.type || "TSEnumDeclaration" === e.type || "TSImportEqualsDeclaration" === e.type || "TSInterfaceDeclaration" === e.type || "TSModuleDeclaration" === e.type || "TSNamespaceExportDeclaration" === e.type || "TypeAlias" === e.type || "VariableDeclaration" === e.type || "WhileStatement" === e.type || "WithStatement" === e.type } function E(e) { let t = 0, r = e.getValue(); for (; r;) { let n = e.getParentNode(t++); if (n && "ForStatement" === n.type && n.init === r) return !0; r = n } return !1 } function F(e) { return s(e, (e => "ObjectTypeAnnotation" === e.type && s(e, (e => "FunctionTypeAnnotation" === e.type || void 0)) || void 0)) } function A(e) { return "ObjectExpression" === e.type } function v(e) { let t = e.getValue(), n = e.getParentNode(), u = e.getName(); switch (n.type) { case "NGPipeExpression": if ("number" == typeof u && n.arguments[u] === t && n.arguments.length - 1 === u) return e.callParent(v); break; case "ObjectProperty": if ("value" === u) { let t = e.getParentNode(1); return r(t.properties) === n } break; case "BinaryExpression": case "LogicalExpression": if ("right" === u) return e.callParent(v); break; case "ConditionalExpression": if ("alternate" === u) return e.callParent(v); break; case "UnaryExpression": if (n.prefix) return e.callParent(v) }return !1 } function b(e, t) { let r = e.getValue(), n = e.getParentNode(); return "FunctionExpression" === r.type || "ClassExpression" === r.type ? "ExportDefaultDeclaration" === n.type || !h(e, t) : !(!a(r) || "ExportDefaultDeclaration" !== n.type && h(e, t)) && e.call((e => b(e, t)), ...i(e, r)) } t.exports = h } }), Mr = m({ "src/language-js/print-preprocess.js"(e, t) { function r(e, t) { switch (t.parser) { case "json": case "json5": case "json-stringify": case "__js_expression": case "__vue_expression": case "__vue_ts_expression": return Object.assign(Object.assign({}, e), {}, { type: t.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e, comments: [], rootMarker: t.rootMarker }); default: return e } } C(), t.exports = r } }), $r = m({ "src/language-js/print/html-binding.js"(e, t) { C(); var { builders: { join: r, line: n, group: u, softline: i, indent: o } } = V(); function a(e, t, a) { let s = e.getValue(); if (t.__onHtmlBindingRoot && null === e.getName() && t.__onHtmlBindingRoot(s, t), "File" === s.type) { if (t.__isVueForBindingLeft) return e.call((e => { let t = r([",", n], e.map(a, "params")), { params: s } = e.getValue(); return 1 === s.length ? t : ["(", o([i, u(t)]), i, ")"] }), "program", "body", 0); if (t.__isVueBindings) return e.call((e => r([",", n], e.map(a, "params"))), "program", "body", 0) } } function s(e) { switch (e.type) { case "MemberExpression": switch (e.property.type) { case "Identifier": case "NumericLiteral": case "StringLiteral": return s(e.object) }return !1; case "Identifier": return !0; default: return !1 } } t.exports = { isVueEventBindingExpression: s, printHtmlBinding: a } } }), qr = m({ "src/language-js/print/binaryish.js"(e, t) { C(); var { printComments: r } = Ut(), { getLast: n } = pe(), { builders: { join: u, line: i, softline: o, group: a, indent: s, align: l, indentIfBreak: c }, utils: { cleanDoc: p, getDocParts: D, isConcat: d } } = V(), { hasLeadingOwnLineComment: f, isBinaryish: m, isJsxNode: g, shouldFlatten: h, hasComment: y, CommentCheckFlags: E, isCallExpression: F, isMemberExpression: A, isObjectProperty: v, isEnabledHackPipeline: b } = nr(), x = 0; function S(e, t, r) { let u = e.getValue(), i = e.getParentNode(), l = e.getParentNode(1), p = u !== i.body && ("IfStatement" === i.type || "WhileStatement" === i.type || "SwitchStatement" === i.type || "DoWhileStatement" === i.type), D = b(t) && "|>" === u.operator, d = B(e, r, t, !1, p); if (p) return d; if (D) return a(d); if (F(i) && i.callee === u || "UnaryExpression" === i.type || A(i) && !i.computed) return a([s([o, ...d]), o]); let f = "ReturnStatement" === i.type || "ThrowStatement" === i.type || "JSXExpressionContainer" === i.type && "JSXAttribute" === l.type || "|" !== u.operator && "JsExpressionRoot" === i.type || "NGPipeExpression" !== u.type && ("NGRoot" === i.type && "__ng_binding" === t.parser || "NGMicrosyntaxExpression" === i.type && "NGMicrosyntax" === l.type && 1 === l.body.length) || u === i.body && "ArrowFunctionExpression" === i.type || u !== i.body && "ForStatement" === i.type || "ConditionalExpression" === i.type && "ReturnStatement" !== l.type && "ThrowStatement" !== l.type && !F(l) || "TemplateLiteral" === i.type, y = "AssignmentExpression" === i.type || "VariableDeclarator" === i.type || "ClassProperty" === i.type || "PropertyDefinition" === i.type || "TSAbstractPropertyDefinition" === i.type || "ClassPrivateProperty" === i.type || v(i), E = m(u.left) && h(u.operator, u.left.operator); if (f || T(u) && !E || !T(u) && y) return a(d); if (0 === d.length) return ""; let C = g(u.right), S = d.findIndex((e => "string" != typeof e && !Array.isArray(e) && "group" === e.type)), w = d.slice(0, -1 === S ? 1 : S + 1), k = d.slice(w.length, C ? -1 : void 0), N = Symbol("logicalChain-" + ++x), j = a([...w, s(k)], { id: N }); if (!C) return j; let O = n(d); return a([j, c(O, { groupId: N })]) } function B(e, t, n, o, c) { let g = e.getValue(); if (!m(g)) return [a(t())]; let C = []; h(g.operator, g.left.operator) ? C = e.call((e => B(e, t, n, !0, c)), "left") : C.push(a(t("left"))); let F, A = T(g), v = ("|>" === g.operator || "NGPipeExpression" === g.type || "|" === g.operator && "__vue_expression" === n.parser) && !f(n.originalText, g.right), x = "NGPipeExpression" === g.type ? "|" : g.operator, S = "NGPipeExpression" === g.type && g.arguments.length > 0 ? a(s([i, ": ", u([i, ": "], e.map(t, "arguments").map((e => l(2, a(e)))))])) : ""; if (A) F = [x, " ", t("right"), S]; else { let r = b(n) && "|>" === x ? e.call((e => B(e, t, n, !0, c)), "right") : t("right"); F = [v ? i : "", x, v ? " " : i, r, S] } let w = e.getParentNode(), k = y(g.left, E.Trailing | E.Line), N = k || !(c && "LogicalExpression" === g.type) && w.type !== g.type && g.left.type !== g.type && g.right.type !== g.type; if (C.push(v ? "" : " ", N ? a(F, { shouldBreak: k }) : F), o && y(g)) { let t = p(r(e, C, n)); return d(t) || "fill" === t.type ? D(t) : [t] } return C } function T(e) { return "LogicalExpression" === e.type && !!("ObjectExpression" === e.right.type && e.right.properties.length > 0 || "ArrayExpression" === e.right.type && e.right.elements.length > 0 || g(e.right)) } t.exports = { printBinaryishExpression: S, shouldInlineLogicalExpression: T } } }), Vr = m({ "src/language-js/print/angular.js"(e, t) { C(); var { builders: { join: r, line: n, group: u } } = V(), { hasNode: i, hasComment: o, getComments: a } = nr(), { printBinaryishExpression: s } = qr(); function l(e, t, i) { let l = e.getValue(); if (l.type.startsWith("NG")) switch (l.type) { case "NGRoot": return [i("node"), o(l.node) ? " //" + a(l.node)[0].value.trimEnd() : ""]; case "NGPipeExpression": return s(e, t, i); case "NGChainedExpression": return u(r([";", n], e.map((e => p(e) ? i() : ["(", i(), ")"]), "expressions"))); case "NGEmptyExpression": return ""; case "NGQuotedExpression": return [l.prefix, ": ", l.value.trim()]; case "NGMicrosyntax": return e.map(((e, t) => [0 === t ? "" : c(e.getValue(), t, l) ? " " : [";", n], i()]), "body"); case "NGMicrosyntaxKey": return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(l.name) ? l.name : JSON.stringify(l.name); case "NGMicrosyntaxExpression": return [i("expression"), null === l.alias ? "" : [" as ", i("alias")]]; case "NGMicrosyntaxKeyedExpression": { let t = e.getName(), r = e.getParentNode(), n = c(l, t, r) || (1 === t && ("then" === l.key.name || "else" === l.key.name) || 2 === t && "else" === l.key.name && "NGMicrosyntaxKeyedExpression" === r.body[t - 1].type && "then" === r.body[t - 1].key.name) && "NGMicrosyntaxExpression" === r.body[0].type; return [i("key"), n ? " " : ": ", i("expression")] } case "NGMicrosyntaxLet": return ["let ", i("key"), null === l.value ? "" : [" = ", i("value")]]; case "NGMicrosyntaxAs": return [i("key"), " as ", i("alias")]; default: throw new Error(`Unknown Angular node type: ${JSON.stringify(l.type)}.`) } } function c(e, t, r) { return "NGMicrosyntaxKeyedExpression" === e.type && "of" === e.key.name && 1 === t && "NGMicrosyntaxLet" === r.body[0].type && null === r.body[0].value } function p(e) { return i(e.getValue(), (e => { switch (e.type) { case void 0: return !1; case "CallExpression": case "OptionalCallExpression": case "AssignmentExpression": return !0 } })) } t.exports = { printAngular: l } } }), Ur = m({ "src/language-js/print/jsx.js"(e, t) { C(); var { printComments: r, printDanglingComments: n, printCommentsSeparately: u } = Ut(), { builders: { line: i, hardline: o, softline: a, group: s, indent: l, conditionalGroup: c, fill: p, ifBreak: D, lineSuffixBoundary: d, join: f }, utils: { willBreak: m } } = V(), { getLast: g, getPreferredQuote: h } = pe(), { isJsxNode: y, rawText: E, isCallExpression: F, isStringLiteral: A, isBinaryish: v, hasComment: b, CommentCheckFlags: x, hasNodeIgnoreComment: S } = nr(), B = Rr(), { willPrintOwnComments: T } = _r(), w = e => "" === e || e === i || e === o || e === a; function k(e, t, r) { let n = e.getValue(); if ("JSXElement" === n.type && Y(n)) return [r("openingElement"), r("closingElement")]; let u = "JSXElement" === n.type ? r("openingElement") : r("openingFragment"), i = "JSXElement" === n.type ? r("closingElement") : r("closingFragment"); if (1 === n.children.length && "JSXExpressionContainer" === n.children[0].type && ("TemplateLiteral" === n.children[0].expression.type || "TaggedTemplateExpression" === n.children[0].expression.type)) return [u, ...e.map(r, "children"), i]; n.children = n.children.map((e => Z(e) ? { type: "JSXText", value: " ", raw: " " } : e)); let d = n.children.some(y), f = n.children.filter((e => "JSXExpressionContainer" === e.type)).length > 1, h = "JSXElement" === n.type && n.openingElement.attributes.length > 1, E = m(u) || d || h || f, C = "mdx" === e.getParentNode().rootMarker, F = t.singleQuote ? "{' '}" : '{" "}', A = C ? " " : D([F, a], " "), v = N(e, t, r, A, n.openingElement && n.openingElement.name && "fbt" === n.openingElement.name.name), b = n.children.some((e => Q(e))); for (let s = v.length - 2; s >= 0; s--) { let e = "" === v[s] && "" === v[s + 1], t = v[s] === o && "" === v[s + 1] && v[s + 2] === o, r = (v[s] === a || v[s] === o) && "" === v[s + 1] && v[s + 2] === A, n = v[s] === A && "" === v[s + 1] && (v[s + 2] === a || v[s + 2] === o), u = v[s] === A && "" === v[s + 1] && v[s + 2] === A, i = v[s] === a && "" === v[s + 1] && v[s + 2] === o || v[s] === o && "" === v[s + 1] && v[s + 2] === a; t && b || e || r || u || i ? v.splice(s, 2) : n && v.splice(s + 1, 2) } for (; v.length > 0 && w(g(v));)v.pop(); for (; v.length > 1 && w(v[0]) && w(v[1]);)v.shift(), v.shift(); let x = []; for (let [a, s] of v.entries()) { if (s === A) { if (1 === a && "" === v[a - 1]) { if (2 === v.length) { x.push(F); continue } x.push([F, o]); continue } if (a === v.length - 1) { x.push(F); continue } if ("" === v[a - 1] && v[a - 2] === o) { x.push(F); continue } } x.push(s), m(s) && (E = !0) } let S = b ? p(x) : s(x, { shouldBreak: !0 }); if (C) return S; let B = s([u, l([o, S]), o, i]); return E ? B : c([s([u, ...v, i]), B]) } function N(e, t, r, n, u) { let a = []; return e.each(((e, t, s) => { let l = e.getValue(); if ("JSXText" === l.type) { let e = E(l); if (Q(l)) { let r, o = e.split(J); if ("" === o[0]) { if (a.push(""), o.shift(), /\n/.test(o[0])) { let e = s[t + 1]; a.push(O(u, o[1], l, e)) } else a.push(n); o.shift() } if ("" === g(o) && (o.pop(), r = o.pop()), 0 === o.length) return; for (let [e, t] of o.entries()) e % 2 == 1 ? a.push(i) : a.push(t); if (void 0 !== r) if (/\n/.test(r)) { let e = s[t + 1]; a.push(O(u, g(a), l, e)) } else a.push(n); else { let e = s[t + 1]; a.push(j(u, g(a), l, e)) } } else /\n/.test(e) ? e.match(/\n/g).length > 1 && a.push("", o) : a.push("", n) } else { let e = r(); a.push(e); let n = s[t + 1]; if (n && Q(n)) { let e = K(E(n)).split(J)[0]; a.push(j(u, e, l, n)) } else a.push(o) } }), "children"), a } function j(e, t, r, n) { return e ? "" : "JSXElement" === r.type && !r.closingElement || n && "JSXElement" === n.type && !n.closingElement ? 1 === t.length ? a : o : a } function O(e, t, r, n) { return e ? o : 1 === t.length ? "JSXElement" === r.type && !r.closingElement || n && "JSXElement" === n.type && !n.closingElement ? o : a : o } function I(e, t, r) { let n = e.getParentNode(); if (!n || { ArrayExpression: !0, JSXAttribute: !0, JSXElement: !0, JSXExpressionContainer: !0, JSXFragment: !0, ExpressionStatement: !0, CallExpression: !0, OptionalCallExpression: !0, ConditionalExpression: !0, JsExpressionRoot: !0 }[n.type]) return t; let u = e.match(void 0, (e => "ArrowFunctionExpression" === e.type), F, (e => "JSXExpressionContainer" === e.type)), i = B(e, r); return s([i ? "" : D("("), l([a, t]), a, i ? "" : D(")")], { shouldBreak: u }) } function P(e, t, r) { let n = e.getValue(), i = []; if (i.push(r("name")), n.value) { let o; if (A(n.value)) { let r = E(n.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: i, quote: a, regex: s } = h(r, t.jsxSingleQuote ? "'" : '"'); r = r.replace(s, i); let { leading: l, trailing: c } = e.call((() => u(e, t)), "value"); o = [l, a, r, a, c] } else o = r("value"); i.push("=", o) } return i } function L(e, t, r) { let n = e.getValue(), u = (e, t) => "JSXEmptyExpression" === e.type || !b(e) && ("ArrayExpression" === e.type || "ObjectExpression" === e.type || "ArrowFunctionExpression" === e.type || "AwaitExpression" === e.type && (u(e.argument, e) || "JSXElement" === e.argument.type) || F(e) || "FunctionExpression" === e.type || "TemplateLiteral" === e.type || "TaggedTemplateExpression" === e.type || "DoExpression" === e.type || y(t) && ("ConditionalExpression" === e.type || v(e))); return u(n.expression, e.getParentNode(0)) ? s(["{", r("expression"), d, "}"]) : s(["{", l([a, r("expression")]), a, d, "}"]) } function _(e, t, r) { let n = e.getValue(), u = n.name && b(n.name) || n.typeParameters && b(n.typeParameters); if (n.selfClosing && 0 === n.attributes.length && !u) return ["<", r("name"), r("typeParameters"), " />"]; if (n.attributes && 1 === n.attributes.length && n.attributes[0].value && A(n.attributes[0].value) && !n.attributes[0].value.value.includes("\n") && !u && !b(n.attributes[0])) return s(["<", r("name"), r("typeParameters"), " ", ...e.map(r, "attributes"), n.selfClosing ? " />" : ">"]); let a = n.attributes && n.attributes.some((e => e.value && A(e.value) && e.value.value.includes("\n"))), c = t.singleAttributePerLine && n.attributes.length > 1 ? o : i; return s(["<", r("name"), r("typeParameters"), l(e.map((() => [c, r()]), "attributes")), ...R(n, t, u)], { shouldBreak: a }) } function R(e, t, r) { return e.selfClosing ? [i, "/>"] : M(e, t, r) ? [">"] : [a, ">"] } function M(e, t, r) { let n = e.attributes.length > 0 && b(g(e.attributes), x.Trailing); return 0 === e.attributes.length && !r || (t.bracketSameLine || t.jsxBracketSameLine) && (!r || e.attributes.length > 0) && !n } function $(e, t, r) { let n = e.getValue(), u = []; u.push("</"); let i = r("name"); return b(n.name, x.Leading | x.Line) ? u.push(l([o, i]), o) : b(n.name, x.Leading | x.Block) ? u.push(" ", i) : u.push(i), u.push(">"), u } function q(e, t) { let r = e.getValue(), u = b(r), i = b(r, x.Line), a = "JSXOpeningFragment" === r.type; return [a ? "<" : "</", l([i ? o : u && !a ? " " : "", n(e, t, !0)]), i ? o : "", ">"] } function U(e, t, n) { return I(e, r(e, k(e, t, n), t), t) } function W(e, t) { let r = e.getValue(), u = b(r, x.Line); return [n(e, t, !u), u ? o : ""] } function G(e, t, n) { let u = e.getValue(); return ["{", e.call((e => { let u = ["...", n()], i = e.getValue(); return b(i) && T(e) ? [l([a, r(e, u, t)]), a] : u }), "JSXSpreadAttribute" === u.type ? "argument" : "expression"), "}"] } function z(e, t, r) { let n = e.getValue(); if (n.type.startsWith("JSX")) switch (n.type) { case "JSXAttribute": return P(e, t, r); case "JSXIdentifier": return String(n.name); case "JSXNamespacedName": return f(":", [r("namespace"), r("name")]); case "JSXMemberExpression": return f(".", [r("object"), r("property")]); case "JSXSpreadAttribute": case "JSXSpreadChild": return G(e, t, r); case "JSXExpressionContainer": return L(e, t, r); case "JSXFragment": case "JSXElement": return U(e, t, r); case "JSXOpeningElement": return _(e, t, r); case "JSXClosingElement": return $(e, t, r); case "JSXOpeningFragment": case "JSXClosingFragment": return q(e, t); case "JSXEmptyExpression": return W(e, t); case "JSXText": throw new Error("JSXText should be handled by JSXElement"); default: throw new Error(`Unknown JSX node type: ${JSON.stringify(n.type)}.`) } } var H = " \n\r\t", J = new RegExp("([" + H + "]+)"), X = new RegExp("[^" + H + "]"), K = e => e.replace(new RegExp("(?:^" + J.source + "|" + J.source + "$)"), ""); function Y(e) { if (0 === e.children.length) return !0; if (e.children.length > 1) return !1; let t = e.children[0]; return "JSXText" === t.type && !Q(t) } function Q(e) { return "JSXText" === e.type && (X.test(E(e)) || !/\n/.test(E(e))) } function Z(e) { return "JSXExpressionContainer" === e.type && A(e.expression) && " " === e.expression.value && !b(e.expression) } function ee(e) { let t = e.getValue(), r = e.getParentNode(); if (!(r && t && y(t) && y(r))) return !1; let n = null; for (let u = r.children.indexOf(t); u > 0; u--) { let e = r.children[u - 1]; if ("JSXText" !== e.type || Q(e)) { n = e; break } } return n && "JSXExpressionContainer" === n.type && "JSXEmptyExpression" === n.expression.type && S(n.expression) } t.exports = { hasJsxIgnoreComment: ee, printJsx: z } } }), Wr = m({ "src/language-js/print/misc.js"(e, t) { C(); var { isNonEmptyArray: r } = pe(), { builders: { indent: n, join: u, line: i } } = V(), { isFlowAnnotationComment: o } = nr(); function a(e) { let t = e.getValue(); return !t.optional || "Identifier" === t.type && t === e.getParentNode().key ? "" : "OptionalCallExpression" === t.type || "OptionalMemberExpression" === t.type && t.computed ? "?." : "?" } function s(e) { return e.getValue().definite || e.match(void 0, ((e, t) => "id" === t && "VariableDeclarator" === e.type && e.definite)) ? "!" : "" } function l(e, t, r) { let n = e.getValue(); return n.typeArguments ? r("typeArguments") : n.typeParameters ? r("typeParameters") : "" } function c(e, t, r) { let n = e.getValue(); if (!n.typeAnnotation) return ""; let u = e.getParentNode(), i = "DeclareFunction" === u.type && u.id === n; return o(t.originalText, n.typeAnnotation) ? [" /*: ", r("typeAnnotation"), " */"] : [i ? "" : ": ", r("typeAnnotation")] } function p(e, t, r) { return ["::", r("callee")] } function D(e, t, n) { let i = e.getValue(); return r(i.modifiers) ? [u(" ", e.map(n, "modifiers")), " "] : "" } function d(e, t, r) { return "EmptyStatement" === e.type ? ";" : "BlockStatement" === e.type || r ? [" ", t] : n([i, t]) } function f(e, t, r) { return ["...", r("argument"), c(e, t, r)] } function m(e, t) { let r = e.slice(1, -1); if (r.includes('"') || r.includes("'")) return e; let n = t.singleQuote ? "'" : '"'; return n + r + n } t.exports = { printOptionalToken: a, printDefiniteToken: s, printFunctionTypeParameters: l, printBindExpressionCallee: p, printTypeScriptModifiers: D, printTypeAnnotation: c, printRestSpread: f, adjustClause: d, printDirective: m } } }), Gr = m({ "src/language-js/print/array.js"(e, t) { C(); var { printDanglingComments: r } = Ut(), { builders: { line: n, softline: u, hardline: i, group: o, indent: a, ifBreak: s, fill: l } } = V(), { getLast: c, hasNewline: p } = pe(), { shouldPrintComma: D, hasComment: d, CommentCheckFlags: f, isNextLineEmpty: m, isNumericLiteral: g, isSignedNumericLiteral: h } = nr(), { locStart: y } = Pt(), { printOptionalToken: E, printTypeAnnotation: F } = Wr(); function A(e, t, n) { let i = e.getValue(), l = [], p = "TupleExpression" === i.type ? "#[" : "[", m = "]"; if (0 === i.elements.length) d(i, f.Dangling) ? l.push(o([p, r(e, t), u, m])) : l.push(p, m); else { let d = c(i.elements), f = !(d && "RestElement" === d.type), g = null === d, h = Symbol("array"), y = !t.__inJestEach && i.elements.length > 1 && i.elements.every(((e, t, r) => { let n = e && e.type; if ("ArrayExpression" !== n && "ObjectExpression" !== n) return !1; let u = r[t + 1]; if (u && n !== u.type) return !1; let i = "ArrayExpression" === n ? "elements" : "properties"; return e[i] && e[i].length > 1 })), E = v(i, t), C = f ? g ? "," : D(t) ? E ? s(",", "", { groupId: h }) : s(",") : "" : ""; l.push(o([p, a([u, E ? x(e, t, n, C) : [b(e, t, "elements", n), C], r(e, t, !0)]), u, m], { shouldBreak: y, id: h })) } return l.push(E(e), F(e, t, n)), l } function v(e, t) { return e.elements.length > 1 && e.elements.every((e => e && (g(e) || h(e) && !d(e.argument)) && !d(e, f.Trailing | f.Line, (e => !p(t.originalText, y(e), { backwards: !0 }))))) } function b(e, t, r, i) { let a = [], s = []; return e.each((e => { a.push(s, o(i())), s = [",", n], e.getValue() && m(e.getValue(), t) && s.push(u) }), r), a } function x(e, t, r, u) { let o = []; return e.each(((e, a, s) => { let l = a === s.length - 1; o.push([r(), l ? u : ","]), l || o.push(m(e.getValue(), t) ? [i, i] : d(s[a + 1], f.Leading | f.Line) ? i : n) }), "elements"), l(o) } t.exports = { printArray: A, printArrayItems: b, isConciselyPrintedArray: v } } }), zr = m({ "src/language-js/print/call-arguments.js"(e, t) { C(); var { printDanglingComments: r } = Ut(), { getLast: n, getPenultimate: u } = pe(), { getFunctionParameters: i, hasComment: o, CommentCheckFlags: a, isFunctionCompositionArgs: s, isJsxNode: l, isLongCurriedCallExpression: c, shouldPrintComma: p, getCallArguments: D, iterateCallArgumentsPath: d, isNextLineEmpty: f, isCallExpression: m, isStringLiteral: g, isObjectProperty: h, isTSTypeExpression: y } = nr(), { builders: { line: E, hardline: F, softline: A, group: v, indent: b, conditionalGroup: x, ifBreak: S, breakParent: B }, utils: { willBreak: T } } = V(), { ArgExpansionBailout: w } = je(), { isConciselyPrintedArray: k } = Gr(); function N(e, t, u) { let i = e.getValue(), o = "ImportExpression" === i.type, a = D(i); if (0 === a.length) return ["(", r(e, t, !0), ")"]; if (P(a)) return ["(", u(["arguments", 0]), ", ", u(["arguments", 1]), ")"]; let l = !1, m = !1, g = a.length - 1, h = []; d(e, ((e, r) => { let n = e.getNode(), i = [u()]; r === g || (f(n, t) ? (0 === r && (m = !0), l = !0, i.push(",", F, F)) : i.push(",", E)), h.push(i) })); let y = o || i.callee && "Import" === i.callee.type || !p(t, "all") ? "" : ","; function C() { return v(["(", b([E, ...h]), y, E, ")"], { shouldBreak: !0 }) } if (l || "Decorator" !== e.getParentNode().type && s(a)) return C(); let k = I(a), N = O(a, t); if (k || N) { if (k ? h.slice(1).some(T) : h.slice(0, -1).some(T)) return C(); let t = []; try { e.try((() => { d(e, ((e, r) => { k && 0 === r && (t = [[u([], { expandFirstArg: !0 }), h.length > 1 ? "," : "", m ? F : E, m ? F : ""], ...h.slice(1)]), N && r === g && (t = [...h.slice(0, -1), u([], { expandLastArg: !0 })]) })) })) } catch (L) { if (L instanceof w) return C(); throw L } return [h.some(T) ? B : "", x([["(", ...t, ")"], k ? ["(", v(t[0], { shouldBreak: !0 }), ...t.slice(1), ")"] : ["(", ...h.slice(0, -1), v(n(t), { shouldBreak: !0 }), ")"], C()])] } let j = ["(", b([A, ...h]), S(y), A, ")"]; return c(e) ? j : v(j, { shouldBreak: h.some(T) || l }) } function j(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; return "ObjectExpression" === e.type && (e.properties.length > 0 || o(e)) || "ArrayExpression" === e.type && (e.elements.length > 0 || o(e)) || "TSTypeAssertion" === e.type && j(e.expression) || y(e) && j(e.expression) || "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type && (!e.returnType || !e.returnType.typeAnnotation || "TSTypeReference" !== e.returnType.typeAnnotation.type || L(e.body)) && ("BlockStatement" === e.body.type || "ArrowFunctionExpression" === e.body.type && j(e.body, !0) || "ObjectExpression" === e.body.type || "ArrayExpression" === e.body.type || !t && (m(e.body) || "ConditionalExpression" === e.body.type) || l(e.body)) || "DoExpression" === e.type || "ModuleExpression" === e.type } function O(e, t) { let r = n(e), i = u(e); return !o(r, a.Leading) && !o(r, a.Trailing) && j(r) && (!i || i.type !== r.type) && (2 !== e.length || "ArrowFunctionExpression" !== i.type || "ArrayExpression" !== r.type) && !(e.length > 1 && "ArrayExpression" === r.type && k(r, t)) } function I(e) { if (2 !== e.length) return !1; let [t, r] = e; return !("ModuleExpression" !== t.type || !_(r)) || !o(t) && ("FunctionExpression" === t.type || "ArrowFunctionExpression" === t.type && "BlockStatement" === t.body.type) && "FunctionExpression" !== r.type && "ArrowFunctionExpression" !== r.type && "ConditionalExpression" !== r.type && !j(r) } function P(e) { return 2 === e.length && "ArrowFunctionExpression" === e[0].type && 0 === i(e[0]).length && "BlockStatement" === e[0].body.type && "ArrayExpression" === e[1].type && !e.some((e => o(e))) } function L(e) { return "BlockStatement" === e.type && (e.body.some((e => "EmptyStatement" !== e.type)) || o(e, a.Dangling)) } function _(e) { return "ObjectExpression" === e.type && 1 === e.properties.length && h(e.properties[0]) && "Identifier" === e.properties[0].key.type && "type" === e.properties[0].key.name && g(e.properties[0].value) && "module" === e.properties[0].value.value } t.exports = N } }), Hr = m({ "src/language-js/print/member.js"(e, t) { C(); var { builders: { softline: r, group: n, indent: u, label: i } } = V(), { isNumericLiteral: o, isMemberExpression: a, isCallExpression: s } = nr(), { printOptionalToken: l } = Wr(); function c(e, t, o) { let l, c = e.getValue(), D = e.getParentNode(), d = 0; do { l = e.getParentNode(d), d++ } while (l && (a(l) || "TSNonNullExpression" === l.type)); let f = o("object"), m = p(e, t, o), g = l && ("NewExpression" === l.type || "BindExpression" === l.type || "AssignmentExpression" === l.type && "Identifier" !== l.left.type) || c.computed || "Identifier" === c.object.type && "Identifier" === c.property.type && !a(D) || ("AssignmentExpression" === D.type || "VariableDeclarator" === D.type) && (s(c.object) && c.object.arguments.length > 0 || "TSNonNullExpression" === c.object.type && s(c.object.expression) && c.object.expression.arguments.length > 0 || "member-chain" === f.label); return i("member-chain" === f.label ? "member-chain" : "member", [f, g ? m : n(u([r, m]))]) } function p(e, t, i) { let a = i("property"), s = e.getValue(), c = l(e); return s.computed ? !s.property || o(s.property) ? [c, "[", a, "]"] : n([c, "[", u([r, a]), r, "]"]) : [c, ".", a] } t.exports = { printMemberExpression: c, printMemberLookup: p } } }), Jr = m({ "src/language-js/print/member-chain.js"(e, t) { C(); var { printComments: r } = Ut(), { getLast: n, isNextLineEmptyAfterIndex: u, getNextNonSpaceNonCommentCharacterIndex: i } = pe(), o = Rr(), { isCallExpression: a, isMemberExpression: s, isFunctionOrArrowExpression: l, isLongCurriedCallExpression: c, isMemberish: p, isNumericLiteral: D, isSimpleCallArgument: d, hasComment: f, CommentCheckFlags: m, isNextLineEmpty: g } = nr(), { locEnd: h } = Pt(), { builders: { join: y, hardline: E, group: F, indent: A, conditionalGroup: v, breakParent: b, label: x }, utils: { willBreak: S } } = V(), B = zr(), { printMemberLookup: T } = Hr(), { printOptionalToken: w, printFunctionTypeParameters: k, printBindExpressionCallee: N } = Wr(); function j(e, t, C) { let j = e.getParentNode(), O = !j || "ExpressionStatement" === j.type, I = []; function P(e) { let { originalText: r } = t, n = i(r, e, h); return ")" === r.charAt(n) ? !1 !== n && u(r, n + 1) : g(e, t) } function L(e) { let n = e.getValue(); a(n) && (p(n.callee) || a(n.callee)) ? (I.unshift({ node: n, printed: [r(e, [w(e), k(e, t, C), B(e, t, C)], t), P(n) ? E : ""] }), e.call((e => L(e)), "callee")) : p(n) ? (I.unshift({ node: n, needsParens: o(e, t), printed: r(e, s(n) ? T(e, t, C) : N(e, t, C), t) }), e.call((e => L(e)), "object")) : "TSNonNullExpression" === n.type ? (I.unshift({ node: n, printed: r(e, "!", t) }), e.call((e => L(e)), "expression")) : I.unshift({ node: n, printed: C() }) } let _ = e.getValue(); I.unshift({ node: _, printed: [w(e), k(e, t, C), B(e, t, C)] }), _.callee && e.call((e => L(e)), "callee"); let R = [], M = [I[0]], $ = 1; for (; $ < I.length && ("TSNonNullExpression" === I[$].node.type || a(I[$].node) || s(I[$].node) && I[$].node.computed && D(I[$].node.property)); ++$)M.push(I[$]); if (!a(I[0].node)) for (; $ + 1 < I.length && p(I[$].node) && p(I[$ + 1].node); ++$)M.push(I[$]); R.push(M), M = []; let q = !1; for (; $ < I.length; ++$) { if (q && p(I[$].node)) { if (I[$].node.computed && D(I[$].node.property)) { M.push(I[$]); continue } R.push(M), M = [], q = !1 } (a(I[$].node) || "ImportExpression" === I[$].node.type) && (q = !0), M.push(I[$]), f(I[$].node, m.Trailing) && (R.push(M), M = [], q = !1) } function V(e) { return /^[A-Z]|^[$_]+$/.test(e) } function U(e) { return e.length <= t.tabWidth } function W(e) { let t = e[1].length > 0 && e[1][0].node.computed; if (1 === e[0].length) { let r = e[0][0].node; return "ThisExpression" === r.type || "Identifier" === r.type && (V(r.name) || O && U(r.name) || t) } let r = n(e[0]).node; return s(r) && "Identifier" === r.property.type && (V(r.property.name) || t) } M.length > 0 && R.push(M); let G = R.length >= 2 && !f(R[1][0].node) && W(R); function z(e) { let t = e.map((e => e.printed)); return e.length > 0 && n(e).needsParens ? ["(", ...t, ")"] : t } function H(e) { return 0 === e.length ? "" : A(F([E, y(E, e.map(z))])) } let J = R.map(z), X = J, K = G ? 3 : 2, Y = R.flat(), Q = Y.slice(1, -1).some((e => f(e.node, m.Leading))) || Y.slice(0, -1).some((e => f(e.node, m.Trailing))) || R[K] && f(R[K][0].node, m.Leading); if (R.length <= K && !Q) return c(e) ? X : F(X); let Z, ee = n(R[G ? 1 : 0]).node, te = !a(ee) && P(ee), re = [z(R[0]), G ? R.slice(1, 2).map(z) : "", te ? E : "", H(R.slice(G ? 2 : 1))], ne = I.map((e => { let { node: t } = e; return t })).filter(a); function ue() { let e = n(n(R)).node, t = n(J); return a(e) && S(t) && ne.slice(0, -1).some((e => e.arguments.some(l))) } return Z = Q || ne.length > 2 && ne.some((e => !e.arguments.every((e => d(e, 0))))) || J.slice(0, -1).some(S) || ue() ? F(re) : [S(X) || te ? b : "", v([X, re])], x("member-chain", Z) } t.exports = j } }), Xr = m({ "src/language-js/print/call-expression.js"(e, t) { C(); var { builders: { join: r, group: n } } = V(), u = Rr(), { getCallArguments: i, hasFlowAnnotationComment: o, isCallExpression: a, isMemberish: s, isStringLiteral: l, isTemplateOnItsOwnLine: c, isTestCall: p, iterateCallArgumentsPath: D } = nr(), d = Jr(), f = zr(), { printOptionalToken: m, printFunctionTypeParameters: g } = Wr(); function h(e, t, l) { let h = e.getValue(), E = e.getParentNode(), C = "NewExpression" === h.type, F = "ImportExpression" === h.type, A = m(e), v = i(h); if (v.length > 0 && (!F && !C && y(h, E) || 1 === v.length && c(v[0], t.originalText) || !C && p(h, E))) { let n = []; return D(e, (() => { n.push(l()) })), [C ? "new " : "", l("callee"), A, g(e, t, l), "(", r(", ", n), ")"] } let b = ("babel" === t.parser || "babel-flow" === t.parser) && h.callee && "Identifier" === h.callee.type && o(h.callee.trailingComments); if (b && (h.callee.trailingComments[0].printed = !0), !F && !C && s(h.callee) && !e.call((e => u(e, t)), "callee")) return d(e, t, l); let x = [C ? "new " : "", F ? "import" : l("callee"), A, b ? `/*:: ${h.callee.trailingComments[0].value.slice(2).trim()} */` : "", g(e, t, l), f(e, t, l)]; return F || a(h.callee) ? n(x) : x } function y(e, t) { if ("Identifier" !== e.callee.type) return !1; if ("require" === e.callee.name) return !0; if ("define" === e.callee.name) { let r = i(e); return "ExpressionStatement" === t.type && (1 === r.length || 2 === r.length && "ArrayExpression" === r[0].type || 3 === r.length && l(r[0]) && "ArrayExpression" === r[1].type) } return !1 } t.exports = { printCallExpression: h } } }), Kr = m({ "src/language-js/print/assignment.js"(e, t) { C(); var { isNonEmptyArray: r, getStringWidth: n } = pe(), { builders: { line: u, group: i, indent: o, indentIfBreak: a, lineSuffixBoundary: s }, utils: { cleanDoc: l, willBreak: c, canBreak: p } } = V(), { hasLeadingOwnLineComment: D, isBinaryish: d, isStringLiteral: f, isLiteral: m, isNumericLiteral: g, isCallExpression: h, isMemberExpression: y, getCallArguments: E, rawText: F, hasComment: A, isSignedNumericLiteral: v, isObjectProperty: b } = nr(), { shouldInlineLogicalExpression: x } = qr(), { printCallExpression: S } = Xr(); function B(e, t, r, n, l, c) { let p = k(e, t, r, n, c), D = r(c, { assignmentLayout: p }); switch (p) { case "break-after-operator": return i([i(n), l, i(o([u, D]))]); case "never-break-after-operator": return i([i(n), l, " ", D]); case "fluid": { let e = Symbol("assignment"); return i([i(n), l, i(o(u), { id: e }), s, a(D, { groupId: e })]) } case "break-lhs": return i([n, l, " ", i(D)]); case "chain": return [i(n), l, u, D]; case "chain-tail": return [i(n), l, o([u, D])]; case "chain-tail-arrow-chain": return [i(n), l, D]; case "only-left": return n } } function T(e, t, r) { let n = e.getValue(); return B(e, t, r, r("left"), [" ", n.operator], "right") } function w(e, t, r) { return B(e, t, r, r("id"), " =", "init") } function k(e, t, r, n, u) { let i = e.getValue(), o = i[u]; if (!o) return "only-left"; let a = !O(o); if (e.match(O, I, (e => !a || "ExpressionStatement" !== e.type && "VariableDeclaration" !== e.type))) return a ? "ArrowFunctionExpression" === o.type && "ArrowFunctionExpression" === o.body.type ? "chain-tail-arrow-chain" : "chain-tail" : "chain"; if (!a && O(o.right) || D(t.originalText, o)) return "break-after-operator"; if ("CallExpression" === o.type && "require" === o.callee.name || "json5" === t.parser || "json" === t.parser) return "never-break-after-operator"; if (j(i) || P(i) || R(i) || M(i) && p(n)) return "break-lhs"; let s = z(i, n, t); return e.call((() => N(e, t, r, s)), u) ? "break-after-operator" : s || "TemplateLiteral" === o.type || "TaggedTemplateExpression" === o.type || "BooleanLiteral" === o.type || g(o) || "ClassExpression" === o.type ? "never-break-after-operator" : "fluid" } function N(e, t, n, u) { let i = e.getValue(); if (d(i) && !x(i)) return !0; switch (i.type) { case "StringLiteralTypeAnnotation": case "SequenceExpression": return !0; case "ConditionalExpression": { let { test: e } = i; return d(e) && !x(e) } case "ClassExpression": return r(i.decorators) }if (u) return !1; let o = i, a = []; for (; ;)if ("UnaryExpression" === o.type) o = o.argument, a.push("argument"); else { if ("TSNonNullExpression" !== o.type) break; o = o.expression, a.push("expression") } return !(!f(o) && !e.call((() => U(e, t, n)), ...a)) } function j(e) { if (I(e)) { let t = e.left || e.id; return "ObjectPattern" === t.type && t.properties.length > 2 && t.properties.some((e => b(e) && (!e.shorthand || e.value && "AssignmentPattern" === e.value.type))) } return !1 } function O(e) { return "AssignmentExpression" === e.type } function I(e) { return O(e) || "VariableDeclarator" === e.type } function P(e) { let t = L(e); if (r(t)) { let r = "TSTypeAliasDeclaration" === e.type ? "constraint" : "bound"; if (t.length > 1 && t.some((e => e[r] || e.default))) return !0 } return !1 } function L(e) { return _(e) && e.typeParameters && e.typeParameters.params ? e.typeParameters.params : null } function _(e) { return "TSTypeAliasDeclaration" === e.type || "TypeAlias" === e.type } function R(e) { if ("VariableDeclarator" !== e.type) return !1; let { typeAnnotation: t } = e.id; if (!t || !t.typeAnnotation) return !1; let n = $(t.typeAnnotation); return r(n) && n.length > 1 && n.some((e => r($(e)) || "TSConditionalType" === e.type)) } function M(e) { return "VariableDeclarator" === e.type && e.init && "ArrowFunctionExpression" === e.init.type } function $(e) { return q(e) && e.typeParameters && e.typeParameters.params ? e.typeParameters.params : null } function q(e) { return "TSTypeReference" === e.type || "GenericTypeAnnotation" === e.type } function U(e, t, r) { let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], u = e.getValue(), i = () => U(e, t, r, !0); if ("TSNonNullExpression" === u.type) return e.call(i, "expression"); if (h(u)) { if ("member-chain" === S(e, t, r).label) return !1; let n = E(u); return !(!(0 === n.length || 1 === n.length && G(n[0], t)) || H(u, r)) && e.call(i, "callee") } return y(u) ? e.call(i, "object") : n && ("Identifier" === u.type || "ThisExpression" === u.type) } var W = .25; function G(e, t) { let { printWidth: r } = t; if (A(e)) return !1; let n = r * W; if ("ThisExpression" === e.type || "Identifier" === e.type && e.name.length <= n || v(e) && !A(e.argument)) return !0; let u = "Literal" === e.type && "regex" in e && e.regex.pattern || "RegExpLiteral" === e.type && e.pattern; return u ? u.length <= n : f(e) ? F(e).length <= n : "TemplateLiteral" === e.type ? 0 === e.expressions.length && e.quasis[0].value.raw.length <= n && !e.quasis[0].value.raw.includes("\n") : m(e) } function z(e, t, r) { if (!b(e)) return !1; let u = 3; return "string" == typeof (t = l(t)) && n(t) < r.tabWidth + u } function H(e, t) { let n = J(e); if (r(n)) { if (n.length > 1) return !0; if (1 === n.length) { let e = n[0]; if ("TSUnionType" === e.type || "UnionTypeAnnotation" === e.type || "TSIntersectionType" === e.type || "IntersectionTypeAnnotation" === e.type || "TSTypeLiteral" === e.type || "ObjectTypeAnnotation" === e.type) return !0 } let r = e.typeParameters ? "typeParameters" : "typeArguments"; if (c(t(r))) return !0 } return !1 } function J(e) { return e.typeParameters && e.typeParameters.params || e.typeArguments && e.typeArguments.params } t.exports = { printVariableDeclarator: w, printAssignmentExpression: T, printAssignment: B, isArrowFunctionVariableDeclarator: M } } }), Yr = m({ "src/language-js/print/function-parameters.js"(e, t) { C(); var { getNextNonSpaceNonCommentCharacter: r } = pe(), { printDanglingComments: n } = Ut(), { builders: { line: u, hardline: i, softline: o, group: a, indent: s, ifBreak: l }, utils: { removeLines: c, willBreak: p } } = V(), { getFunctionParameters: D, iterateFunctionParametersPath: d, isSimpleType: f, isTestCall: m, isTypeAnnotationAFunction: g, isObjectType: h, isObjectTypePropertyAFunction: y, hasRestParameter: E, shouldPrintComma: F, hasComment: A, isNextLineEmpty: v } = nr(), { locEnd: b } = Pt(), { ArgExpansionBailout: x } = je(), { printFunctionTypeParameters: S } = Wr(); function B(e, t, h, C, A) { let B = e.getValue(), w = D(B), k = A ? S(e, h, t) : ""; if (0 === w.length) return [k, "(", n(e, h, !0, (e => ")" === r(h.originalText, e, b))), ")"]; let N = e.getParentNode(), j = m(N), O = T(B), I = []; if (d(e, ((e, r) => { let n = r === w.length - 1; n && B.rest && I.push("..."), I.push(t()), !n && (I.push(","), j || O ? I.push(" ") : v(w[r], h) ? I.push(i, i) : I.push(u)) })), C) { if (p(k) || p(I)) throw new x; return a([c(k), "(", c(I), ")"]) } let P = w.every((e => !e.decorators)); return O && P || j ? [k, "(", ...I, ")"] : (y(N) || g(N) || "TypeAlias" === N.type || "UnionTypeAnnotation" === N.type || "TSUnionType" === N.type || "IntersectionTypeAnnotation" === N.type || "FunctionTypeAnnotation" === N.type && N.returnType === B) && 1 === w.length && null === w[0].name && B.this !== w[0] && w[0].typeAnnotation && null === B.typeParameters && f(w[0].typeAnnotation) && !B.rest ? "always" === h.arrowParens ? ["(", ...I, ")"] : I : [k, "(", s([o, ...I]), l(!E(B) && F(h, "all") ? "," : ""), o, ")"] } function T(e) { if (!e) return !1; let t = D(e); if (1 !== t.length) return !1; let [r] = t; return !A(r) && ("ObjectPattern" === r.type || "ArrayPattern" === r.type || "Identifier" === r.type && r.typeAnnotation && ("TypeAnnotation" === r.typeAnnotation.type || "TSTypeAnnotation" === r.typeAnnotation.type) && h(r.typeAnnotation.typeAnnotation) || "FunctionTypeParam" === r.type && h(r.typeAnnotation) || "AssignmentPattern" === r.type && ("ObjectPattern" === r.left.type || "ArrayPattern" === r.left.type) && ("Identifier" === r.right.type || "ObjectExpression" === r.right.type && 0 === r.right.properties.length || "ArrayExpression" === r.right.type && 0 === r.right.elements.length)) } function w(e) { let t; return e.returnType ? (t = e.returnType, t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t } function k(e, t) { let r = w(e); if (!r) return !1; let n = e.typeParameters && e.typeParameters.params; if (n) { if (n.length > 1) return !1; if (1 === n.length) { let e = n[0]; if (e.constraint || e.default) return !1 } } return 1 === D(e).length && (h(r) || p(t)) } t.exports = { printFunctionParameters: B, shouldHugFunctionParameters: T, shouldGroupFunctionParameters: k } } }), Qr = m({ "src/language-js/print/type-annotation.js"(e, t) { C(); var { printComments: r, printDanglingComments: n } = Ut(), { isNonEmptyArray: u } = pe(), { builders: { group: i, join: o, line: a, softline: s, indent: l, align: c, ifBreak: p } } = V(), D = Rr(), { locStart: d } = Pt(), { isSimpleType: f, isObjectType: m, hasLeadingOwnLineComment: g, isObjectTypePropertyAFunction: h, shouldPrintComma: y } = nr(), { printAssignment: E } = Kr(), { printFunctionParameters: F, shouldGroupFunctionParameters: A } = Yr(), { printArrayItems: v } = Gr(); function b(e) { if (f(e) || m(e)) return !0; if ("UnionTypeAnnotation" === e.type || "TSUnionType" === e.type) { let t = e.types.filter((e => "VoidTypeAnnotation" === e.type || "TSVoidKeyword" === e.type || "NullLiteralTypeAnnotation" === e.type || "TSNullKeyword" === e.type)).length, r = e.types.some((e => "ObjectTypeAnnotation" === e.type || "TSTypeLiteral" === e.type || "GenericTypeAnnotation" === e.type || "TSTypeReference" === e.type)); if (e.types.length - 1 === t && r) return !0 } return !1 } function x(e, t, r) { let n = t.semi ? ";" : "", u = e.getValue(), i = []; return i.push("opaque type ", r("id"), r("typeParameters")), u.supertype && i.push(": ", r("supertype")), u.impltype && i.push(" = ", r("impltype")), i.push(n), i } function S(e, t, r) { let n = t.semi ? ";" : "", u = e.getValue(), i = []; u.declare && i.push("declare "), i.push("type ", r("id"), r("typeParameters")); let o = "TSTypeAliasDeclaration" === u.type ? "typeAnnotation" : "right"; return [E(e, t, r, i, " =", o), n] } function B(e, t, r) { let n = e.getValue(), u = e.map(r, "types"), o = [], s = !1; for (let i = 0; i < u.length; ++i)0 === i ? o.push(u[i]) : m(n.types[i - 1]) && m(n.types[i]) ? o.push([" & ", s ? l(u[i]) : u[i]]) : m(n.types[i - 1]) || m(n.types[i]) ? (i > 1 && (s = !0), o.push(" & ", i > 1 ? l(u[i]) : u[i])) : o.push(l([" &", a, u[i]])); return i(o) } function T(e, t, n) { let u = e.getValue(), d = e.getParentNode(), f = !("TypeParameterInstantiation" === d.type || "TSTypeParameterInstantiation" === d.type || "GenericTypeAnnotation" === d.type || "TSTypeReference" === d.type || "TSTypeAssertion" === d.type || "TupleTypeAnnotation" === d.type || "TSTupleType" === d.type || "FunctionTypeParam" === d.type && !d.name && e.getParentNode(1).this !== d || ("TypeAlias" === d.type || "VariableDeclarator" === d.type || "TSTypeAliasDeclaration" === d.type) && g(t.originalText, u)), m = b(u), h = e.map((e => { let u = n(); return m || (u = c(2, u)), r(e, u, t) }), "types"); if (m) return o(" | ", h); let y = f && !g(t.originalText, u), E = [p([y ? a : "", "| "]), o([a, "| "], h)]; return D(e, t) ? i([l(E), s]) : "TupleTypeAnnotation" === d.type && d.types.length > 1 || "TSTupleType" === d.type && d.elementTypes.length > 1 ? i([l([p(["(", s]), E]), s, p(")")]) : i(f ? l(E) : E) } function w(e, t, r) { let n = e.getValue(), u = [], o = e.getParentNode(0), a = e.getParentNode(1), s = e.getParentNode(2), l = "TSFunctionType" === n.type || !(("ObjectTypeProperty" === o.type || "ObjectTypeInternalSlot" === o.type) && !o.variance && !o.optional && d(o) === d(n) || "ObjectTypeCallProperty" === o.type || s && "DeclareFunction" === s.type), c = l && ("TypeAnnotation" === o.type || "TSTypeAnnotation" === o.type), p = c && l && ("TypeAnnotation" === o.type || "TSTypeAnnotation" === o.type) && "ArrowFunctionExpression" === a.type; h(o) && (l = !0, c = !0), p && u.push("("); let D = F(e, r, t, !1, !0), f = n.returnType || n.predicate || n.typeAnnotation ? [l ? " => " : ": ", r("returnType"), r("predicate"), r("typeAnnotation")] : "", m = A(n, f); return u.push(m ? i(D) : D), f && u.push(f), p && u.push(")"), i(u) } function k(e, t, r) { let o = e.getValue(), a = "TSTupleType" === o.type ? "elementTypes" : "types", c = o[a], D = u(c), d = D ? s : ""; return i(["[", l([d, v(e, t, a, r)]), p(D && y(t, "all") ? "," : ""), n(e, t, !0), d, "]"]) } function N(e, t, r) { let n = e.getValue(), u = "OptionalIndexedAccessType" === n.type && n.optional ? "?.[" : "["; return [r("objectType"), u, r("indexType"), "]"] } function j(e, t, r) { let n = e.getValue(); return [n.postfix ? "" : r, t("typeAnnotation"), n.postfix ? r : ""] } t.exports = { printOpaqueType: x, printTypeAlias: S, printIntersectionType: B, printUnionType: T, printFunctionType: w, printTupleType: k, printIndexedAccessType: N, shouldHugType: b, printJSDocType: j } } }), Zr = m({ "src/language-js/print/type-parameters.js"(e, t) { C(); var { printDanglingComments: r } = Ut(), { builders: { join: n, line: u, hardline: i, softline: o, group: a, indent: s, ifBreak: l } } = V(), { isTestCall: c, hasComment: p, CommentCheckFlags: D, isTSXFile: d, shouldPrintComma: f, getFunctionParameters: m, isObjectType: g, getTypeScriptMappedTypeModifier: h } = nr(), { createGroupIdMapper: y } = pe(), { shouldHugType: E } = Qr(), { isArrowFunctionVariableDeclarator: F } = Kr(), A = y("typeParameters"); function v(e, t, r, i) { let p = e.getValue(); if (!p[i]) return ""; if (!Array.isArray(p[i])) return r(i); let D = e.getNode(2), h = D && c(D), y = e.match((e => !(1 === e[i].length && g(e[i][0]))), void 0, ((e, t) => "typeAnnotation" === t), (e => "Identifier" === e.type), F); if (0 === p[i].length || !y && (h || 1 === p[i].length && ("NullableTypeAnnotation" === p[i][0].type || E(p[i][0])))) return ["<", n(", ", e.map(r, i)), b(e, t), ">"]; let C = "TSTypeParameterInstantiation" === p.type ? "" : 1 === m(p).length && d(t) && !p[i][0].constraint && "ArrowFunctionExpression" === e.getParentNode().type ? "," : f(t, "all") ? l(",") : ""; return a(["<", s([o, n([",", u], e.map(r, i))]), C, o, ">"], { id: A(p) }) } function b(e, t) { let n = e.getValue(); if (!p(n, D.Dangling)) return ""; let u = !p(n, D.Line), o = r(e, t, u); return u ? o : [o, i] } function x(e, t, r) { let n = e.getValue(), u = ["TSTypeParameter" === n.type && n.const ? "const " : ""], i = e.getParentNode(); return "TSMappedType" === i.type ? (i.readonly && u.push(h(i.readonly, "readonly"), " "), u.push("[", r("name")), n.constraint && u.push(" in ", r("constraint")), i.nameType && u.push(" as ", e.callParent((() => r("nameType")))), u.push("]"), u) : (n.variance && u.push(r("variance")), n.in && u.push("in "), n.out && u.push("out "), u.push(r("name")), n.bound && u.push(": ", r("bound")), n.constraint && u.push(" extends ", r("constraint")), n.default && u.push(" = ", r("default")), u) } t.exports = { printTypeParameter: x, printTypeParameters: v, getTypeParametersGroupId: A } } }), en = m({ "src/language-js/print/property.js"(e, t) { C(); var { printComments: r } = Ut(), { printString: n, printNumber: u } = pe(), { isNumericLiteral: i, isSimpleNumber: o, isStringLiteral: a, isStringPropSafeToUnquote: s, rawText: l } = nr(), { printAssignment: c } = Kr(), p = new WeakMap; function D(e, t, c) { let D = e.getNode(); if (D.computed) return ["[", c("key"), "]"]; let d = e.getParentNode(), { key: f } = D; if ("consistent" === t.quoteProps && !p.has(d)) { let e = (d.properties || d.body || d.members).some((e => !e.computed && e.key && a(e.key) && !s(e, t))); p.set(d, e) } if (("Identifier" === f.type || i(f) && o(u(l(f))) && String(f.value) === u(l(f)) && "typescript" !== t.parser && "babel-ts" !== t.parser) && ("json" === t.parser || "consistent" === t.quoteProps && p.get(d))) { let u = n(JSON.stringify("Identifier" === f.type ? f.name : f.value.toString()), t); return e.call((e => r(e, u, t)), "key") } return s(D, t) && ("as-needed" === t.quoteProps || "consistent" === t.quoteProps && !p.get(d)) ? e.call((e => r(e, /^\d/.test(f.value) ? u(f.value) : f.value, t)), "key") : c("key") } function d(e, t, r) { return e.getValue().shorthand ? r("value") : c(e, t, r, D(e, t, r), ":", "value") } t.exports = { printProperty: d, printPropertyKey: D } } }), tn = m({ "src/language-js/print/function.js"(e, t) { C(); var r = Vt(), { printDanglingComments: n, printCommentsSeparately: u } = Ut(), i = S(), { getNextNonSpaceNonCommentCharacterIndex: o } = pe(), { builders: { line: a, softline: s, group: l, indent: c, ifBreak: p, hardline: D, join: d, indentIfBreak: f }, utils: { removeLines: m, willBreak: g } } = V(), { ArgExpansionBailout: h } = je(), { getFunctionParameters: y, hasLeadingOwnLineComment: E, isFlowAnnotationComment: F, isJsxNode: A, isTemplateOnItsOwnLine: v, shouldPrintComma: b, startsWithNoLookaheadToken: x, isBinaryish: B, isLineComment: T, hasComment: w, getComments: k, CommentCheckFlags: N, isCallLikeExpression: j, isCallExpression: O, getCallArguments: I, hasNakedLeftSide: P, getLeftSide: L } = nr(), { locEnd: _ } = Pt(), { printFunctionParameters: R, shouldGroupFunctionParameters: M } = Yr(), { printPropertyKey: $ } = en(), { printFunctionTypeParameters: q } = Wr(); function U(e, t, r, n) { let u = e.getValue(), i = !1; if (("FunctionDeclaration" === u.type || "FunctionExpression" === u.type) && n && n.expandLastArg) { let t = e.getParentNode(); O(t) && I(t).length > 1 && (i = !0) } let o = []; "TSDeclareFunction" === u.type && u.declare && o.push("declare "), u.async && o.push("async "), u.generator ? o.push("function* ") : o.push("function "), u.id && o.push(t("id")); let a = R(e, t, r, i), s = Y(e, t, r), c = M(u, s); return o.push(q(e, r, t), l([c ? l(a) : a, s]), u.body ? " " : "", t("body")), r.semi && (u.declare || !u.body) && o.push(";"), o } function W(e, t, n) { let u = e.getNode(), { kind: i } = u, o = u.value || u, a = []; return i && "init" !== i && "method" !== i && "constructor" !== i ? (r.ok("get" === i || "set" === i), a.push(i, " ")) : o.async && a.push("async "), o.generator && a.push("*"), a.push($(e, t, n), u.optional || u.key.optional ? "?" : ""), u === o ? a.push(G(e, t, n)) : "FunctionExpression" === o.type ? a.push(e.call((e => G(e, t, n)), "value")) : a.push(n("value")), a } function G(e, t, r) { let n = e.getNode(), u = R(e, r, t), i = Y(e, r, t), o = M(n, i), a = [q(e, t, r), l([o ? l(u) : u, i])]; return n.body ? a.push(" ", r("body")) : a.push(t.semi ? ";" : ""), a } function z(e, t, r, u) { let i = []; if (e.getValue().async && i.push("async "), K(e, t)) i.push(r(["params", 0])); else { let n = u && (u.expandLastArg || u.expandFirstArg), o = Y(e, r, t); if (n) { if (g(o)) throw new h; o = l(m(o)) } i.push(l([R(e, r, t, n, !0), o])) } let a = n(e, t, !0, (e => { let r = o(t.originalText, e, _); return !1 !== r && "=>" === t.originalText.slice(r, r + 2) })); return a && i.push(" ", a), i } function H(e, t, r, n, u, i) { let o = e.getName(), D = e.getParentNode(), m = j(D) && "callee" === o, g = Boolean(t && t.assignmentLayout), h = "BlockStatement" !== i.body.type && "ObjectExpression" !== i.body.type && "SequenceExpression" !== i.body.type, y = m && h || t && "chain-tail-arrow-chain" === t.assignmentLayout, E = Symbol("arrow-chain"); return "SequenceExpression" === i.body.type && (u = l(["(", c([s, u]), s, ")"])), l([l(c([m || g ? s : "", l(d([" =>", a], r), { shouldBreak: n })]), { id: E, shouldBreak: y }), " =>", f(h ? c([a, u]) : [" ", u], { groupId: E }), m ? p(s, "", { groupId: E }) : ""]) } function J(e, t, r, n) { let i = e.getValue(), o = [], D = [], d = !1; if (function a() { let s = z(e, t, r, n); if (0 === o.length) o.push(s); else { let { leading: r, trailing: n } = u(e, t); o.push([r, s]), D.unshift(n) } d = d || i.returnType && y(i).length > 0 || i.typeParameters || y(i).some((e => "Identifier" !== e.type)), "ArrowFunctionExpression" !== i.body.type || n && n.expandLastArg ? D.unshift(r("body", n)) : (i = i.body, e.call(a, "body")) }(), o.length > 1) return H(e, n, o, d, D, i); let f = o; if (f.push(" =>"), !E(t.originalText, i.body) && ("ArrayExpression" === i.body.type || "ObjectExpression" === i.body.type || "BlockStatement" === i.body.type || A(i.body) || v(i.body, t.originalText) || "ArrowFunctionExpression" === i.body.type || "DoExpression" === i.body.type)) return l([...f, " ", D]); if ("SequenceExpression" === i.body.type) return l([...f, l([" (", c([s, D]), s, ")"])]); let m = (n && n.expandLastArg || "JSXExpressionContainer" === e.getParentNode().type) && !w(i), g = n && n.expandLastArg && b(t, "all"), h = "ConditionalExpression" === i.body.type && !x(i.body, (e => "ObjectExpression" === e.type)); return l([...f, l([c([a, h ? p("", "(") : "", D, h ? p("", ")") : ""]), m ? [p(g ? "," : ""), s] : ""])]) } function X(e) { let t = y(e); return !(1 !== t.length || e.typeParameters || w(e, N.Dangling) || "Identifier" !== t[0].type || t[0].typeAnnotation || w(t[0]) || t[0].optional || e.predicate || e.returnType) } function K(e, t) { return "always" !== t.arrowParens && "avoid" === t.arrowParens && X(e.getValue()) } function Y(e, t, r) { let n = e.getValue(), u = t("returnType"); if (n.returnType && F(r.originalText, n.returnType)) return [" /*: ", u, " */"]; let i = [u]; return n.returnType && n.returnType.typeAnnotation && i.unshift(": "), n.predicate && i.push(n.returnType ? " " : ": ", t("predicate")), i } function Q(e, t, r) { let u = e.getValue(), o = t.semi ? ";" : "", a = []; u.argument && (te(t, u.argument) ? a.push([" (", c([D, r("argument")]), D, ")"]) : B(u.argument) || "SequenceExpression" === u.argument.type ? a.push(l([p(" (", " "), c([s, r("argument")]), s, p(")")])) : a.push(" ", r("argument"))); let d = k(u), f = i(d), m = f && T(f); return m && a.push(o), w(u, N.Dangling) && a.push(" ", n(e, t, !0)), m || a.push(o), a } function Z(e, t, r) { return ["return", Q(e, t, r)] } function ee(e, t, r) { return ["throw", Q(e, t, r)] } function te(e, t) { if (E(e.originalText, t)) return !0; if (P(t)) { let r, n = t; for (; r = L(n);)if (n = r, E(e.originalText, n)) return !0 } return !1 } t.exports = { printFunction: U, printArrowFunction: J, printMethod: W, printReturnStatement: Z, printThrowStatement: ee, printMethodInternal: G, shouldPrintParamsWithoutParens: K } } }), rn = m({ "src/language-js/print/decorators.js"(e, t) { C(); var { isNonEmptyArray: r, hasNewline: n } = pe(), { builders: { line: u, hardline: i, join: o, breakParent: a, group: s } } = V(), { locStart: l, locEnd: c } = Pt(), { getParentExportDeclaration: p } = nr(); function D(e, t, r) { let n = e.getValue(); return s([o(u, e.map(r, "decorators")), m(n, t) ? i : u]) } function d(e, t, r) { return [o(i, e.map(r, "declaration", "decorators")), i] } function f(e, t, n) { let s = e.getValue(), { decorators: l } = s; if (!r(l) || g(e.getParentNode())) return; let c = "ClassExpression" === s.type || "ClassDeclaration" === s.type || m(s, t); return [p(e) ? i : c ? a : "", o(u, e.map(n, "decorators")), u] } function m(e, t) { return e.decorators.some((e => n(t.originalText, c(e)))) } function g(e) { if ("ExportDefaultDeclaration" !== e.type && "ExportNamedDeclaration" !== e.type && "DeclareExportDeclaration" !== e.type) return !1; let t = e.declaration && e.declaration.decorators; return r(t) && l(e) === l(t[0]) } t.exports = { printDecorators: f, printClassMemberDecorators: D, printDecoratorsBeforeExport: d, hasDecoratorsBeforeExport: g } } }), nn = m({ "src/language-js/print/class.js"(e, t) { C(); var { isNonEmptyArray: r, createGroupIdMapper: n } = pe(), { printComments: u, printDanglingComments: i } = Ut(), { builders: { join: o, line: a, hardline: s, softline: l, group: c, indent: p, ifBreak: D } } = V(), { hasComment: d, CommentCheckFlags: f } = nr(), { getTypeParametersGroupId: m } = Zr(), { printMethod: g } = tn(), { printOptionalToken: h, printTypeAnnotation: y, printDefiniteToken: E } = Wr(), { printPropertyKey: F } = en(), { printAssignment: A } = Kr(), { printClassMemberDecorators: v } = rn(); function b(e, t, n) { let i = e.getValue(), o = []; i.declare && o.push("declare "), i.abstract && o.push("abstract "), o.push("class"); let s = i.id && d(i.id, f.Trailing) || i.typeParameters && d(i.typeParameters, f.Trailing) || i.superClass && d(i.superClass) || r(i.extends) || r(i.mixins) || r(i.implements), l = [], D = []; if (i.id && l.push(" ", n("id")), l.push(n("typeParameters")), i.superClass) { let r = [k(e, t, n), n("superTypeParameters")], i = e.call((e => ["extends ", u(e, r, t)]), "superClass"); s ? D.push(a, c(i)) : D.push(" ", i) } else D.push(w(e, t, n, "extends")); if (D.push(w(e, t, n, "mixins"), w(e, t, n, "implements")), s) { let e; e = T(i) ? [...l, p(D)] : p([...l, D]), o.push(c(e, { id: x(i) })) } else o.push(...l, ...D); return o.push(" ", n("body")), o } var x = n("heritageGroup"); function S(e) { return D(s, "", { groupId: x(e) }) } function B(e) { return ["superClass", "extends", "mixins", "implements"].filter((t => Boolean(e[t]))).length > 1 } function T(e) { return e.typeParameters && !d(e.typeParameters, f.Trailing | f.Line) && !B(e) } function w(e, t, n, u) { let l = e.getValue(); if (!r(l[u])) return ""; let d = i(e, t, !0, (e => { let { marker: t } = e; return t === u })); return [T(l) ? D(" ", a, { groupId: m(l.typeParameters) }) : a, d, d && s, u, c(p([a, o([",", a], e.map(n, u))]))] } function k(e, t, r) { let n = r("superClass"); return "AssignmentExpression" === e.getParentNode().type ? c(D(["(", p([l, n]), l, ")"], n)) : n } function N(e, t, n) { let u = e.getValue(), i = []; return r(u.decorators) && i.push(v(e, t, n)), u.accessibility && i.push(u.accessibility + " "), u.readonly && i.push("readonly "), u.declare && i.push("declare "), u.static && i.push("static "), ("TSAbstractMethodDefinition" === u.type || u.abstract) && i.push("abstract "), u.override && i.push("override "), i.push(g(e, t, n)), i } function j(e, t, n) { let u = e.getValue(), i = [], o = t.semi ? ";" : ""; return r(u.decorators) && i.push(v(e, t, n)), u.accessibility && i.push(u.accessibility + " "), u.declare && i.push("declare "), u.static && i.push("static "), ("TSAbstractPropertyDefinition" === u.type || "TSAbstractAccessorProperty" === u.type || u.abstract) && i.push("abstract "), u.override && i.push("override "), u.readonly && i.push("readonly "), u.variance && i.push(n("variance")), ("ClassAccessorProperty" === u.type || "AccessorProperty" === u.type || "TSAbstractAccessorProperty" === u.type) && i.push("accessor "), i.push(F(e, t, n), h(e), E(e), y(e, t, n)), [A(e, t, n, i, " =", "value"), o] } t.exports = { printClass: b, printClassMethod: N, printClassProperty: j, printHardlineAfterHeritage: S } } }), un = m({ "src/language-js/print/interface.js"(e, t) { C(); var { isNonEmptyArray: r } = pe(), { builders: { join: n, line: u, group: i, indent: o, ifBreak: a } } = V(), { hasComment: s, identity: l, CommentCheckFlags: c } = nr(), { getTypeParametersGroupId: p } = Zr(), { printTypeScriptModifiers: D } = Wr(); function d(e, t, d) { let f = e.getValue(), m = []; f.declare && m.push("declare "), "TSInterfaceDeclaration" === f.type && m.push(f.abstract ? "abstract " : "", D(e, t, d)), m.push("interface"); let g = [], h = []; "InterfaceTypeAnnotation" !== f.type && g.push(" ", d("id"), d("typeParameters")); let y = f.typeParameters && !s(f.typeParameters, c.Trailing | c.Line); return r(f.extends) && h.push(y ? a(" ", u, { groupId: p(f.typeParameters) }) : u, "extends ", (1 === f.extends.length ? l : o)(n([",", u], e.map(d, "extends")))), f.id && s(f.id, c.Trailing) || r(f.extends) ? y ? m.push(i([...g, o(h)])) : m.push(i(o([...g, ...h]))) : m.push(...g, ...h), m.push(" ", d("body")), i(m) } t.exports = { printInterface: d } } }), on = m({ "src/language-js/print/module.js"(e, t) { C(); var { isNonEmptyArray: r } = pe(), { builders: { softline: n, group: u, indent: i, join: o, line: a, ifBreak: s, hardline: l } } = V(), { printDanglingComments: c } = Ut(), { hasComment: p, CommentCheckFlags: D, shouldPrintComma: d, needsHardlineAfterDanglingComment: f, isStringLiteral: m, rawText: g } = nr(), { locStart: h, hasSameLoc: y } = Pt(), { hasDecoratorsBeforeExport: E, printDecoratorsBeforeExport: F } = rn(); function A(e, t, r) { let n = e.getValue(), u = t.semi ? ";" : "", i = [], { importKind: o } = n; return i.push("import"), o && "value" !== o && i.push(" ", o), i.push(B(e, t, r), S(e, t, r), w(e, t, r), u), i } function v(e, t, r) { let n = e.getValue(), u = []; E(n) && u.push(F(e, t, r)); let { type: i, exportKind: o, declaration: a } = n; return u.push("export"), (n.default || "ExportDefaultDeclaration" === i) && u.push(" default"), p(n, D.Dangling) && (u.push(" ", c(e, t, !0)), f(n) && u.push(l)), a ? u.push(" ", r("declaration")) : u.push("type" === o ? " type" : "", B(e, t, r), S(e, t, r), w(e, t, r)), x(n, t) && u.push(";"), u } function b(e, t, r) { let n = e.getValue(), u = t.semi ? ";" : "", i = [], { exportKind: o, exported: a } = n; return i.push("export"), "type" === o && i.push(" type"), i.push(" *"), a && i.push(" as ", r("exported")), i.push(S(e, t, r), w(e, t, r), u), i } function x(e, t) { if (!t.semi) return !1; let { type: r, declaration: n } = e, u = e.default || "ExportDefaultDeclaration" === r; if (!n) return !0; let { type: i } = n; return !(!u || "ClassDeclaration" === i || "FunctionDeclaration" === i || "TSInterfaceDeclaration" === i || "DeclareClass" === i || "DeclareFunction" === i || "TSDeclareFunction" === i || "EnumDeclaration" === i) } function S(e, t, r) { let n = e.getValue(); if (!n.source) return ""; let u = []; return T(n, t) || u.push(" from"), u.push(" ", r("source")), u } function B(e, t, l) { let c = e.getValue(); if (T(c, t)) return ""; let D = [" "]; if (r(c.specifiers)) { let r = [], f = []; e.each((() => { let t = e.getValue().type; if ("ExportNamespaceSpecifier" === t || "ExportDefaultSpecifier" === t || "ImportNamespaceSpecifier" === t || "ImportDefaultSpecifier" === t) r.push(l()); else { if ("ExportSpecifier" !== t && "ImportSpecifier" !== t) throw new Error(`Unknown specifier type ${JSON.stringify(t)}`); f.push(l()) } }), "specifiers"), D.push(o(", ", r)), f.length > 0 && (r.length > 0 && D.push(", "), f.length > 1 || r.length > 0 || c.specifiers.some((e => p(e))) ? D.push(u(["{", i([t.bracketSpacing ? a : n, o([",", a], f)]), s(d(t) ? "," : ""), t.bracketSpacing ? a : n, "}"])) : D.push(["{", t.bracketSpacing ? " " : "", ...f, t.bracketSpacing ? " " : "", "}"])) } else D.push("{}"); return D } function T(e, t) { let { type: n, importKind: u, source: i, specifiers: o } = e; return "ImportDeclaration" === n && !r(o) && "type" !== u && !/{\s*}/.test(t.originalText.slice(h(e), h(i))) } function w(e, t, n) { let u = e.getNode(); return r(u.assertions) ? [" assert {", t.bracketSpacing ? " " : "", o(", ", e.map(n, "assertions")), t.bracketSpacing ? " " : "", "}"] : "" } function k(e, t, r) { let n = e.getNode(), { type: u } = n, i = [], o = "ImportSpecifier" === u ? n.importKind : n.exportKind; o && "value" !== o && i.push(o, " "); let a = u.startsWith("Import"), s = a ? "imported" : "local", l = a ? "local" : "exported", c = n[s], p = n[l], D = "", d = ""; return "ExportNamespaceSpecifier" === u || "ImportNamespaceSpecifier" === u ? D = "*" : c && (D = r(s)), p && !N(n) && (d = r(l)), i.push(D, D && d ? " as " : "", d), i } function N(e) { if ("ImportSpecifier" !== e.type && "ExportSpecifier" !== e.type) return !1; let { local: t, ["ImportSpecifier" === e.type ? "imported" : "exported"]: r } = e; return !(t.type !== r.type || !y(t, r)) && (m(t) ? t.value === r.value && g(t) === g(r) : "Identifier" === t.type && t.name === r.name) } t.exports = { printImportDeclaration: A, printExportDeclaration: v, printExportAllDeclaration: b, printModuleSpecifier: k } } }), an = m({ "src/language-js/print/object.js"(e, t) { C(); var { printDanglingComments: r } = Ut(), { builders: { line: n, softline: u, group: i, indent: o, ifBreak: a, hardline: s } } = V(), { getLast: l, hasNewlineInRange: c, hasNewline: p, isNonEmptyArray: D } = pe(), { shouldPrintComma: d, hasComment: f, getComments: m, CommentCheckFlags: g, isNextLineEmpty: h } = nr(), { locStart: y, locEnd: E } = Pt(), { printOptionalToken: F, printTypeAnnotation: A } = Wr(), { shouldHugFunctionParameters: v } = Yr(), { shouldHugType: b } = Qr(), { printHardlineAfterHeritage: x } = nn(); function S(e, t, C) { let S, B = t.semi ? ";" : "", T = e.getValue(); S = "TSTypeLiteral" === T.type ? "members" : "TSInterfaceBody" === T.type ? "body" : "properties"; let w = "ObjectTypeAnnotation" === T.type, k = [S]; w && k.push("indexers", "callProperties", "internalSlots"); let N = k.map((e => T[e][0])).sort(((e, t) => y(e) - y(t)))[0], j = e.getParentNode(0), O = w && j && ("InterfaceDeclaration" === j.type || "DeclareInterface" === j.type || "DeclareClass" === j.type) && "body" === e.getName(), I = "TSInterfaceBody" === T.type || O || "ObjectPattern" === T.type && "FunctionDeclaration" !== j.type && "FunctionExpression" !== j.type && "ArrowFunctionExpression" !== j.type && "ObjectMethod" !== j.type && "ClassMethod" !== j.type && "ClassPrivateMethod" !== j.type && "AssignmentPattern" !== j.type && "CatchClause" !== j.type && T.properties.some((e => e.value && ("ObjectPattern" === e.value.type || "ArrayPattern" === e.value.type))) || "ObjectPattern" !== T.type && N && c(t.originalText, y(T), y(N)), P = O ? ";" : "TSInterfaceBody" === T.type || "TSTypeLiteral" === T.type ? a(B, ";") : ",", L = "RecordExpression" === T.type ? "#{" : T.exact ? "{|" : "{", _ = T.exact ? "|}" : "}", R = []; for (let r of k) e.each((e => { let t = e.getValue(); R.push({ node: t, printed: C(), loc: y(t) }) }), r); k.length > 1 && R.sort(((e, t) => e.loc - t.loc)); let M = [], $ = R.map((e => { let r = [...M, i(e.printed)]; return M = [P, n], ("TSPropertySignature" === e.node.type || "TSMethodSignature" === e.node.type || "TSConstructSignatureDeclaration" === e.node.type) && f(e.node, g.PrettierIgnore) && M.shift(), h(e.node, t) && M.push(s), r })); if (T.inexact) { let u; if (f(T, g.Dangling)) { let i = f(T, g.Line); u = [r(e, t, !0), i || p(t.originalText, E(l(m(T)))) ? s : n, "..."] } else u = ["..."]; $.push([...M, ...u]) } let q, V = l(T[S]), U = !(T.inexact || V && "RestElement" === V.type || V && ("TSPropertySignature" === V.type || "TSCallSignatureDeclaration" === V.type || "TSMethodSignature" === V.type || "TSConstructSignatureDeclaration" === V.type) && f(V, g.PrettierIgnore)); if (0 === $.length) { if (!f(T, g.Dangling)) return [L, _, A(e, t, C)]; q = i([L, r(e, t), u, _, F(e), A(e, t, C)]) } else q = [O && D(T.properties) ? x(j) : "", L, o([t.bracketSpacing ? n : u, ...$]), a(U && ("," !== P || d(t)) ? P : ""), t.bracketSpacing ? n : u, _, F(e), A(e, t, C)]; return e.match((e => "ObjectPattern" === e.type && !e.decorators), ((e, t, r) => v(e) && ("params" === t || "parameters" === t || "this" === t || "rest" === t) && 0 === r)) || e.match(b, ((e, t) => "typeAnnotation" === t), ((e, t) => "typeAnnotation" === t), ((e, t, r) => v(e) && ("params" === t || "parameters" === t || "this" === t || "rest" === t) && 0 === r)) || !I && e.match((e => "ObjectPattern" === e.type), (e => "AssignmentExpression" === e.type || "VariableDeclarator" === e.type)) ? q : i(q, { shouldBreak: I }) } t.exports = { printObject: S } } }), sn = m({ "src/language-js/print/flow.js"(e, t) { C(); var r = Vt(), { printDanglingComments: n } = Ut(), { printString: u, printNumber: i } = pe(), { builders: { hardline: o, softline: a, group: s, indent: l } } = V(), { getParentExportDeclaration: c, isFunctionNotation: p, isGetterOrSetter: D, rawText: d, shouldPrintComma: f } = nr(), { locStart: m, locEnd: g } = Pt(), { replaceTextEndOfLine: h } = M(), { printClass: y } = nn(), { printOpaqueType: E, printTypeAlias: F, printIntersectionType: A, printUnionType: v, printFunctionType: b, printTupleType: x, printIndexedAccessType: S } = Qr(), { printInterface: B } = un(), { printTypeParameter: T, printTypeParameters: w } = Zr(), { printExportDeclaration: k, printExportAllDeclaration: N } = on(), { printArrayItems: j } = Gr(), { printObject: O } = an(), { printPropertyKey: I } = en(), { printOptionalToken: P, printTypeAnnotation: L, printRestSpread: _ } = Wr(); function R(e, t, c) { let C = e.getValue(), R = t.semi ? ";" : "", M = []; switch (C.type) { case "DeclareClass": return $(e, y(e, t, c)); case "DeclareFunction": return $(e, ["function ", c("id"), C.predicate ? " " : "", c("predicate"), R]); case "DeclareModule": return $(e, ["module ", c("id"), " ", c("body")]); case "DeclareModuleExports": return $(e, ["module.exports", ": ", c("typeAnnotation"), R]); case "DeclareVariable": return $(e, ["var ", c("id"), R]); case "DeclareOpaqueType": return $(e, E(e, t, c)); case "DeclareInterface": return $(e, B(e, t, c)); case "DeclareTypeAlias": return $(e, F(e, t, c)); case "DeclareExportDeclaration": return $(e, k(e, t, c)); case "DeclareExportAllDeclaration": return $(e, N(e, t, c)); case "OpaqueType": return E(e, t, c); case "TypeAlias": return F(e, t, c); case "IntersectionTypeAnnotation": return A(e, t, c); case "UnionTypeAnnotation": return v(e, t, c); case "FunctionTypeAnnotation": return b(e, t, c); case "TupleTypeAnnotation": return x(e, t, c); case "GenericTypeAnnotation": return [c("id"), w(e, t, c, "typeParameters")]; case "IndexedAccessType": case "OptionalIndexedAccessType": return S(e, t, c); case "TypeAnnotation": return c("typeAnnotation"); case "TypeParameter": return T(e, t, c); case "TypeofTypeAnnotation": return ["typeof ", c("argument")]; case "ExistsTypeAnnotation": return "*"; case "EmptyTypeAnnotation": return "empty"; case "MixedTypeAnnotation": return "mixed"; case "ArrayTypeAnnotation": return [c("elementType"), "[]"]; case "BooleanLiteralTypeAnnotation": return String(C.value); case "EnumDeclaration": return ["enum ", c("id"), " ", c("body")]; case "EnumBooleanBody": case "EnumNumberBody": case "EnumStringBody": case "EnumSymbolBody": if ("EnumSymbolBody" === C.type || C.explicitType) { let e = null; switch (C.type) { case "EnumBooleanBody": e = "boolean"; break; case "EnumNumberBody": e = "number"; break; case "EnumStringBody": e = "string"; break; case "EnumSymbolBody": e = "symbol" }M.push("of ", e, " ") } if (0 !== C.members.length || C.hasUnknownMembers) { let r = C.members.length > 0 ? [o, j(e, t, "members", c), C.hasUnknownMembers || f(t) ? "," : ""] : []; M.push(s(["{", l([...r, ...C.hasUnknownMembers ? [o, "..."] : []]), n(e, t, !0), o, "}"])) } else M.push(s(["{", n(e, t), a, "}"])); return M; case "EnumBooleanMember": case "EnumNumberMember": case "EnumStringMember": return [c("id"), " = ", "object" == typeof C.init ? c("init") : String(C.init)]; case "EnumDefaultedMember": return c("id"); case "FunctionTypeParam": { let t = C.name ? c("name") : e.getParentNode().this === C ? "this" : ""; return [t, P(e), t ? ": " : "", c("typeAnnotation")] } case "InterfaceDeclaration": case "InterfaceTypeAnnotation": return B(e, t, c); case "ClassImplements": case "InterfaceExtends": return [c("id"), c("typeParameters")]; case "NullableTypeAnnotation": return ["?", c("typeAnnotation")]; case "Variance": { let { kind: e } = C; return r.ok("plus" === e || "minus" === e), "plus" === e ? "+" : "-" } case "ObjectTypeCallProperty": return C.static && M.push("static "), M.push(c("value")), M; case "ObjectTypeIndexer": return [C.static ? "static " : "", C.variance ? c("variance") : "", "[", c("id"), C.id ? ": " : "", c("key"), "]: ", c("value")]; case "ObjectTypeProperty": { let r = ""; return C.proto ? r = "proto " : C.static && (r = "static "), [r, D(C) ? C.kind + " " : "", C.variance ? c("variance") : "", I(e, t, c), P(e), p(C) ? "" : ": ", c("value")] } case "ObjectTypeAnnotation": return O(e, t, c); case "ObjectTypeInternalSlot": return [C.static ? "static " : "", "[[", c("id"), "]]", P(e), C.method ? "" : ": ", c("value")]; case "ObjectTypeSpreadProperty": return _(e, t, c); case "QualifiedTypeofIdentifier": case "QualifiedTypeIdentifier": return [c("qualification"), ".", c("id")]; case "StringLiteralTypeAnnotation": return h(u(d(C), t)); case "NumberLiteralTypeAnnotation": r.strictEqual(typeof C.value, "number"); case "BigIntLiteralTypeAnnotation": return C.extra ? i(C.extra.raw) : i(C.raw); case "TypeCastExpression": return ["(", c("expression"), L(e, t, c), ")"]; case "TypeParameterDeclaration": case "TypeParameterInstantiation": { let r = w(e, t, c, "params"); if ("flow" === t.parser) { let e = m(C), n = g(C), u = t.originalText.lastIndexOf("/*", e), i = t.originalText.indexOf("*/", n); if (-1 !== u && -1 !== i) { let e = t.originalText.slice(u + 2, i).trim(); if (e.startsWith("::") && !e.includes("/*") && !e.includes("*/")) return ["/*:: ", r, " */"] } } return r } case "InferredPredicate": return "%checks"; case "DeclaredPredicate": return ["%checks(", c("value"), ")"]; case "AnyTypeAnnotation": return "any"; case "BooleanTypeAnnotation": return "boolean"; case "BigIntTypeAnnotation": return "bigint"; case "NullLiteralTypeAnnotation": return "null"; case "NumberTypeAnnotation": return "number"; case "SymbolTypeAnnotation": return "symbol"; case "StringTypeAnnotation": return "string"; case "VoidTypeAnnotation": return "void"; case "ThisTypeAnnotation": return "this"; case "Node": case "Printable": case "SourceLocation": case "Position": case "Statement": case "Function": case "Pattern": case "Expression": case "Declaration": case "Specifier": case "NamedSpecifier": case "Comment": case "MemberTypeAnnotation": case "Type": throw new Error("unprintable type: " + JSON.stringify(C.type)) } } function $(e, t) { let n = c(e); return n ? (r.strictEqual(n.type, "DeclareExportDeclaration"), t) : ["declare ", t] } t.exports = { printFlow: R } } }), ln = m({ "src/language-js/utils/is-ts-keyword-type.js"(e, t) { function r(e) { let { type: t } = e; return t.startsWith("TS") && t.endsWith("Keyword") } C(), t.exports = r } }), cn = m({ "src/language-js/print/ternary.js"(e, t) { C(); var { hasNewlineInRange: r } = pe(), { isJsxNode: n, getComments: u, isCallExpression: i, isMemberExpression: o, isTSTypeExpression: a } = nr(), { locStart: s, locEnd: l } = Pt(), c = tr(), { builders: { line: p, softline: D, group: d, indent: f, align: m, ifBreak: g, dedent: h, breakParent: y } } = V(); function E(e) { let t = [e]; for (let r = 0; r < t.length; r++) { let e = t[r]; for (let r of ["test", "consequent", "alternate"]) { let u = e[r]; if (n(u)) return !0; "ConditionalExpression" === u.type && t.push(u) } } return !1 } function F(e, t, r) { let n = e.getValue(), u = "ConditionalExpression" === n.type, i = u ? "alternate" : "falseType", o = e.getParentNode(), a = u ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")]; return o.type === n.type && o[i] === n ? m(2, a) : a } var A = new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]); function v(e) { let t = e.getValue(); if ("ConditionalExpression" !== t.type) return !1; let r, n = t; for (let u = 0; !r; u++) { let t = e.getParentNode(u); i(t) && t.callee === n || o(t) && t.object === n || "TSNonNullExpression" === t.type && t.expression === n ? n = t : "NewExpression" === t.type && t.callee === n || a(t) && t.expression === n ? (r = e.getParentNode(u + 1), n = t) : r = t } return n !== t && r[A.get(r.type)] === n } function b(e, t, i) { let a, C, A = e.getValue(), b = "ConditionalExpression" === A.type, x = b ? "consequent" : "trueType", S = b ? "alternate" : "falseType", B = b ? ["test"] : ["checkType", "extendsType"], T = A[x], w = A[S], k = [], N = !1, j = e.getParentNode(), O = j.type === A.type && B.some((e => j[e] === A)), I = j.type === A.type && !O, P = 0; do { C = a || A, a = e.getParentNode(P), P++ } while (a && a.type === A.type && B.every((e => a[e] !== C))); let L = a || j, _ = C; if (b && (n(A[B[0]]) || n(T) || n(w) || E(_))) { N = !0, I = !0; let e = e => [g("("), f([D, e]), D, g(")")], t = e => "NullLiteral" === e.type || "Literal" === e.type && null === e.value || "Identifier" === e.type && "undefined" === e.name; k.push(" ? ", t(T) ? i(x) : e(i(x)), " : ", w.type === A.type || t(w) ? i(S) : e(i(S))) } else { let e = [p, "? ", T.type === A.type ? g("", "(") : "", m(2, i(x)), T.type === A.type ? g("", ")") : "", p, ": ", w.type === A.type ? i(S) : m(2, i(S))]; k.push(j.type !== A.type || j[S] === A || O ? e : t.useTabs ? h(f(e)) : m(Math.max(0, t.tabWidth - 2), e)) } let R = [...B.map((e => u(A[e]))), u(T), u(w)].flat().some((e => c(e) && r(t.originalText, s(e), l(e)))), M = e => j === L ? d(e, { shouldBreak: R }) : R ? [e, y] : e, $ = !N && (o(j) || "NGPipeExpression" === j.type && j.left === A) && !j.computed, q = v(e), V = M([F(e, t, i), I ? k : f(k), b && $ && !q ? D : ""]); return O || q ? d([f([D, V]), D]) : V } t.exports = { printTernary: b } } }), pn = m({ "src/language-js/print/statement.js"(e, t) { C(); var { builders: { hardline: r } } = V(), n = Rr(), { getLeftSidePathName: u, hasNakedLeftSide: i, isJsxNode: o, isTheOnlyJsxElementInMarkdown: a, hasComment: s, CommentCheckFlags: l, isNextLineEmpty: c } = nr(), { shouldPrintParamsWithoutParens: p } = tn(); function D(e, t, n, u) { let i = e.getValue(), o = [], p = "ClassBody" === i.type, D = d(i[u]); return e.each(((e, u, i) => { let d = e.getValue(); if ("EmptyStatement" === d.type) return; let m = n(); t.semi || p || a(t, e) || !f(e, t) ? o.push(m) : s(d, l.Leading) ? o.push(n([], { needsSemi: !0 })) : o.push(";", m), !t.semi && p && y(d) && E(d, i[u + 1]) && o.push(";"), d !== D && (o.push(r), c(d, t) && o.push(r)) }), u), o } function d(e) { for (let t = e.length - 1; t >= 0; t--) { let r = e[t]; if ("EmptyStatement" !== r.type) return r } } function f(e, t) { return "ExpressionStatement" === e.getNode().type && e.call((e => m(e, t)), "expression") } function m(e, t) { let r = e.getValue(); switch (r.type) { case "ParenthesizedExpression": case "TypeCastExpression": case "ArrayExpression": case "ArrayPattern": case "TemplateLiteral": case "TemplateElement": case "RegExpLiteral": return !0; case "ArrowFunctionExpression": if (!p(e, t)) return !0; break; case "UnaryExpression": { let { prefix: e, operator: t } = r; if (e && ("+" === t || "-" === t)) return !0; break } case "BindExpression": if (!r.object) return !0; break; case "Literal": if (r.regex) return !0; break; default: if (o(r)) return !0 }return !!n(e, t) || !!i(r) && e.call((e => m(e, t)), ...u(e, r)) } function g(e, t, r) { return D(e, t, r, "body") } function h(e, t, r) { return D(e, t, r, "consequent") } var y = e => { let { type: t } = e; return "ClassProperty" === t || "PropertyDefinition" === t || "ClassPrivateProperty" === t || "ClassAccessorProperty" === t || "AccessorProperty" === t || "TSAbstractPropertyDefinition" === t || "TSAbstractAccessorProperty" === t }; function E(e, t) { let { type: r, name: n } = e.key; if (!(e.computed || "Identifier" !== r || "static" !== n && "get" !== n && "set" !== n && "accessor" !== n || e.value || e.typeAnnotation)) return !0; if (!t || t.static || t.accessibility) return !1; if (!t.computed) { let e = t.key && t.key.name; if ("in" === e || "instanceof" === e) return !0 } if (y(t) && t.variance && !t.static && !t.declare) return !0; switch (t.type) { case "ClassProperty": case "PropertyDefinition": case "TSAbstractPropertyDefinition": return t.computed; case "MethodDefinition": case "TSAbstractMethodDefinition": case "ClassMethod": case "ClassPrivateMethod": { if ((t.value ? t.value.async : t.async) || "get" === t.kind || "set" === t.kind) return !1; let e = t.value ? t.value.generator : t.generator; return !(!t.computed && !e) } case "TSIndexSignature": return !0 }return !1 } t.exports = { printBody: g, printSwitchCaseConsequent: h } } }), Dn = m({ "src/language-js/print/block.js"(e, t) { C(); var { printDanglingComments: r } = Ut(), { isNonEmptyArray: n } = pe(), { builders: { hardline: u, indent: i } } = V(), { hasComment: o, CommentCheckFlags: a, isNextLineEmpty: s } = nr(), { printHardlineAfterHeritage: l } = nn(), { printBody: c } = pn(); function p(e, t, r) { let o = e.getValue(), a = []; if ("StaticBlock" === o.type && a.push("static "), "ClassBody" === o.type && n(o.body)) { let t = e.getParentNode(); a.push(l(t)) } a.push("{"); let s = D(e, t, r); if (s) a.push(i([u, s]), u); else { let t = e.getParentNode(), r = e.getParentNode(1); "ArrowFunctionExpression" === t.type || "FunctionExpression" === t.type || "FunctionDeclaration" === t.type || "ObjectMethod" === t.type || "ClassMethod" === t.type || "ClassPrivateMethod" === t.type || "ForStatement" === t.type || "WhileStatement" === t.type || "DoWhileStatement" === t.type || "DoExpression" === t.type || "CatchClause" === t.type && !r.finalizer || "TSModuleDeclaration" === t.type || "TSDeclareFunction" === t.type || "StaticBlock" === o.type || "ClassBody" === o.type || a.push(u) } return a.push("}"), a } function D(e, t, i) { let l = e.getValue(), p = n(l.directives), D = l.body.some((e => "EmptyStatement" !== e.type)), d = o(l, a.Dangling); if (!p && !D && !d) return ""; let f = []; if (p && e.each(((e, r, n) => { f.push(i()), (r < n.length - 1 || D || d) && (f.push(u), s(e.getValue(), t) && f.push(u)) }), "directives"), D && f.push(c(e, t, i)), d && f.push(r(e, t, !0)), "Program" === l.type) { let t = e.getParentNode(); (!t || "ModuleExpression" !== t.type) && f.push(u) } return f } t.exports = { printBlock: p, printBlockBody: D } } }), dn = m({ "src/language-js/print/typescript.js"(e, t) { C(); var { printDanglingComments: r } = Ut(), { hasNewlineInRange: n } = pe(), { builders: { join: u, line: i, hardline: o, softline: a, group: s, indent: l, conditionalGroup: c, ifBreak: p } } = V(), { isStringLiteral: D, getTypeScriptMappedTypeModifier: d, shouldPrintComma: f, isCallExpression: m, isMemberExpression: g } = nr(), h = ln(), { locStart: y, locEnd: E } = Pt(), { printOptionalToken: F, printTypeScriptModifiers: A } = Wr(), { printTernary: v } = cn(), { printFunctionParameters: b, shouldGroupFunctionParameters: x } = Yr(), { printTemplateLiteral: S } = ur(), { printArrayItems: B } = Gr(), { printObject: T } = an(), { printClassProperty: w, printClassMethod: k } = nn(), { printTypeParameter: N, printTypeParameters: j } = Zr(), { printPropertyKey: O } = en(), { printFunction: I, printMethodInternal: P } = tn(), { printInterface: L } = un(), { printBlock: _ } = Dn(), { printTypeAlias: R, printIntersectionType: M, printUnionType: $, printFunctionType: q, printTupleType: U, printIndexedAccessType: W, printJSDocType: G } = Qr(); function z(e, t, C) { let V = e.getValue(); if (!V.type.startsWith("TS")) return; if (h(V)) return V.type.slice(2, -7).toLowerCase(); let z = t.semi ? ";" : "", H = []; switch (V.type) { case "TSThisType": return "this"; case "TSTypeAssertion": { let e = !("ArrayExpression" === V.expression.type || "ObjectExpression" === V.expression.type), t = s(["<", l([a, C("typeAnnotation")]), a, ">"]), r = [p("("), l([a, C("expression")]), a, p(")")]; return e ? c([[t, C("expression")], [t, s(r, { shouldBreak: !0 })], [t, C("expression")]]) : s([t, C("expression")]) } case "TSDeclareFunction": return I(e, C, t); case "TSExportAssignment": return ["export = ", C("expression"), z]; case "TSModuleBlock": return _(e, t, C); case "TSInterfaceBody": case "TSTypeLiteral": return T(e, t, C); case "TSTypeAliasDeclaration": return R(e, t, C); case "TSQualifiedName": return u(".", [C("left"), C("right")]); case "TSAbstractMethodDefinition": case "TSDeclareMethod": return k(e, t, C); case "TSAbstractAccessorProperty": case "TSAbstractPropertyDefinition": return w(e, t, C); case "TSInterfaceHeritage": case "TSExpressionWithTypeArguments": return H.push(C("expression")), V.typeParameters && H.push(C("typeParameters")), H; case "TSTemplateLiteralType": return S(e, C, t); case "TSNamedTupleMember": return [C("label"), V.optional ? "?" : "", ": ", C("elementType")]; case "TSRestType": return ["...", C("typeAnnotation")]; case "TSOptionalType": return [C("typeAnnotation"), "?"]; case "TSInterfaceDeclaration": return L(e, t, C); case "TSClassImplements": case "TSInstantiationExpression": return [C("expression"), C("typeParameters")]; case "TSTypeParameterDeclaration": case "TSTypeParameterInstantiation": return j(e, t, C, "params"); case "TSTypeParameter": return N(e, t, C); case "TSSatisfiesExpression": case "TSAsExpression": { let t = "TSAsExpression" === V.type ? "as" : "satisfies"; H.push(C("expression"), ` ${t} `, C("typeAnnotation")); let r = e.getParentNode(); return m(r) && r.callee === V || g(r) && r.object === V ? s([l([a, ...H]), a]) : H } case "TSArrayType": return [C("elementType"), "[]"]; case "TSPropertySignature": return V.readonly && H.push("readonly "), H.push(O(e, t, C), F(e)), V.typeAnnotation && H.push(": ", C("typeAnnotation")), V.initializer && H.push(" = ", C("initializer")), H; case "TSParameterProperty": return V.accessibility && H.push(V.accessibility + " "), V.export && H.push("export "), V.static && H.push("static "), V.override && H.push("override "), V.readonly && H.push("readonly "), H.push(C("parameter")), H; case "TSTypeQuery": return ["typeof ", C("exprName"), C("typeParameters")]; case "TSIndexSignature": { let r = e.getParentNode(), n = V.parameters.length > 1 ? p(f(t) ? "," : "") : "", i = s([l([a, u([", ", a], e.map(C, "parameters"))]), n, a]); return [V.export ? "export " : "", V.accessibility ? [V.accessibility, " "] : "", V.static ? "static " : "", V.readonly ? "readonly " : "", V.declare ? "declare " : "", "[", V.parameters ? i : "", V.typeAnnotation ? "]: " : "]", V.typeAnnotation ? C("typeAnnotation") : "", "ClassBody" === r.type ? z : ""] } case "TSTypePredicate": return [V.asserts ? "asserts " : "", C("parameterName"), V.typeAnnotation ? [" is ", C("typeAnnotation")] : ""]; case "TSNonNullExpression": return [C("expression"), "!"]; case "TSImportType": return [V.isTypeOf ? "typeof " : "", "import(", C(V.parameter ? "parameter" : "argument"), ")", V.qualifier ? [".", C("qualifier")] : "", j(e, t, C, "typeParameters")]; case "TSLiteralType": return C("literal"); case "TSIndexedAccessType": return W(e, t, C); case "TSConstructSignatureDeclaration": case "TSCallSignatureDeclaration": case "TSConstructorType": if ("TSConstructorType" === V.type && V.abstract && H.push("abstract "), "TSCallSignatureDeclaration" !== V.type && H.push("new "), H.push(s(b(e, C, t, !1, !0))), V.returnType || V.typeAnnotation) { let e = "TSConstructorType" === V.type; H.push(e ? " => " : ": ", C("returnType"), C("typeAnnotation")) } return H; case "TSTypeOperator": return [V.operator, " ", C("typeAnnotation")]; case "TSMappedType": { let u = n(t.originalText, y(V), E(V)); return s(["{", l([t.bracketSpacing ? i : a, C("typeParameter"), V.optional ? d(V.optional, "?") : "", V.typeAnnotation ? ": " : "", C("typeAnnotation"), p(z)]), r(e, t, !0), t.bracketSpacing ? i : a, "}"], { shouldBreak: u }) } case "TSMethodSignature": { let r = V.kind && "method" !== V.kind ? `${V.kind} ` : ""; H.push(V.accessibility ? [V.accessibility, " "] : "", r, V.export ? "export " : "", V.static ? "static " : "", V.readonly ? "readonly " : "", V.abstract ? "abstract " : "", V.declare ? "declare " : "", V.computed ? "[" : "", C("key"), V.computed ? "]" : "", F(e)); let n = b(e, C, t, !1, !0), u = V.returnType ? "returnType" : "typeAnnotation", i = V[u], o = i ? C(u) : "", a = x(V, o); return H.push(a ? s(n) : n), i && H.push(": ", s(o)), s(H) } case "TSNamespaceExportDeclaration": return H.push("export as namespace ", C("id")), t.semi && H.push(";"), s(H); case "TSEnumDeclaration": return V.declare && H.push("declare "), V.modifiers && H.push(A(e, t, C)), V.const && H.push("const "), H.push("enum ", C("id"), " "), 0 === V.members.length ? H.push(s(["{", r(e, t), a, "}"])) : H.push(s(["{", l([o, B(e, t, "members", C), f(t, "es5") ? "," : ""]), r(e, t, !0), o, "}"])), H; case "TSEnumMember": return V.computed ? H.push("[", C("id"), "]") : H.push(C("id")), V.initializer && H.push(" = ", C("initializer")), H; case "TSImportEqualsDeclaration": return V.isExport && H.push("export "), H.push("import "), V.importKind && "value" !== V.importKind && H.push(V.importKind, " "), H.push(C("id"), " = ", C("moduleReference")), t.semi && H.push(";"), s(H); case "TSExternalModuleReference": return ["require(", C("expression"), ")"]; case "TSModuleDeclaration": { let r = e.getParentNode(), n = D(V.id), u = "TSModuleDeclaration" === r.type, i = V.body && "TSModuleDeclaration" === V.body.type; if (u) H.push("."); else { V.declare && H.push("declare "), H.push(A(e, t, C)); let r = t.originalText.slice(y(V), y(V.id)); "Identifier" === V.id.type && "global" === V.id.name && !/namespace|module/.test(r) || H.push(n || /(?:^|\s)module(?:\s|$)/.test(r) ? "module " : "namespace ") } return H.push(C("id")), i ? H.push(C("body")) : V.body ? H.push(" ", s(C("body"))) : H.push(z), H } case "TSConditionalType": return v(e, t, C); case "TSInferType": return ["infer", " ", C("typeParameter")]; case "TSIntersectionType": return M(e, t, C); case "TSUnionType": return $(e, t, C); case "TSFunctionType": return q(e, t, C); case "TSTupleType": return U(e, t, C); case "TSTypeReference": return [C("typeName"), j(e, t, C, "typeParameters")]; case "TSTypeAnnotation": return C("typeAnnotation"); case "TSEmptyBodyFunctionExpression": return P(e, t, C); case "TSJSDocAllType": return "*"; case "TSJSDocUnknownType": return "?"; case "TSJSDocNullableType": return G(e, C, "?"); case "TSJSDocNonNullableType": return G(e, C, "!"); default: throw new Error(`Unknown TypeScript node type: ${JSON.stringify(V.type)}.`) } } t.exports = { printTypescript: z } } }), fn = m({ "src/language-js/print/comment.js"(e, t) { C(); var { hasNewline: r } = pe(), { builders: { join: n, hardline: u }, utils: { replaceTextEndOfLine: i } } = V(), { isLineComment: o } = nr(), { locStart: a, locEnd: s } = Pt(), l = tr(); function c(e, t) { let n = e.getValue(); if (o(n)) return t.originalText.slice(a(n), s(n)).trimEnd(); if (l(n)) { if (p(n)) { let e = D(n); return n.trailing && !r(t.originalText, a(n), { backwards: !0 }) ? [u, e] : e } let e = s(n), o = "*-/" === t.originalText.slice(e - 3, e); return ["/*", i(n.value), o ? "*-/" : "*/"] } throw new Error("Not a comment: " + JSON.stringify(n)) } function p(e) { let t = `*${e.value}*`.split("\n"); return t.length > 1 && t.every((e => "*" === e.trim()[0])) } function D(e) { let t = e.value.split("\n"); return ["/*", n(u, t.map(((e, r) => 0 === r ? e.trimEnd() : " " + (r < t.length - 1 ? e.trim() : e.trimStart())))), "*/"] } t.exports = { printComment: c } } }), mn = m({ "src/language-js/print/literal.js"(e, t) { C(); var { printString: r, printNumber: n } = pe(), { replaceTextEndOfLine: u } = M(), { printDirective: i } = Wr(); function o(e, t) { let o = e.getNode(); switch (o.type) { case "RegExpLiteral": return l(o); case "BigIntLiteral": return s(o.bigint || o.extra.raw); case "NumericLiteral": return n(o.extra.raw); case "StringLiteral": return u(r(o.extra.raw, t)); case "NullLiteral": return "null"; case "BooleanLiteral": return String(o.value); case "DecimalLiteral": return n(o.value) + "m"; case "Literal": { if (o.regex) return l(o.regex); if (o.bigint) return s(o.raw); if (o.decimal) return n(o.decimal) + "m"; let { value: c } = o; return "number" == typeof c ? n(o.raw) : "string" == typeof c ? a(e) ? i(o.raw, t) : u(r(o.raw, t)) : String(c) } } } function a(e) { if ("expression" !== e.getName()) return; let t = e.getParentNode(); return "ExpressionStatement" === t.type && t.directive } function s(e) { return e.toLowerCase() } function l(e) { let { pattern: t, flags: r } = e; return r = [...r].sort().join(""), `/${t}/${r}` } t.exports = { printLiteral: o } } }), gn = m({ "src/language-js/printer-estree.js"(e, t) { C(); var { printDanglingComments: r } = Ut(), { hasNewline: n } = pe(), { builders: { join: u, line: i, hardline: o, softline: a, group: s, indent: l }, utils: { replaceTextEndOfLine: c } } = V(), p = lr(), D = cr(), { insertPragma: d } = Pr(), f = _r(), m = Rr(), g = Mr(), { hasFlowShorthandAnnotationComment: h, hasComment: y, CommentCheckFlags: E, isTheOnlyJsxElementInMarkdown: F, isLineComment: A, isNextLineEmpty: v, needsHardlineAfterDanglingComment: b, hasIgnoreComment: x, isCallExpression: S, isMemberExpression: B, markerForIfWithoutBlockAndSameLineComment: T } = nr(), { locStart: w, locEnd: k } = Pt(), N = tr(), { printHtmlBinding: j, isVueEventBindingExpression: O } = $r(), { printAngular: I } = Vr(), { printJsx: P, hasJsxIgnoreComment: L } = Ur(), { printFlow: _ } = sn(), { printTypescript: R } = dn(), { printOptionalToken: M, printBindExpressionCallee: $, printTypeAnnotation: q, adjustClause: U, printRestSpread: W, printDefiniteToken: G, printDirective: z } = Wr(), { printImportDeclaration: H, printExportDeclaration: J, printExportAllDeclaration: X, printModuleSpecifier: K } = on(), { printTernary: Y } = cn(), { printTemplateLiteral: Q } = ur(), { printArray: Z } = Gr(), { printObject: ee } = an(), { printClass: te, printClassMethod: re, printClassProperty: ne } = nn(), { printProperty: ue } = en(), { printFunction: ie, printArrowFunction: oe, printMethod: ae, printReturnStatement: se, printThrowStatement: le } = tn(), { printCallExpression: ce } = Xr(), { printVariableDeclarator: De, printAssignmentExpression: de } = Kr(), { printBinaryishExpression: fe } = qr(), { printSwitchCaseConsequent: me } = pn(), { printMemberExpression: ge } = Hr(), { printBlock: he, printBlockBody: ye } = Dn(), { printComment: Ee } = fn(), { printLiteral: Ce } = mn(), { printDecorators: Fe } = rn(); function Ae(e, t, r, n) { let u = ve(e, t, r, n); if (!u) return ""; let o = e.getValue(), { type: a } = o; if ("ClassMethod" === a || "ClassPrivateMethod" === a || "ClassProperty" === a || "ClassAccessorProperty" === a || "AccessorProperty" === a || "TSAbstractAccessorProperty" === a || "PropertyDefinition" === a || "TSAbstractPropertyDefinition" === a || "ClassPrivateProperty" === a || "MethodDefinition" === a || "TSAbstractMethodDefinition" === a || "TSDeclareMethod" === a) return u; let c = [u], p = Fe(e, t, r), D = "ClassExpression" === o.type && p; if (p && (c = [...p, u], !D)) return s(c); if (!m(e, t)) return n && n.needsSemi && c.unshift(";"), 1 === c.length && c[0] === u ? u : c; if (D && (c = [l([i, ...c])]), c.unshift("("), n && n.needsSemi && c.unshift(";"), h(o)) { let [e] = o.trailingComments; c.push(" /*", e.value.trimStart(), "*/"), e.printed = !0 } return D && c.push(i), c.push(")"), c } function ve(e, t, p, D) { let d = e.getValue(), f = t.semi ? ";" : ""; if (!d) return ""; if ("string" == typeof d) return d; for (let r of [Ce, j, I, P, _, R]) { let n = r(e, t, p); if (typeof n < "u") return n } let m = []; switch (d.type) { case "JsExpressionRoot": return p("node"); case "JsonRoot": return [p("node"), o]; case "File": return d.program && d.program.interpreter && m.push(p(["program", "interpreter"])), m.push(p("program")), m; case "Program": return ye(e, t, p); case "EmptyStatement": return ""; case "ExpressionStatement": { if ("__vue_event_binding" === t.parser || "__vue_ts_event_binding" === t.parser) { let t = e.getParentNode(); if ("Program" === t.type && 1 === t.body.length && t.body[0] === d) return [p("expression"), O(d.expression) ? ";" : ""] } let n = r(e, t, !0, (e => { let { marker: t } = e; return t === T })); return [p("expression"), F(t, e) ? "" : f, n ? [" ", n] : ""] } case "ParenthesizedExpression": return y(d.expression) || "ObjectExpression" !== d.expression.type && "ArrayExpression" !== d.expression.type ? s(["(", l([a, p("expression")]), a, ")"]) : ["(", p("expression"), ")"]; case "AssignmentExpression": return de(e, t, p); case "VariableDeclarator": return De(e, t, p); case "BinaryExpression": case "LogicalExpression": return fe(e, t, p); case "AssignmentPattern": return [p("left"), " = ", p("right")]; case "OptionalMemberExpression": case "MemberExpression": return ge(e, t, p); case "MetaProperty": return [p("meta"), ".", p("property")]; case "BindExpression": return d.object && m.push(p("object")), m.push(s(l([a, $(e, t, p)]))), m; case "Identifier": return [d.name, M(e), G(e), q(e, t, p)]; case "V8IntrinsicIdentifier": return ["%", d.name]; case "SpreadElement": case "SpreadElementPattern": case "SpreadProperty": case "SpreadPropertyPattern": case "RestElement": return W(e, t, p); case "FunctionDeclaration": case "FunctionExpression": return ie(e, p, t, D); case "ArrowFunctionExpression": return oe(e, t, p, D); case "YieldExpression": return m.push("yield"), d.delegate && m.push("*"), d.argument && m.push(" ", p("argument")), m; case "AwaitExpression": if (m.push("await"), d.argument) { m.push(" ", p("argument")); let t = e.getParentNode(); if (S(t) && t.callee === d || B(t) && t.object === d) { m = [l([a, ...m]), a]; let t = e.findAncestor((e => "AwaitExpression" === e.type || "BlockStatement" === e.type)); if (!t || "AwaitExpression" !== t.type) return s(m) } } return m; case "ExportDefaultDeclaration": case "ExportNamedDeclaration": return J(e, t, p); case "ExportAllDeclaration": return X(e, t, p); case "ImportDeclaration": return H(e, t, p); case "ImportSpecifier": case "ExportSpecifier": case "ImportNamespaceSpecifier": case "ExportNamespaceSpecifier": case "ImportDefaultSpecifier": case "ExportDefaultSpecifier": return K(e, t, p); case "ImportAttribute": return [p("key"), ": ", p("value")]; case "Import": return "import"; case "BlockStatement": case "StaticBlock": case "ClassBody": return he(e, t, p); case "ThrowStatement": return le(e, t, p); case "ReturnStatement": return se(e, t, p); case "NewExpression": case "ImportExpression": case "OptionalCallExpression": case "CallExpression": return ce(e, t, p); case "ObjectExpression": case "ObjectPattern": case "RecordExpression": return ee(e, t, p); case "ObjectProperty": case "Property": return d.method || "get" === d.kind || "set" === d.kind ? ae(e, t, p) : ue(e, t, p); case "ObjectMethod": return ae(e, t, p); case "Decorator": return ["@", p("expression")]; case "ArrayExpression": case "ArrayPattern": case "TupleExpression": return Z(e, t, p); case "SequenceExpression": { let t = e.getParentNode(0); if ("ExpressionStatement" === t.type || "ForStatement" === t.type) { let t = []; return e.each(((e, r) => { 0 === r ? t.push(p()) : t.push(",", l([i, p()])) }), "expressions"), s(t) } return s(u([",", i], e.map(p, "expressions"))) } case "ThisExpression": return "this"; case "Super": return "super"; case "Directive": return [p("value"), f]; case "DirectiveLiteral": return z(d.extra.raw, t); case "UnaryExpression": return m.push(d.operator), /[a-z]$/.test(d.operator) && m.push(" "), y(d.argument) ? m.push(s(["(", l([a, p("argument")]), a, ")"])) : m.push(p("argument")), m; case "UpdateExpression": return m.push(p("argument"), d.operator), d.prefix && m.reverse(), m; case "ConditionalExpression": return Y(e, t, p); case "VariableDeclaration": { let t, r = e.map(p, "declarations"), n = e.getParentNode(), u = "ForStatement" === n.type || "ForInStatement" === n.type || "ForOfStatement" === n.type, a = d.declarations.some((e => e.init)); return 1 !== r.length || y(d.declarations[0]) ? r.length > 0 && (t = l(r[0])) : t = r[0], m = [d.declare ? "declare " : "", d.kind, t ? [" ", t] : "", l(r.slice(1).map((e => [",", a && !u ? o : i, e])))], u && n.body !== d || m.push(f), s(m) } case "WithStatement": return s(["with (", p("object"), ")", U(d.body, p("body"))]); case "IfStatement": { let n = U(d.consequent, p("consequent")), u = s(["if (", s([l([a, p("test")]), a]), ")", n]); if (m.push(u), d.alternate) { let n = y(d.consequent, E.Trailing | E.Line) || b(d), u = "BlockStatement" === d.consequent.type && !n; m.push(u ? " " : o), y(d, E.Dangling) && m.push(r(e, t, !0), n ? o : " "), m.push("else", s(U(d.alternate, p("alternate"), "IfStatement" === d.alternate.type))) } return m } case "ForStatement": { let n = U(d.body, p("body")), u = r(e, t, !0), o = u ? [u, a] : ""; return d.init || d.test || d.update ? [o, s(["for (", s([l([a, p("init"), ";", i, p("test"), ";", i, p("update")]), a]), ")", n])] : [o, s(["for (;;)", n])] } case "WhileStatement": return s(["while (", s([l([a, p("test")]), a]), ")", U(d.body, p("body"))]); case "ForInStatement": return s(["for (", p("left"), " in ", p("right"), ")", U(d.body, p("body"))]); case "ForOfStatement": return s(["for", d.await ? " await" : "", " (", p("left"), " of ", p("right"), ")", U(d.body, p("body"))]); case "DoWhileStatement": { let e = U(d.body, p("body")); return m = [s(["do", e])], "BlockStatement" === d.body.type ? m.push(" ") : m.push(o), m.push("while (", s([l([a, p("test")]), a]), ")", f), m } case "DoExpression": return [d.async ? "async " : "", "do ", p("body")]; case "BreakStatement": return m.push("break"), d.label && m.push(" ", p("label")), m.push(f), m; case "ContinueStatement": return m.push("continue"), d.label && m.push(" ", p("label")), m.push(f), m; case "LabeledStatement": return "EmptyStatement" === d.body.type ? [p("label"), ":;"] : [p("label"), ": ", p("body")]; case "TryStatement": return ["try ", p("block"), d.handler ? [" ", p("handler")] : "", d.finalizer ? [" finally ", p("finalizer")] : ""]; case "CatchClause": if (d.param) { let e = y(d.param, (e => !N(e) || e.leading && n(t.originalText, k(e)) || e.trailing && n(t.originalText, w(e), { backwards: !0 }))), r = p("param"); return ["catch ", e ? ["(", l([a, r]), a, ") "] : ["(", r, ") "], p("body")] } return ["catch ", p("body")]; case "SwitchStatement": return [s(["switch (", l([a, p("discriminant")]), a, ")"]), " {", d.cases.length > 0 ? l([o, u(o, e.map(((e, r, n) => { let u = e.getValue(); return [p(), r !== n.length - 1 && v(u, t) ? o : ""] }), "cases"))]) : "", o, "}"]; case "SwitchCase": { d.test ? m.push("case ", p("test"), ":") : m.push("default:"), y(d, E.Dangling) && m.push(" ", r(e, t, !0)); let n = d.consequent.filter((e => "EmptyStatement" !== e.type)); if (n.length > 0) { let r = me(e, t, p); m.push(1 === n.length && "BlockStatement" === n[0].type ? [" ", r] : l([o, r])) } return m } case "DebuggerStatement": return ["debugger", f]; case "ClassDeclaration": case "ClassExpression": return te(e, t, p); case "ClassMethod": case "ClassPrivateMethod": case "MethodDefinition": return re(e, t, p); case "ClassProperty": case "PropertyDefinition": case "ClassPrivateProperty": case "ClassAccessorProperty": case "AccessorProperty": return ne(e, t, p); case "TemplateElement": return c(d.value.raw); case "TemplateLiteral": return Q(e, p, t); case "TaggedTemplateExpression": return [p("tag"), p("typeParameters"), p("quasi")]; case "PrivateIdentifier": return ["#", p("name")]; case "PrivateName": return ["#", p("id")]; case "InterpreterDirective": return m.push("#!", d.value, o), v(d, t) && m.push(o), m; case "TopicReference": return "%"; case "ArgumentPlaceholder": return "?"; case "ModuleExpression": { m.push("module {"); let e = p("body"); return e && m.push(l([o, e]), o), m.push("}"), m } default: throw new Error("unknown type: " + JSON.stringify(d.type)) } } function be(e) { return e.type && !N(e) && !A(e) && "EmptyStatement" !== e.type && "TemplateElement" !== e.type && "Import" !== e.type && "TSEmptyBodyFunctionExpression" !== e.type } t.exports = { preprocess: g, print: Ae, embed: p, insertPragma: d, massageAstNode: D, hasPrettierIgnore: e => x(e) || L(e), willPrintOwnComments: f.willPrintOwnComments, canAttachComment: be, printComment: Ee, isBlockComment: N, handleComments: { avoidAstMutation: !0, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes } } }), hn = m({ "src/language-js/printer-estree-json.js"(e, t) { C(); var { builders: { hardline: r, indent: n, join: u } } = V(), i = Mr(); function o(e, t, i) { let o = e.getValue(); switch (o.type) { case "JsonRoot": return [i("node"), r]; case "ArrayExpression": { if (0 === o.elements.length) return "[]"; let t = e.map((() => null === e.getValue() ? "null" : i()), "elements"); return ["[", n([r, u([",", r], t)]), r, "]"] } case "ObjectExpression": return 0 === o.properties.length ? "{}" : ["{", n([r, u([",", r], e.map(i, "properties"))]), r, "}"]; case "ObjectProperty": return [i("key"), ": ", i("value")]; case "UnaryExpression": return ["+" === o.operator ? "" : o.operator, i("argument")]; case "NullLiteral": return "null"; case "BooleanLiteral": return o.value ? "true" : "false"; case "StringLiteral": return JSON.stringify(o.value); case "NumericLiteral": return a(e) ? JSON.stringify(String(o.value)) : JSON.stringify(o.value); case "Identifier": return a(e) ? JSON.stringify(o.name) : o.name; case "TemplateLiteral": return i(["quasis", 0]); case "TemplateElement": return JSON.stringify(o.value.cooked); default: throw new Error("unknown type: " + JSON.stringify(o.type)) } } function a(e) { return "key" === e.getName() && "ObjectProperty" === e.getParentNode().type } var s = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]); function l(e, t) { let { type: r } = e; if ("ObjectProperty" !== r) { if ("UnaryExpression" === r && "+" === e.operator) return t.argument; if ("ArrayExpression" !== r) return "TemplateLiteral" === r ? { type: "StringLiteral", value: e.quasis[0].value.cooked } : void 0; for (let [r, n] of e.elements.entries()) null === n && t.elements.splice(r, 0, { type: "NullLiteral" }) } else { let { key: r } = e; "Identifier" === r.type ? t.key = { type: "StringLiteral", value: r.name } : "NumericLiteral" === r.type && (t.key = { type: "StringLiteral", value: String(r.value) }) } } l.ignoredProperties = s, t.exports = { preprocess: i, print: o, massageAstNode: l } } }), yn = m({ "src/common/common-options.js"(e, t) { C(); var r = "Common"; t.exports = { bracketSpacing: { since: "0.0.0", category: r, type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: r, type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: r, type: "choice", default: [{ since: "1.8.2", value: !0 }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: r, type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: r, type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } } } }), En = m({ "src/language-js/options.js"(e, t) { C(); var r = yn(), n = "JavaScript"; t.exports = { arrowParens: { since: "1.9.0", category: n, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: r.bracketSameLine, bracketSpacing: r.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: n, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: n, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: r.singleQuote, jsxSingleQuote: { since: "1.15.0", category: n, type: "boolean", default: !1, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: n, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: n, type: "choice", default: [{ since: "0.0.0", value: !1 }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: r.singleAttributePerLine } } }), Cn = m({ "src/language-js/parse/parsers.js"() { C() } }), Fn = m({ "node_modules/linguist-languages/data/JavaScript.json"(e, t) { t.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 } } }), An = m({ "node_modules/linguist-languages/data/TypeScript.json"(e, t) { t.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 } } }), vn = m({ "node_modules/linguist-languages/data/TSX.json"(e, t) { t.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 } } }), bn = m({ "node_modules/linguist-languages/data/JSON.json"(e, t) { t.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 } } }), xn = m({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, t) { t.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 } } }), Sn = m({ "node_modules/linguist-languages/data/JSON5.json"(e, t) { t.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 } } }), Bn = m({ "src/language-js/index.js"(e, t) { C(); var r = Kt(), n = gn(), u = hn(), i = En(), o = Cn(), a = [r(Fn(), (e => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e.interpreters, "zx"], extensions: [...e.extensions.filter((e => ".jsx" !== e)), ".wxs"] }))), r(Fn(), (() => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] }))), r(Fn(), (() => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 }))), r(An(), (() => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }))), r(vn(), (() => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }))), r(bn(), (() => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] }))), r(bn(), (e => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e.extensions.filter((e => ".jsonl" !== e)) }))), r(xn(), (e => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e.filenames, ".eslintrc", ".swcrc"] }))), r(Sn(), (() => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] })))], s = { estree: n, "estree-json": u }; t.exports = { languages: a, options: i, printers: s, parsers: o } } }), Tn = m({ "src/language-css/clean.js"(e, t) { C(); var { isFrontMatterNode: r } = pe(), n = S(), u = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]); function i(e, t, u) { if (r(e) && "yaml" === e.lang && delete t.value, "css-comment" === e.type && "css-root" === u.type && u.nodes.length > 0 && ((u.nodes[0] === e || r(u.nodes[0]) && u.nodes[1] === e) && (delete t.text, /^\*\s*@(?:format|prettier)\s*$/.test(e.text)) || "css-root" === u.type && n(u.nodes) === e)) return null; if ("value-root" === e.type && delete t.text, ("media-query" === e.type || "media-query-list" === e.type || "media-feature-expression" === e.type) && delete t.value, "css-rule" === e.type && delete t.params, "selector-combinator" === e.type && (t.value = t.value.replace(/\s+/g, " ")), "media-feature" === e.type && (t.value = t.value.replace(/ /g, "")), ("value-word" === e.type && (e.isColor && e.isHex || ["initial", "inherit", "unset", "revert"].includes(t.value.replace().toLowerCase())) || "media-feature" === e.type || "selector-root-invalid" === e.type || "selector-pseudo" === e.type) && (t.value = t.value.toLowerCase()), "css-decl" === e.type && (t.prop = t.prop.toLowerCase()), ("css-atrule" === e.type || "css-import" === e.type) && (t.name = t.name.toLowerCase()), "value-number" === e.type && (t.unit = t.unit.toLowerCase()), ("media-feature" === e.type || "media-keyword" === e.type || "media-type" === e.type || "media-unknown" === e.type || "media-url" === e.type || "media-value" === e.type || "selector-attribute" === e.type || "selector-string" === e.type || "selector-class" === e.type || "selector-combinator" === e.type || "value-string" === e.type) && t.value && (t.value = o(t.value)), "selector-attribute" === e.type && (t.attribute = t.attribute.trim(), t.namespace && "string" == typeof t.namespace && (t.namespace = t.namespace.trim(), 0 === t.namespace.length && (t.namespace = !0)), t.value && (t.value = t.value.trim().replace(/^["']|["']$/g, ""), delete t.quoted)), ("media-value" === e.type || "media-type" === e.type || "value-number" === e.type || "selector-root-invalid" === e.type || "selector-class" === e.type || "selector-combinator" === e.type || "selector-tag" === e.type) && t.value && (t.value = t.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, ((e, t, r) => { let n = Number(t); return Number.isNaN(n) ? e : n + r.toLowerCase() }))), "selector-tag" === e.type) { let r = e.value.toLowerCase();["from", "to"].includes(r) && (t.value = r) } if ("css-atrule" === e.type && "supports" === e.name.toLowerCase() && delete t.value, "selector-unknown" === e.type && delete t.value, "value-comma_group" === e.type) { let r = e.groups.findIndex((e => "value-number" === e.type && "..." === e.unit)); -1 !== r && (t.groups[r].unit = "", t.groups.splice(r + 1, 0, { type: "value-word", value: "...", isColor: !1, isHex: !1 })) } return "value-comma_group" === e.type && e.groups.some((e => "value-atword" === e.type && e.value.endsWith("[") || "value-word" === e.type && e.value.startsWith("]"))) ? { type: "value-atword", value: e.groups.map((e => e.value)).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } } : void 0 } function o(e) { return e.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1") } i.ignoredProperties = u, t.exports = i } }), wn = m({ "src/utils/front-matter/print.js"(e, t) { C(); var { builders: { hardline: r, markAsRoot: n } } = V(); function u(e, t) { if ("yaml" === e.lang) { let u = e.value.trim(), i = u ? t(u, { parser: "yaml" }, { stripTrailingHardline: !0 }) : ""; return n([e.startDelimiter, r, i, i ? r : "", e.endDelimiter]) } } t.exports = u } }), kn = m({ "src/language-css/embed.js"(e, t) { C(); var { builders: { hardline: r } } = V(), n = wn(); function u(e, t, u) { let i = e.getValue(); if ("front-matter" === i.type) { let e = n(i, u); return e ? [e, r] : "" } } t.exports = u } }), Nn = m({ "src/utils/front-matter/parse.js"(e, t) { C(); var r = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s"); function n(e) { let t = e.match(r); if (!t) return { content: e }; let { startDelimiter: n, language: u, value: i = "", endDelimiter: o } = t.groups, a = u.trim() || "yaml"; if ("+++" === n && (a = "toml"), "yaml" !== a && n !== o) return { content: e }; let [s] = t; return { frontMatter: { type: "front-matter", lang: a, value: i, startDelimiter: n, endDelimiter: o, raw: s.replace(/\n$/, "") }, content: s.replace(/[^\n]/g, " ") + e.slice(s.length) } } t.exports = n } }), jn = m({ "src/language-css/pragma.js"(e, t) { C(); var r = Pr(), n = Nn(); function u(e) { return r.hasPragma(n(e).content) } function i(e) { let { frontMatter: t, content: u } = n(e); return (t ? t.raw + "\n\n" : "") + r.insertPragma(u) } t.exports = { hasPragma: u, insertPragma: i } } }), On = m({ "src/language-css/utils/index.js"(e, t) { C(); var r = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]); function n(e, t) { let r, n = Array.isArray(t) ? t : [t], u = -1; for (; r = e.getParentNode(++u);)if (n.includes(r.type)) return u; return -1 } function u(e, t) { let r = n(e, t); return -1 === r ? null : e.getParentNode(r) } function i(e) { var t; let r = u(e, "css-decl"); return null == r || null === (t = r.prop) || void 0 === t ? void 0 : t.toLowerCase() } var o = new Set(["initial", "inherit", "unset", "revert"]); function a(e) { return o.has(e.toLowerCase()) } function s(e, t) { let r = u(e, "css-atrule"); return (null == r ? void 0 : r.name) && r.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t.toLowerCase()) } function l(e) { return e.includes("$") || e.includes("@") || e.includes("#") || e.startsWith("%") || e.startsWith("--") || e.startsWith(":--") || e.includes("(") && e.includes(")") ? e : e.toLowerCase() } function c(e, t) { var r; let n = u(e, "value-func"); return (null == n || null === (r = n.value) || void 0 === r ? void 0 : r.toLowerCase()) === t } function p(e) { var t; let r = u(e, "css-rule"), n = null == r || null === (t = r.raws) || void 0 === t ? void 0 : t.selector; return n && (n.startsWith(":import") || n.startsWith(":export")) } function D(e, t) { let r = Array.isArray(t) ? t : [t], n = u(e, "css-atrule"); return n && r.includes(n.name.toLowerCase()) } function d(e) { let t = e.getValue(), r = u(e, "css-atrule"); return "import" === (null == r ? void 0 : r.name) && "url" === t.groups[0].value && 2 === t.groups.length } function f(e) { return "value-func" === e.type && "url" === e.value.toLowerCase() } function m(e, t) { var r; let n = null === (r = e.getParentNode()) || void 0 === r ? void 0 : r.nodes; return n && n.indexOf(t) === n.length - 1 } function g(e) { let { selector: t } = e; return !!t && ("string" == typeof t && /^@.+:.*$/.test(t) || t.value && /^@.+:.*$/.test(t.value)) } function h(e) { return "value-word" === e.type && ["from", "through", "end"].includes(e.value) } function y(e) { return "value-word" === e.type && ["and", "or", "not"].includes(e.value) } function E(e) { return "value-word" === e.type && "in" === e.value } function F(e) { return "value-operator" === e.type && "*" === e.value } function A(e) { return "value-operator" === e.type && "/" === e.value } function v(e) { return "value-operator" === e.type && "+" === e.value } function b(e) { return "value-operator" === e.type && "-" === e.value } function x(e) { return "value-operator" === e.type && "%" === e.value } function S(e) { return F(e) || A(e) || v(e) || b(e) || x(e) } function B(e) { return "value-word" === e.type && ["==", "!="].includes(e.value) } function T(e) { return "value-word" === e.type && ["<", ">", "<=", ">="].includes(e.value) } function w(e) { return "css-atrule" === e.type && ["if", "else", "for", "each", "while"].includes(e.name) } function k(e) { var t; return (null === (t = e.raws) || void 0 === t ? void 0 : t.params) && /^\(\s*\)$/.test(e.raws.params) } function N(e) { return e.name.startsWith("prettier-placeholder") } function j(e) { return e.prop.startsWith("@prettier-placeholder") } function O(e, t) { return "$$" === e.value && "value-func" === e.type && "value-word" === (null == t ? void 0 : t.type) && !t.raws.before } function I(e) { var t, r; return "value-root" === (null === (t = e.value) || void 0 === t ? void 0 : t.type) && "value-value" === (null === (r = e.value.group) || void 0 === r ? void 0 : r.type) && "composes" === e.prop.toLowerCase() } function P(e) { var t, r, n; return "value-paren_group" === (null === (t = e.value) || void 0 === t || null === (r = t.group) || void 0 === r || null === (n = r.group) || void 0 === n ? void 0 : n.type) && null !== e.value.group.group.open && null !== e.value.group.group.close } function L(e) { var t; return "" === (null === (t = e.raws) || void 0 === t ? void 0 : t.before) } function _(e) { var t, r; return "value-comma_group" === e.type && "value-colon" === (null === (t = e.groups) || void 0 === t || null === (r = t[1]) || void 0 === r ? void 0 : r.type) } function R(e) { var t; return "value-paren_group" === e.type && (null === (t = e.groups) || void 0 === t ? void 0 : t[0]) && _(e.groups[0]) } function M(e) { var t; let r = e.getValue(); if (0 === r.groups.length) return !1; let n = e.getParentNode(1); if (!(R(r) || n && R(n))) return !1; let i = u(e, "css-decl"); return !!(null != i && null !== (t = i.prop) && void 0 !== t && t.startsWith("$") || R(n) || "value-func" === n.type) } function $(e) { return "value-comment" === e.type && e.inline } function q(e) { return "value-word" === e.type && "#" === e.value } function V(e) { return "value-word" === e.type && "{" === e.value } function U(e) { return "value-word" === e.type && "}" === e.value } function W(e) { return ["value-word", "value-atword"].includes(e.type) } function G(e) { return "value-colon" === (null == e ? void 0 : e.type) } function z(e, t) { if (!_(t)) return !1; let { groups: r } = t, n = r.indexOf(e); return -1 !== n && G(r[n + 1]) } function H(e) { return e.value && ["not", "and", "or"].includes(e.value.toLowerCase()) } function J(e) { return "value-func" === e.type && r.has(e.value.toLowerCase()) } function X(e) { return /\/\//.test(e.split(/[\n\r]/).pop()) } function K(e) { return "value-atword" === (null == e ? void 0 : e.type) && e.value.startsWith("prettier-placeholder-") } function Y(e, t) { var r, n; if ("(" !== (null === (r = e.open) || void 0 === r ? void 0 : r.value) || ")" !== (null === (n = e.close) || void 0 === n ? void 0 : n.value) || e.groups.some((e => "value-comma_group" !== e.type))) return !1; if ("value-comma_group" === t.type) { let r = t.groups.indexOf(e) - 1, n = t.groups[r]; if ("value-word" === (null == n ? void 0 : n.type) && "with" === n.value) return !0 } return !1 } function Q(e) { var t, r; return "value-paren_group" === e.type && "(" === (null === (t = e.open) || void 0 === t ? void 0 : t.value) && ")" === (null === (r = e.close) || void 0 === r ? void 0 : r.value) } t.exports = { getAncestorCounter: n, getAncestorNode: u, getPropOfDeclNode: i, maybeToLowerCase: l, insideValueFunctionNode: c, insideICSSRuleNode: p, insideAtRuleNode: D, insideURLFunctionInImportAtRuleNode: d, isKeyframeAtRuleKeywords: s, isWideKeywords: a, isLastNode: m, isSCSSControlDirectiveNode: w, isDetachedRulesetDeclarationNode: g, isRelationalOperatorNode: T, isEqualityOperatorNode: B, isMultiplicationNode: F, isDivisionNode: A, isAdditionNode: v, isSubtractionNode: b, isModuloNode: x, isMathOperatorNode: S, isEachKeywordNode: E, isForKeywordNode: h, isURLFunctionNode: f, isIfElseKeywordNode: y, hasComposesNode: I, hasParensAroundNode: P, hasEmptyRawBefore: L, isDetachedRulesetCallNode: k, isTemplatePlaceholderNode: N, isTemplatePropNode: j, isPostcssSimpleVarNode: O, isKeyValuePairNode: _, isKeyValuePairInParenGroupNode: R, isKeyInValuePairNode: z, isSCSSMapItemNode: M, isInlineValueCommentNode: $, isHashNode: q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: U, isWordNode: W, isColonNode: G, isMediaAndSupportsKeywords: H, isColorAdjusterFuncNode: J, lastLineHasInlineComment: X, isAtWordPlaceholderNode: K, isConfigurationNode: Y, isParenGroupNode: Q } } }), In = m({ "src/utils/line-column-to-index.js"(e, t) { C(), t.exports = function (e, t) { let r = 0; for (let n = 0; n < e.line - 1; ++n)r = t.indexOf("\n", r) + 1; return r + e.column } } }), Pn = m({ "src/language-css/loc.js"(e, t) { C(); var { skipEverythingButNewLine: r } = oe(), n = S(), u = In(); function i(e, t) { return "number" == typeof e.sourceIndex ? e.sourceIndex : e.source ? u(e.source.start, t) - 1 : null } function o(e, t) { if ("css-comment" === e.type && e.inline) return r(t, e.source.startOffset); let i = e.nodes && n(e.nodes); return i && e.source && !e.source.end && (e = i), e.source && e.source.end ? u(e.source.end, t) : null } function a(e, t) { e.source && (e.source.startOffset = i(e, t), e.source.endOffset = o(e, t)); for (let r in e) { let n = e[r]; "source" === r || !n || "object" != typeof n || ("value-root" === n.type || "value-unknown" === n.type ? s(n, l(e), n.text || n.value) : a(n, t)) } } function s(e, t, r) { e.source && (e.source.startOffset = i(e, r) + t, e.source.endOffset = o(e, r) + t); for (let n in e) { let u = e[n]; "source" === n || !u || "object" != typeof u || s(u, t, r) } } function l(e) { let t = e.source.startOffset; return "string" == typeof e.prop && (t += e.prop.length), "css-atrule" === e.type && "string" == typeof e.name && (t += 1 + e.name.length + e.raws.afterName.match(/^\s*:?\s*/)[0].length), "css-atrule" !== e.type && e.raws && "string" == typeof e.raws.between && (t += e.raws.between.length), t } function c(e) { let t, r = "initial", n = "initial", u = !1, i = []; for (let o = 0; o < e.length; o++) { let a = e[o]; switch (r) { case "initial": if ("'" === a) { r = "single-quotes"; continue } if ('"' === a) { r = "double-quotes"; continue } if (("u" === a || "U" === a) && "url(" === e.slice(o, o + 4).toLowerCase()) { r = "url", o += 3; continue } if ("*" === a && "/" === e[o - 1]) { r = "comment-block"; continue } if ("/" === a && "/" === e[o - 1]) { r = "comment-inline", t = o - 1; continue } continue; case "single-quotes": if ("'" === a && "\\" !== e[o - 1] && (r = n, n = "initial"), "\n" === a || "\r" === a) return e; continue; case "double-quotes": if ('"' === a && "\\" !== e[o - 1] && (r = n, n = "initial"), "\n" === a || "\r" === a) return e; continue; case "url": if (")" === a && (r = "initial"), "\n" === a || "\r" === a) return e; if ("'" === a) { r = "single-quotes", n = "url"; continue } if ('"' === a) { r = "double-quotes", n = "url"; continue } continue; case "comment-block": "/" === a && "*" === e[o - 1] && (r = "initial"); continue; case "comment-inline": ('"' === a || "'" === a || "*" === a) && (u = !0), ("\n" === a || "\r" === a) && (u && i.push([t, o]), r = "initial", u = !1); continue } } for (let [o, a] of i) e = e.slice(0, o) + e.slice(o, a).replace(/["'*]/g, " ") + e.slice(a); return e } function p(e) { return e.source.startOffset } function D(e) { return e.source.endOffset } t.exports = { locStart: p, locEnd: D, calculateLoc: a, replaceQuotesInInlineComments: c } } }), Ln = m({ "src/language-css/utils/is-less-parser.js"(e, t) { function r(e) { return "css" === e.parser || "less" === e.parser } C(), t.exports = r } }), _n = m({ "src/language-css/utils/is-scss.js"(e, t) { function r(e, t) { return "less" === e || "scss" === e ? "scss" === e : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t) } C(), t.exports = r } }), Rn = m({ "src/language-css/utils/css-units.evaluate.js"(e, t) { t.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" } } }), Mn = m({ "src/language-css/utils/print-unit.js"(e, t) { C(); var r = Rn(); function n(e) { let t = e.toLowerCase(); return Object.prototype.hasOwnProperty.call(r, t) ? r[t] : e } t.exports = n } }), $n = m({ "src/language-css/printer-postcss.js"(e, t) { C(); var r = S(), { printNumber: n, printString: u, hasNewline: i, isFrontMatterNode: o, isNextLineEmpty: a, isNonEmptyArray: s } = pe(), { builders: { join: l, line: c, hardline: p, softline: D, group: d, fill: f, indent: m, dedent: g, ifBreak: h, breakParent: y }, utils: { removeLines: E, getDocParts: F } } = V(), A = Tn(), v = kn(), { insertPragma: b } = jn(), { getAncestorNode: x, getPropOfDeclNode: B, maybeToLowerCase: T, insideValueFunctionNode: w, insideICSSRuleNode: k, insideAtRuleNode: N, insideURLFunctionInImportAtRuleNode: j, isKeyframeAtRuleKeywords: O, isWideKeywords: I, isLastNode: P, isSCSSControlDirectiveNode: L, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: R, isEqualityOperatorNode: M, isMultiplicationNode: $, isDivisionNode: q, isAdditionNode: U, isSubtractionNode: W, isMathOperatorNode: G, isEachKeywordNode: z, isForKeywordNode: H, isURLFunctionNode: J, isIfElseKeywordNode: X, hasComposesNode: K, hasParensAroundNode: Y, hasEmptyRawBefore: Q, isKeyValuePairNode: Z, isKeyInValuePairNode: ee, isDetachedRulesetCallNode: te, isTemplatePlaceholderNode: re, isTemplatePropNode: ne, isPostcssSimpleVarNode: ue, isSCSSMapItemNode: ie, isInlineValueCommentNode: oe, isHashNode: ae, isLeftCurlyBraceNode: se, isRightCurlyBraceNode: le, isWordNode: ce, isColonNode: De, isMediaAndSupportsKeywords: de, isColorAdjusterFuncNode: fe, lastLineHasInlineComment: me, isAtWordPlaceholderNode: ge, isConfigurationNode: he, isParenGroupNode: ye } = On(), { locStart: Ee, locEnd: Ce } = Pn(), Fe = Ln(), Ae = _n(), ve = Mn(); function be(e) { return "es5" === e.trailingComma || "all" === e.trailingComma } function xe(e, t, n) { let i = e.getValue(); if (!i) return ""; if ("string" == typeof i) return i; switch (i.type) { case "front-matter": return [i.raw, p]; case "css-root": { let r = Se(e, t, n), u = i.raws.after.trim(); return u.startsWith(";") && (u = u.slice(1).trim()), [r, u ? ` ${u}` : "", F(r).length > 0 ? p : ""] } case "css-comment": { let e = i.inline || i.raws.inline, r = t.originalText.slice(Ee(i), Ce(i)); return e ? r.trimEnd() : r } case "css-rule": return [n("selector"), i.important ? " !important" : "", i.nodes ? [i.selector && "selector-unknown" === i.selector.type && me(i.selector.value) ? c : " ", "{", i.nodes.length > 0 ? m([p, Se(e, t, n)]) : "", p, "}", _(i) ? ";" : ""] : ";"]; case "css-decl": { let r = e.getParentNode(), { between: u } = i.raws, o = u.trim(), a = ":" === o, s = K(i) ? E(n("value")) : n("value"); return !a && me(o) && (s = m([p, g(s)])), [i.raws.before.replace(/[\s;]/g, ""), "css-atrule" === r.type && r.variable || k(e) ? i.prop : T(i.prop), o.startsWith("//") ? " " : "", o, i.extend ? "" : " ", Fe(t) && i.extend && i.selector ? ["extend(", n("selector"), ")"] : "", s, i.raws.important ? i.raws.important.replace(/\s*!\s*important/i, " !important") : i.important ? " !important" : "", i.raws.scssDefault ? i.raws.scssDefault.replace(/\s*!default/i, " !default") : i.scssDefault ? " !default" : "", i.raws.scssGlobal ? i.raws.scssGlobal.replace(/\s*!global/i, " !global") : i.scssGlobal ? " !global" : "", i.nodes ? [" {", m([D, Se(e, t, n)]), D, "}"] : ne(i) && !r.raws.semicolon && ";" !== t.originalText[Ce(i) - 1] ? "" : t.__isHTMLStyleAttribute && P(e, i) ? h(";") : ";"] } case "css-atrule": { let r = e.getParentNode(), u = re(i) && !r.raws.semicolon && ";" !== t.originalText[Ce(i) - 1]; if (Fe(t)) { if (i.mixin) return [n("selector"), i.important ? " !important" : "", u ? "" : ";"]; if (i.function) return [i.name, n("params"), u ? "" : ";"]; if (i.variable) return ["@", i.name, ": ", i.value ? n("value") : "", i.raws.between.trim() ? i.raws.between.trim() + " " : "", i.nodes ? ["{", m([i.nodes.length > 0 ? D : "", Se(e, t, n)]), D, "}"] : "", u ? "" : ";"] } return ["@", te(i) || i.name.endsWith(":") ? i.name : T(i.name), i.params ? [te(i) ? "" : re(i) ? "" === i.raws.afterName ? "" : i.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(i.raws.afterName) ? [p, p] : /^\s*\n/.test(i.raws.afterName) ? p : " " : " ", n("params")] : "", i.selector ? m([" ", n("selector")]) : "", i.value ? d([" ", n("value"), L(i) ? Y(i) ? " " : c : ""]) : "else" === i.name ? " " : "", i.nodes ? [L(i) ? "" : i.selector && !i.selector.nodes && "string" == typeof i.selector.value && me(i.selector.value) || !i.selector && "string" == typeof i.params && me(i.params) ? c : " ", "{", m([i.nodes.length > 0 ? D : "", Se(e, t, n)]), D, "}"] : u ? "" : ";"] } case "media-query-list": { let t = []; return e.each((e => { let r = e.getValue(); "media-query" === r.type && "" === r.value || t.push(n()) }), "nodes"), d(m(l(c, t))) } case "media-query": return [l(" ", e.map(n, "nodes")), P(e, i) ? "" : ","]; case "media-type": case "media-value": return Ie(je(i.value, t)); case "media-feature-expression": return i.nodes ? ["(", ...e.map(n, "nodes"), ")"] : i.value; case "media-feature": return T(je(i.value.replace(/ +/g, " "), t)); case "media-colon": case "value-comma": return [i.value, " "]; case "media-keyword": case "selector-string": return je(i.value, t); case "media-url": return je(i.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t); case "media-unknown": case "selector-comment": case "selector-nesting": case "value-paren": case "value-operator": case "value-unicode-range": case "value-unknown": return i.value; case "selector-root": return d([N(e, "custom-selector") ? [x(e, "css-atrule").customSelector, c] : "", l([",", N(e, ["extend", "custom-selector", "nest"]) ? c : p], e.map(n, "nodes"))]); case "selector-selector": return d(m(e.map(n, "nodes"))); case "selector-tag": { let t = e.getParentNode(), r = t && t.nodes.indexOf(i), n = r && t.nodes[r - 1]; return [i.namespace ? [!0 === i.namespace ? "" : i.namespace.trim(), "|"] : "", "selector-nesting" === n.type ? i.value : Ie(O(e, i.value) ? i.value.toLowerCase() : i.value)] } case "selector-id": return ["#", i.value]; case "selector-class": return [".", Ie(je(i.value, t))]; case "selector-attribute": var o; return ["[", i.namespace ? [!0 === i.namespace ? "" : i.namespace.trim(), "|"] : "", i.attribute.trim(), null !== (o = i.operator) && void 0 !== o ? o : "", i.value ? Oe(je(i.value.trim(), t), t) : "", i.insensitive ? " i" : "", "]"]; case "selector-combinator": if ("+" === i.value || ">" === i.value || "~" === i.value || ">>>" === i.value) { let t = e.getParentNode(); return ["selector-selector" === t.type && t.nodes[0] === i ? "" : c, i.value, P(e, i) ? "" : " "] } return [i.value.trim().startsWith("(") ? c : "", Ie(je(i.value.trim(), t)) || c]; case "selector-universal": return [i.namespace ? [!0 === i.namespace ? "" : i.namespace.trim(), "|"] : "", i.value]; case "selector-pseudo": return [T(i.value), s(i.nodes) ? d(["(", m([D, l([",", c], e.map(n, "nodes"))]), D, ")"]) : ""]; case "selector-unknown": { let r = x(e, "css-rule"); if (r && r.isSCSSNesterProperty) return Ie(je(T(i.value), t)); let n = e.getParentNode(); if (n.raws && n.raws.selector) { let e = Ee(n), r = e + n.raws.selector.length; return t.originalText.slice(e, r).trim() } let u = e.getParentNode(1); if ("value-paren_group" === n.type && u && "value-func" === u.type && "selector" === u.value) { let e = Ce(n.open) + 1, r = Ee(n.close), u = t.originalText.slice(e, r).trim(); return me(u) ? [y, u] : u } return i.value } case "value-value": case "value-root": return n("group"); case "value-comment": return t.originalText.slice(Ee(i), Ce(i)); case "value-comma_group": { let r = e.getParentNode(), u = e.getParentNode(1), o = B(e), a = o && "value-value" === r.type && ("grid" === o || o.startsWith("grid-template")), s = x(e, "css-atrule"), l = s && L(s), h = i.groups.some((e => oe(e))), E = e.map(n, "groups"), F = [], A = w(e, "url"), v = !1, b = !1; for (let n = 0; n < i.groups.length; ++n) { var C; F.push(E[n]); let o = i.groups[n - 1], d = i.groups[n], f = i.groups[n + 1], m = i.groups[n + 2]; if (A) { (f && U(f) || U(d)) && F.push(" "); continue } if (N(e, "forward") && "value-word" === d.type && d.value && void 0 !== o && "value-word" === o.type && "as" === o.value && "value-operator" === f.type && "*" === f.value || !f || "value-word" === d.type && d.value.endsWith("-") && ge(f)) continue; if ("value-string" === d.type && d.quoted) { let e = d.value.lastIndexOf("#{"), t = d.value.lastIndexOf("}"); -1 !== e && -1 !== t ? v = e > t : -1 !== e ? v = !0 : -1 !== t && (v = !1) } if (v || De(d) || De(f) || "value-atword" === d.type && ("" === d.value || d.value.endsWith("[")) || "value-word" === f.type && f.value.startsWith("]") || "~" === d.value || d.value && d.value.includes("\\") && f && "value-comment" !== f.type || o && o.value && o.value.indexOf("\\") === o.value.length - 1 && "value-operator" === d.type && "/" === d.value || "\\" === d.value || ue(d, f) || ae(d) || se(d) || le(f) || se(f) && Q(f) || le(d) && Q(f) || "--" === d.value && ae(f)) continue; let h = G(d), y = G(f); if ((h && ae(f) || y && le(d)) && Q(f) || !o && q(d) || w(e, "calc") && (U(d) || U(f) || W(d) || W(f)) && Q(f)) continue; let x = (U(d) || W(d)) && 0 === n && ("value-number" === f.type || f.isHex) && u && fe(u) && !Q(f), S = m && "value-func" === m.type || m && ce(m) || "value-func" === d.type || ce(d), B = "value-func" === f.type || ce(f) || o && "value-func" === o.type || o && ce(o); if (($(f) || $(d) || w(e, "calc") || x || !(q(f) && !S || q(d) && !B || U(f) && !S || U(d) && !B || W(f) || W(d)) || !(Q(f) || h && (!o || o && G(o)))) && ("scss" !== t.parser && "less" !== t.parser || !h || "-" !== d.value || !ye(f) || Ce(d) !== Ee(f.open) || "(" !== f.open.value)) { if (oe(d)) { if ("value-paren_group" === r.type) { F.push(g(p)); continue } F.push(p); continue } if (l && (M(f) || R(f) || X(f) || z(d) || H(d))) { F.push(" "); continue } if (s && "namespace" === s.name.toLowerCase()) { F.push(" "); continue } if (a) { d.source && f.source && d.source.start.line !== f.source.start.line ? (F.push(p), b = !0) : F.push(" "); continue } if (y) { F.push(" "); continue } if (!(f && "..." === f.value || ge(d) && ge(f) && Ce(d) === Ee(f))) { if (ge(d) && ye(f) && Ce(d) === Ee(f.open)) { F.push(D); continue } if ("with" === d.value && ye(f)) { F.push(" "); continue } null !== (C = d.value) && void 0 !== C && C.endsWith("#") && "{" === f.value && ye(f.group) || F.push(c) } } } return h && F.push(y), b && F.unshift(p), l ? d(m(F)) : j(e) ? d(f(F)) : d(m(f(F))) } case "value-paren_group": { let u = e.getParentNode(); if (u && J(u) && (1 === i.groups.length || i.groups.length > 0 && "value-comma_group" === i.groups[0].type && i.groups[0].groups.length > 0 && "value-word" === i.groups[0].groups[0].type && i.groups[0].groups[0].value.startsWith("data:"))) return [i.open ? n("open") : "", l(",", e.map(n, "groups")), i.close ? n("close") : ""]; if (!i.open) { let t = e.map(n, "groups"), r = []; for (let e = 0; e < t.length; e++)0 !== e && r.push([",", c]), r.push(t[e]); return d(m(f(r))) } let o = ie(e), y = r(i.groups), E = y && "value-comment" === y.type, C = ee(i, u), A = he(i, u), v = A || o && !C, b = A || C, x = d([i.open ? n("open") : "", m([D, l([c], e.map(((e, u) => { let o = e.getValue(), l = u === i.groups.length - 1, c = [n(), l ? "" : ","]; if (Z(o) && "value-comma_group" === o.type && o.groups && "value-paren_group" !== o.groups[0].type && o.groups[2] && "value-paren_group" === o.groups[2].type) { let e = F(c[0].contents.contents); e[1] = d(e[1]), c = [d(g(c))] } if (!l && "value-comma_group" === o.type && s(o.groups)) { let e = r(o.groups); !e.source && e.close && (e = e.close), e.source && a(t.originalText, e, Ce) && c.push(p) } return c }), "groups"))]), h(!E && Ae(t.parser, t.originalText) && o && be(t) ? "," : ""), D, i.close ? n("close") : ""], { shouldBreak: v }); return b ? g(x) : x } case "value-func": return [i.value, N(e, "supports") && de(i) ? " " : "", n("group")]; case "value-number": return [Pe(i.value), ve(i.unit)]; case "value-word": return i.isColor && i.isHex || I(i.value) ? i.value.toLowerCase() : i.value; case "value-colon": { let t = e.getParentNode(), n = t && t.groups.indexOf(i), u = n && t.groups[n - 1]; return [i.value, u && "string" == typeof u.value && "\\" === r(u.value) || w(e, "url") ? "" : c] } case "value-string": return u(i.raws.quote + i.value + i.raws.quote, t); case "value-atword": return ["@", i.value]; default: throw new Error(`Unknown postcss type ${JSON.stringify(i.type)}`) } } function Se(e, t, r) { let n = []; return e.each(((e, u, s) => { let l = s[u - 1]; if (l && "css-comment" === l.type && "prettier-ignore" === l.text.trim()) { let r = e.getValue(); n.push(t.originalText.slice(Ee(r), Ce(r))) } else n.push(r()); u !== s.length - 1 && ("css-comment" === s[u + 1].type && !i(t.originalText, Ee(s[u + 1]), { backwards: !0 }) && !o(s[u]) || "css-atrule" === s[u + 1].type && "else" === s[u + 1].name && "css-comment" !== s[u].type ? n.push(" ") : (n.push(t.__isHTMLStyleAttribute ? c : p), a(t.originalText, e.getValue(), Ce) && !o(s[u]) && n.push(p))) }), "nodes"), n } var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Te = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, we = /[A-Za-z]+/g, ke = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ne = new RegExp(Be.source + `|(${ke.source})?(${Te.source})(${we.source})?`, "g"); function je(e, t) { return e.replace(Be, (e => u(e, t))) } function Oe(e, t) { let r = t.singleQuote ? "'" : '"'; return e.includes('"') || e.includes("'") ? e : r + e + r } function Ie(e) { return e.replace(Ne, ((e, t, r, n, u) => !r && n ? Pe(n) + T(u || "") : e)) } function Pe(e) { return n(e).replace(/\.0(?=$|e)/, "") } t.exports = { print: xe, embed: v, insertPragma: b, massageAstNode: A } } }), qn = m({ "src/language-css/options.js"(e, t) { C(); var r = yn(); t.exports = { singleQuote: r.singleQuote } } }), Vn = m({ "src/language-css/parsers.js"() { C() } }), Un = m({ "node_modules/linguist-languages/data/CSS.json"(e, t) { t.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 } } }), Wn = m({ "node_modules/linguist-languages/data/PostCSS.json"(e, t) { t.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 } } }), Gn = m({ "node_modules/linguist-languages/data/Less.json"(e, t) { t.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 } } }), zn = m({ "node_modules/linguist-languages/data/SCSS.json"(e, t) { t.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 } } }), Hn = m({ "src/language-css/index.js"(e, t) { C(); var r = Kt(), n = $n(), u = qn(), i = Vn(), o = [r(Un(), (e => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e.extensions, ".wxss"] }))), r(Wn(), (() => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] }))), r(Gn(), (() => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] }))), r(zn(), (() => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] })))], a = { postcss: n }; t.exports = { languages: o, options: u, printers: a, parsers: i } } }), Jn = m({ "src/language-handlebars/loc.js"(e, t) { function r(e) { return e.loc.start.offset } function n(e) { return e.loc.end.offset } C(), t.exports = { locStart: r, locEnd: n } } }), Xn = m({ "src/language-handlebars/clean.js"(e, t) { function r(e, t) { if ("TextNode" === e.type) { let r = e.chars.trim(); if (!r) return null; t.chars = r.replace(/[\t\n\f\r ]+/g, " ") } "AttrNode" === e.type && "class" === e.name.toLowerCase() && delete t.value } C(), r.ignoredProperties = new Set(["loc", "selfClosing"]), t.exports = r } }), Kn = m({ "src/language-handlebars/html-void-elements.evaluate.js"(e, t) { t.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"] } }), Yn = m({ "src/language-handlebars/utils.js"(e, t) { C(); var r = S(), n = Kn(); function u(e) { let t = e.getValue(), n = e.getParentNode(0); return !!(D(e, ["ElementNode"]) && r(n.children) === t || D(e, ["Block"]) && r(n.body) === t) } function i(e) { return e.toUpperCase() === e } function o(e) { return p(e, ["ElementNode"]) && "string" == typeof e.tag && !e.tag.startsWith(":") && (i(e.tag[0]) || e.tag.includes(".")) } var a = new Set(n); function s(e) { return a.has(e.toLowerCase()) && !i(e[0]) } function l(e) { return !0 === e.selfClosing || s(e.tag) || o(e) && e.children.every((e => c(e))) } function c(e) { return p(e, ["TextNode"]) && !/\S/.test(e.chars) } function p(e, t) { return e && t.includes(e.type) } function D(e, t) { return p(e.getParentNode(0), t) } function d(e, t) { return p(g(e), t) } function f(e, t) { return p(h(e), t) } function m(e, t) { var r, n, u, i; let o = e.getValue(), a = null !== (r = e.getParentNode(0)) && void 0 !== r ? r : {}, s = null !== (n = null !== (u = null !== (i = a.children) && void 0 !== i ? i : a.body) && void 0 !== u ? u : a.parts) && void 0 !== n ? n : [], l = s.indexOf(o); return -1 !== l && s[l + t] } function g(e) { return m(e, -(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1)) } function h(e) { return m(e, 1) } function y(e) { return p(e, ["MustacheCommentStatement"]) && "string" == typeof e.value && "prettier-ignore" === e.value.trim() } function E(e) { let t = e.getValue(), r = g(e, 2); return y(t) || y(r) } t.exports = { getNextNode: h, getPreviousNode: g, hasPrettierIgnore: E, isLastNodeOfSiblings: u, isNextNodeOfSomeType: f, isNodeOfSomeType: p, isParentOfSomeType: D, isPreviousNodeOfSomeType: d, isVoid: l, isWhitespaceNode: c } } }), Qn = m({ "src/language-handlebars/printer-glimmer.js"(e, t) { C(); var { builders: { dedent: r, fill: n, group: u, hardline: i, ifBreak: o, indent: a, join: s, line: l, softline: c }, utils: { getDocParts: p, replaceTextEndOfLine: D } } = V(), { getPreferredQuote: d, isNonEmptyArray: f } = pe(), { locStart: m, locEnd: g } = Jn(), h = Xn(), { getNextNode: y, getPreviousNode: E, hasPrettierIgnore: F, isLastNodeOfSiblings: A, isNextNodeOfSomeType: v, isNodeOfSomeType: b, isParentOfSomeType: x, isPreviousNodeOfSomeType: S, isVoid: B, isWhitespaceNode: T } = Yn(), w = 2; function k(e, t, o) { let p = e.getValue(); if (!p) return ""; if (F(e)) return t.originalText.slice(m(p), g(p)); let f = t.singleQuote ? "'" : '"'; switch (p.type) { case "Block": case "Program": case "Template": return u(e.map(o, "body")); case "ElementNode": { let r = u(j(e, o)), n = "ignore" === t.htmlWhitespaceSensitivity && v(e, ["ElementNode"]) ? c : ""; if (B(p)) return [r, n]; let s = ["</", p.tag, ">"]; return 0 === p.children.length ? [r, a(s), n] : "ignore" === t.htmlWhitespaceSensitivity ? [r, a(O(e, t, o)), i, a(s), n] : [r, a(u(O(e, t, o))), a(s), n] } case "BlockStatement": { let r = e.getParentNode(1); return r && r.inverse && 1 === r.inverse.body.length && r.inverse.body[0] === p && r.inverse.body[0].path.parts[0] === r.path.parts[0] ? [z(e, o, r.inverse.body[0].path.parts[0]), Y(e, o, t), Q(e, o, t)] : [W(e, o), u([Y(e, o, t), Q(e, o, t), H(e, o, t)])] } case "ElementModifierStatement": return u(["{{", le(e, o), "}}"]); case "MustacheStatement": return u([P(p), le(e, o), L(p)]); case "SubExpression": return u(["(", se(e, o), c, ")"]); case "AttrNode": { let e = "TextNode" === p.value.type; if (e && "" === p.value.chars && m(p.value) === g(p.value)) return p.name; let t = e ? d(p.value.chars, f).quote : "ConcatStatement" === p.value.type ? d(p.value.parts.filter((e => "TextNode" === e.type)).map((e => e.chars)).join(""), f).quote : "", r = o("value"); return [p.name, "=", t, "class" === p.name && t ? u(a(r)) : r, t] } case "ConcatStatement": return e.map(o, "parts"); case "Hash": return s(l, e.map(o, "pairs")); case "HashPair": return [p.key, "=", o("value")]; case "TextNode": { let u = p.chars.replace(/{{/g, "\\{{"), i = te(e); if (i) { if ("class" === i) { let t = u.trim().split(/\s+/).join(" "), r = !1, n = !1; return x(e, ["ConcatStatement"]) && (S(e, ["MustacheStatement"]) && /^\s/.test(u) && (r = !0), v(e, ["MustacheStatement"]) && /\s$/.test(u) && "" !== t && (n = !0)), [r ? l : "", t, n ? l : ""] } return D(u) } let o = /^[\t\n\f\r ]*$/.test(u), a = !E(e), s = !y(e); if ("ignore" !== t.htmlWhitespaceSensitivity) { let t = /^[\t\n\f\r ]*/, i = /[\t\n\f\r ]*$/, c = s && x(e, ["Template"]), p = a && x(e, ["Template"]); if (o) { if (p || c) return ""; let t = [l], n = re(u); return n && (t = ie(n)), A(e) && (t = t.map((e => r(e)))), t } let [D] = u.match(t), [d] = u.match(i), f = []; if (D) { f = [l]; let e = re(D); e && (f = ie(e)), u = u.replace(t, "") } let m = []; if (d) { if (!c) { m = [l]; let t = re(d); t && (m = ie(t)), A(e) && (m = m.map((e => r(e)))) } u = u.replace(i, "") } return [...f, n(Z(u)), ...m] } let c = re(u), d = ne(u), f = ue(u); if ((a || s) && o && x(e, ["Block", "ElementNode", "Template"])) return ""; o && c ? (d = Math.min(c, w), f = 0) : (v(e, ["BlockStatement", "ElementNode"]) && (f = Math.max(f, 1)), S(e, ["BlockStatement", "ElementNode"]) && (d = Math.max(d, 1))); let m = "", g = ""; return 0 === f && v(e, ["MustacheStatement"]) && (g = " "), 0 === d && S(e, ["MustacheStatement"]) && (m = " "), a && (d = 0, m = ""), s && (f = 0, g = ""), u = u.replace(/^[\t\n\f\r ]+/g, m).replace(/[\t\n\f\r ]+$/, g), [...ie(d), n(Z(u)), ...ie(f)] } case "MustacheCommentStatement": { let e = m(p), r = g(p), n = "~" === t.originalText.charAt(e + 2), u = "~" === t.originalText.charAt(r - 3), i = p.value.includes("}}") ? "--" : ""; return ["{{", n ? "~" : "", "!", i, p.value, i, u ? "~" : "", "}}"] } case "PathExpression": return p.original; case "BooleanLiteral": case "NumberLiteral": return String(p.value); case "CommentStatement": return ["\x3c!--", p.value, "--\x3e"]; case "StringLiteral": if (ae(e)) { let e = t.singleQuote ? '"' : "'"; return oe(p.value, e) } return oe(p.value, f); case "UndefinedLiteral": return "undefined"; case "NullLiteral": return "null"; default: throw new Error("unknown glimmer type: " + JSON.stringify(p.type)) } } function N(e, t) { return m(e) - m(t) } function j(e, t) { let r = e.getValue(), n = ["attributes", "modifiers", "comments"].filter((e => f(r[e]))), u = n.flatMap((e => r[e])).sort(N); for (let i of n) e.each((e => { let r = u.indexOf(e.getValue()); u.splice(r, 1, [l, t()]) }), i); return f(r.blockParams) && u.push(l, de(r)), ["<", r.tag, a(u), I(r)] } function O(e, t, r) { let n = e.getValue().children.every((e => T(e))); return "ignore" === t.htmlWhitespaceSensitivity && n ? "" : e.map(((e, n) => { let u = r(); return 0 === n && "ignore" === t.htmlWhitespaceSensitivity ? [c, u] : u }), "children") } function I(e) { return B(e) ? o([c, "/>"], [" />", c]) : o([c, ">"], ">") } function P(e) { return [!1 === e.escaped ? "{{{" : "{{", e.strip && e.strip.open ? "~" : ""] } function L(e) { let t = !1 === e.escaped ? "}}}" : "}}"; return [e.strip && e.strip.close ? "~" : "", t] } function _(e) { return [P(e), e.openStrip.open ? "~" : "", "#"] } function R(e) { let t = L(e); return [e.openStrip.close ? "~" : "", t] } function M(e) { return [P(e), e.closeStrip.open ? "~" : "", "/"] } function $(e) { let t = L(e); return [e.closeStrip.close ? "~" : "", t] } function q(e) { return [P(e), e.inverseStrip.open ? "~" : ""] } function U(e) { let t = L(e); return [e.inverseStrip.close ? "~" : "", t] } function W(e, t) { let r = e.getValue(), n = [], i = De(e, t); return i && n.push(u(i)), f(r.program.blockParams) && n.push(de(r.program)), u([_(r), ce(e, t), n.length > 0 ? a([l, s(l, n)]) : "", c, R(r)]) } function G(e, t) { return ["ignore" === t.htmlWhitespaceSensitivity ? i : "", q(e), "else", U(e)] } function z(e, t, r) { let n = e.getValue(), i = e.getParentNode(1); return u([q(i), ["else", " ", r], a([l, u(De(e, t)), ...f(n.program.blockParams) ? [l, de(n.program)] : []]), c, U(i)]) } function H(e, t, r) { let n = e.getValue(); return "ignore" === r.htmlWhitespaceSensitivity ? [J(n) ? c : i, M(n), t("path"), $(n)] : [M(n), t("path"), $(n)] } function J(e) { return b(e, ["BlockStatement"]) && e.program.body.every((e => T(e))) } function X(e) { return K(e) && 1 === e.inverse.body.length && b(e.inverse.body[0], ["BlockStatement"]) && e.inverse.body[0].path.parts[0] === e.path.parts[0] } function K(e) { return b(e, ["BlockStatement"]) && e.inverse } function Y(e, t, r) { if (J(e.getValue())) return ""; let n = t("program"); return "ignore" === r.htmlWhitespaceSensitivity ? a([i, n]) : a(n) } function Q(e, t, r) { let n = e.getValue(), u = t("inverse"), o = "ignore" === r.htmlWhitespaceSensitivity ? [i, u] : u; return X(n) ? o : K(n) ? [G(n, r), a(o)] : "" } function Z(e) { return p(s(l, ee(e))) } function ee(e) { return e.split(/[\t\n\f\r ]+/) } function te(e) { for (let t = 0; t < 2; t++) { let r = e.getParentNode(t); if (r && "AttrNode" === r.type) return r.name.toLowerCase() } } function re(e) { return (e = "string" == typeof e ? e : "").split("\n").length - 1 } function ne(e) { return re(((e = "string" == typeof e ? e : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "") } function ue(e) { return re(((e = "string" == typeof e ? e : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "") } function ie() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; return Array.from({ length: Math.min(e, w) }).fill(i) } function oe(e, t) { let { quote: r, regex: n } = d(e, t); return [r, e.replace(n, `\\${r}`), r] } function ae(e) { let t = 0, r = e.getParentNode(t); for (; r && b(r, ["SubExpression"]);)t++, r = e.getParentNode(t); return !!(r && b(e.getParentNode(t + 1), ["ConcatStatement"]) && b(e.getParentNode(t + 2), ["AttrNode"])) } function se(e, t) { let r = ce(e, t), n = De(e, t); return n ? a([r, l, u(n)]) : r } function le(e, t) { let r = ce(e, t), n = De(e, t); return n ? [a([r, l, n]), c] : r } function ce(e, t) { return t("path") } function De(e, t) { let r = e.getValue(), n = []; if (r.params.length > 0) { let r = e.map(t, "params"); n.push(...r) } if (r.hash && r.hash.pairs.length > 0) { let e = t("hash"); n.push(e) } return 0 === n.length ? "" : s(l, n) } function de(e) { return ["as |", e.blockParams.join(" "), "|"] } t.exports = { print: k, massageAstNode: h } } }), Zn = m({ "src/language-handlebars/parsers.js"() { C() } }), eu = m({ "node_modules/linguist-languages/data/Handlebars.json"(e, t) { t.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 } } }), tu = m({ "src/language-handlebars/index.js"(e, t) { C(); var r = Kt(), n = Qn(), u = Zn(), i = [r(eu(), (() => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] })))], o = { glimmer: n }; t.exports = { languages: i, printers: o, parsers: u } } }), ru = m({ "src/language-graphql/pragma.js"(e, t) { function r(e) { return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e) } function n(e) { return "# @format\n\n" + e } C(), t.exports = { hasPragma: r, insertPragma: n } } }), nu = m({ "src/language-graphql/loc.js"(e, t) { function r(e) { return "number" == typeof e.start ? e.start : e.loc && e.loc.start } function n(e) { return "number" == typeof e.end ? e.end : e.loc && e.loc.end } C(), t.exports = { locStart: r, locEnd: n } } }), uu = m({ "src/language-graphql/printer-graphql.js"(e, t) { C(); var { builders: { join: r, hardline: n, line: u, softline: i, group: o, indent: a, ifBreak: s } } = V(), { isNextLineEmpty: l, isNonEmptyArray: c } = pe(), { insertPragma: p } = ru(), { locStart: D, locEnd: d } = nu(); function f(e, t, p) { let f = e.getValue(); if (!f) return ""; if ("string" == typeof f) return f; switch (f.kind) { case "Document": { let r = []; return e.each(((e, u, i) => { r.push(p()), u !== i.length - 1 && (r.push(n), l(t.originalText, e.getValue(), d) && r.push(n)) }), "definitions"), [...r, n] } case "OperationDefinition": { let n = "{" !== t.originalText[D(f)], u = Boolean(f.name); return [n ? f.operation : "", n && u ? [" ", p("name")] : "", n && !u && c(f.variableDefinitions) ? " " : "", c(f.variableDefinitions) ? o(["(", a([i, r([s("", ", "), i], e.map(p, "variableDefinitions"))]), i, ")"]) : "", m(e, p, f), f.selectionSet && (n || u) ? " " : "", p("selectionSet")] } case "FragmentDefinition": return ["fragment ", p("name"), c(f.variableDefinitions) ? o(["(", a([i, r([s("", ", "), i], e.map(p, "variableDefinitions"))]), i, ")"]) : "", " on ", p("typeCondition"), m(e, p, f), " ", p("selectionSet")]; case "SelectionSet": return ["{", a([n, r(n, g(e, t, p, "selections"))]), n, "}"]; case "Field": return o([f.alias ? [p("alias"), ": "] : "", p("name"), f.arguments.length > 0 ? o(["(", a([i, r([s("", ", "), i], g(e, t, p, "arguments"))]), i, ")"]) : "", m(e, p, f), f.selectionSet ? " " : "", p("selectionSet")]); case "Name": case "IntValue": case "FloatValue": case "EnumValue": return f.value; case "StringValue": if (f.block) { let e = f.value.replace(/"""/g, "\\$&").split("\n"); return 1 === e.length && (e[0] = e[0].trim()), e.every((e => "" === e)) && (e.length = 0), r(n, ['"""', ...e, '"""']) } return ['"', f.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"']; case "BooleanValue": return f.value ? "true" : "false"; case "NullValue": return "null"; case "Variable": return ["$", p("name")]; case "ListValue": return o(["[", a([i, r([s("", ", "), i], e.map(p, "values"))]), i, "]"]); case "ObjectValue": return o(["{", t.bracketSpacing && f.fields.length > 0 ? " " : "", a([i, r([s("", ", "), i], e.map(p, "fields"))]), i, s("", t.bracketSpacing && f.fields.length > 0 ? " " : ""), "}"]); case "ObjectField": case "Argument": return [p("name"), ": ", p("value")]; case "Directive": return ["@", p("name"), f.arguments.length > 0 ? o(["(", a([i, r([s("", ", "), i], g(e, t, p, "arguments"))]), i, ")"]) : ""]; case "NamedType": return p("name"); case "VariableDefinition": return [p("variable"), ": ", p("type"), f.defaultValue ? [" = ", p("defaultValue")] : "", m(e, p, f)]; case "ObjectTypeExtension": case "ObjectTypeDefinition": return [p("description"), f.description ? n : "", "ObjectTypeExtension" === f.kind ? "extend " : "", "type ", p("name"), f.interfaces.length > 0 ? [" implements ", ...E(e, t, p)] : "", m(e, p, f), f.fields.length > 0 ? [" {", a([n, r(n, g(e, t, p, "fields"))]), n, "}"] : ""]; case "FieldDefinition": return [p("description"), f.description ? n : "", p("name"), f.arguments.length > 0 ? o(["(", a([i, r([s("", ", "), i], g(e, t, p, "arguments"))]), i, ")"]) : "", ": ", p("type"), m(e, p, f)]; case "DirectiveDefinition": return [p("description"), f.description ? n : "", "directive ", "@", p("name"), f.arguments.length > 0 ? o(["(", a([i, r([s("", ", "), i], g(e, t, p, "arguments"))]), i, ")"]) : "", f.repeatable ? " repeatable" : "", " on ", r(" | ", e.map(p, "locations"))]; case "EnumTypeExtension": case "EnumTypeDefinition": return [p("description"), f.description ? n : "", "EnumTypeExtension" === f.kind ? "extend " : "", "enum ", p("name"), m(e, p, f), f.values.length > 0 ? [" {", a([n, r(n, g(e, t, p, "values"))]), n, "}"] : ""]; case "EnumValueDefinition": return [p("description"), f.description ? n : "", p("name"), m(e, p, f)]; case "InputValueDefinition": return [p("description"), f.description ? f.description.block ? n : u : "", p("name"), ": ", p("type"), f.defaultValue ? [" = ", p("defaultValue")] : "", m(e, p, f)]; case "InputObjectTypeExtension": case "InputObjectTypeDefinition": return [p("description"), f.description ? n : "", "InputObjectTypeExtension" === f.kind ? "extend " : "", "input ", p("name"), m(e, p, f), f.fields.length > 0 ? [" {", a([n, r(n, g(e, t, p, "fields"))]), n, "}"] : ""]; case "SchemaExtension": return ["extend schema", m(e, p, f), ...f.operationTypes.length > 0 ? [" {", a([n, r(n, g(e, t, p, "operationTypes"))]), n, "}"] : []]; case "SchemaDefinition": return [p("description"), f.description ? n : "", "schema", m(e, p, f), " {", f.operationTypes.length > 0 ? a([n, r(n, g(e, t, p, "operationTypes"))]) : "", n, "}"]; case "OperationTypeDefinition": return [p("operation"), ": ", p("type")]; case "InterfaceTypeExtension": case "InterfaceTypeDefinition": return [p("description"), f.description ? n : "", "InterfaceTypeExtension" === f.kind ? "extend " : "", "interface ", p("name"), f.interfaces.length > 0 ? [" implements ", ...E(e, t, p)] : "", m(e, p, f), f.fields.length > 0 ? [" {", a([n, r(n, g(e, t, p, "fields"))]), n, "}"] : ""]; case "FragmentSpread": return ["...", p("name"), m(e, p, f)]; case "InlineFragment": return ["...", f.typeCondition ? [" on ", p("typeCondition")] : "", m(e, p, f), " ", p("selectionSet")]; case "UnionTypeExtension": case "UnionTypeDefinition": return o([p("description"), f.description ? n : "", o(["UnionTypeExtension" === f.kind ? "extend " : "", "union ", p("name"), m(e, p, f), f.types.length > 0 ? [" =", s("", " "), a([s([u, "  "]), r([u, "| "], e.map(p, "types"))])] : ""])]); case "ScalarTypeExtension": case "ScalarTypeDefinition": return [p("description"), f.description ? n : "", "ScalarTypeExtension" === f.kind ? "extend " : "", "scalar ", p("name"), m(e, p, f)]; case "NonNullType": return [p("type"), "!"]; case "ListType": return ["[", p("type"), "]"]; default: throw new Error("unknown graphql type: " + JSON.stringify(f.kind)) } } function m(e, t, n) { if (0 === n.directives.length) return ""; let s = r(u, e.map(t, "directives")); return "FragmentDefinition" === n.kind || "OperationDefinition" === n.kind ? o([u, s]) : [" ", o(a([i, s]))] } function g(e, t, r, u) { return e.map(((e, u, i) => { let o = r(); return u < i.length - 1 && l(t.originalText, e.getValue(), d) ? [o, n] : o }), u) } function h(e) { return e.kind && "Comment" !== e.kind } function y(e) { let t = e.getValue(); if ("Comment" === t.kind) return "#" + t.value.trimEnd(); throw new Error("Not a comment: " + JSON.stringify(t)) } function E(e, t, r) { let n = e.getNode(), i = [], { interfaces: o } = n, a = e.map((e => r(e)), "interfaces"); for (let s = 0; s < o.length; s++) { let e = o[s]; i.push(a[s]); let r = o[s + 1]; if (r) { let n = t.originalText.slice(e.loc.end, r.loc.start), o = n.includes("#"), a = n.replace(/#.*/g, "").trim(); i.push("," === a ? "," : " &", o ? u : " ") } } return i } function F(e, t) { "StringValue" === e.kind && e.block && !e.value.includes("\n") && (t.value = t.value.trim()) } function A(e) { var t; let r = e.getValue(); return null == r || null === (t = r.comments) || void 0 === t ? void 0 : t.some((e => "prettier-ignore" === e.value.trim())) } F.ignoredProperties = new Set(["loc", "comments"]), t.exports = { print: f, massageAstNode: F, hasPrettierIgnore: A, insertPragma: p, printComment: y, canAttachComment: h } } }), iu = m({ "src/language-graphql/options.js"(e, t) { C(); var r = yn(); t.exports = { bracketSpacing: r.bracketSpacing } } }), ou = m({ "src/language-graphql/parsers.js"() { C() } }), au = m({ "node_modules/linguist-languages/data/GraphQL.json"(e, t) { t.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 } } }), su = m({ "src/language-graphql/index.js"(e, t) { C(); var r = Kt(), n = uu(), u = iu(), i = ou(), o = [r(au(), (() => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] })))], a = { graphql: n }; t.exports = { languages: o, options: u, printers: a, parsers: i } } }), lu = m({ "node_modules/collapse-white-space/index.js"(e, t) { function r(e) { return String(e).replace(/\s+/g, " ") } C(), t.exports = r } }), cu = m({ "src/language-markdown/loc.js"(e, t) { function r(e) { return e.position.start.offset } function n(e) { return e.position.end.offset } C(), t.exports = { locStart: r, locEnd: n } } }), pu = m({ "src/language-markdown/constants.evaluate.js"(e, t) { t.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" } } }), Du = m({ "src/language-markdown/utils.js"(e, t) { C(); var { getLast: r } = pe(), { locStart: n, locEnd: u } = cu(), { cjkPattern: i, kPattern: o, punctuationPattern: a } = pu(), s = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], l = [...s, "tableCell", "paragraph", "heading"], c = new RegExp(o), p = new RegExp(a); function D(e, t) { let n = "non-cjk", u = "cj-letter", o = "k-letter", a = "cjk-punctuation", s = [], l = ("preserve" === t.proseWrap ? e : e.replace(new RegExp(`(${i})\n(${i})`, "g"), "$1$2")).split(/([\t\n ]+)/); for (let [d, f] of l.entries()) { if (d % 2 == 1) { s.push({ type: "whitespace", value: /\n/.test(f) ? "\n" : " " }); continue } if ((0 === d || d === l.length - 1) && "" === f) continue; let e = f.split(new RegExp(`(${i})`)); for (let [t, i] of e.entries()) if (0 !== t && t !== e.length - 1 || "" !== i) { if (t % 2 == 0) { "" !== i && D({ type: "word", value: i, kind: n, hasLeadingPunctuation: p.test(i[0]), hasTrailingPunctuation: p.test(r(i)) }); continue } D(p.test(i) ? { type: "word", value: i, kind: a, hasLeadingPunctuation: !0, hasTrailingPunctuation: !0 } : { type: "word", value: i, kind: c.test(i) ? o : u, hasLeadingPunctuation: !1, hasTrailingPunctuation: !1 }) } } return s; function D(e) { let t = r(s); function i(r, n) { return t.kind === r && e.kind === n || t.kind === n && e.kind === r } t && "word" === t.type && (t.kind === n && e.kind === u && !t.hasTrailingPunctuation || t.kind === u && e.kind === n && !e.hasLeadingPunctuation ? s.push({ type: "whitespace", value: " " }) : !i(n, a) && ![t.value, e.value].some((e => /\u3000/.test(e))) && s.push({ type: "whitespace", value: "" })), s.push(e) } } function d(e, t) { let [, r, n, u] = t.slice(e.position.start.offset, e.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/); return { numberText: r, marker: n, leadingSpaces: u } } function f(e, t) { if (!e.ordered || e.children.length < 2) return !1; let r = Number(d(e.children[0], t.originalText).numberText), n = Number(d(e.children[1], t.originalText).numberText); if (0 === r && e.children.length > 2) { let r = Number(d(e.children[2], t.originalText).numberText); return 1 === n && 1 === r } return 1 === n } function m(e, t) { let { value: r } = e; return e.position.end.offset === t.length && r.endsWith("\n") && t.endsWith("\n") ? r.slice(0, -1) : r } function g(e, t) { return function e(r, n, u) { let i = Object.assign({}, t(r, n, u)); return i.children && (i.children = i.children.map(((t, r) => e(t, r, [i, ...u])))), i }(e, null, []) } function h(e) { if ("link" !== (null == e ? void 0 : e.type) || 1 !== e.children.length) return !1; let [t] = e.children; return n(e) === n(t) && u(e) === u(t) } t.exports = { mapAst: g, splitText: D, punctuationPattern: a, getFencedCodeBlockValue: m, getOrderedListItemInfo: d, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: s, INLINE_NODE_WRAPPER_TYPES: l, isAutolink: h } } }), du = m({ "src/language-markdown/embed.js"(e, t) { C(); var { inferParserByLanguage: r, getMaxContinuousCount: n } = pe(), { builders: { hardline: u, markAsRoot: i }, utils: { replaceEndOfLine: o } } = V(), a = wn(), { getFencedCodeBlockValue: s } = Du(); function l(e, t, l, c) { let p = e.getValue(); if ("code" === p.type && null !== p.lang) { let e = r(p.lang, c); if (e) { let t = c.__inJsTemplate ? "~" : "`", r = t.repeat(Math.max(3, n(p.value, t) + 1)), a = { parser: e }; "tsx" === p.lang && (a.filepath = "dummy.tsx"); let D = l(s(p, c.originalText), a, { stripTrailingHardline: !0 }); return i([r, p.lang, p.meta ? " " + p.meta : "", u, o(D), u, r]) } } switch (p.type) { case "front-matter": return a(p, l); case "importExport": return [l(p.value, { parser: "babel" }, { stripTrailingHardline: !0 }), u]; case "jsx": return l(`<$>${p.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: !0 }) }return null } t.exports = l } }), fu = m({ "src/language-markdown/pragma.js"(e, t) { C(); var r = Nn(), n = ["format", "prettier"]; function u(e) { let t = `@(${n.join("|")})`, r = new RegExp([`\x3c!--\\s*${t}\\s*--\x3e`, `{\\s*\\/\\*\\s*${t}\\s*\\*\\/\\s*}`, `\x3c!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*${t}[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e`].join("|"), "m"), u = e.match(r); return 0 === (null == u ? void 0 : u.index) } t.exports = { startWithPragma: u, hasPragma: e => u(r(e).content.trimStart()), insertPragma: e => { let t = r(e), u = `\x3c!-- @${n[0]} --\x3e`; return t.frontMatter ? `${t.frontMatter.raw}\n\n${u}\n\n${t.content}` : `${u}\n\n${t.content}` } } } }), mu = m({ "src/language-markdown/print-preprocess.js"(e, t) { C(); var r = S(), { getOrderedListItemInfo: n, mapAst: u, splitText: i } = Du(), o = /^.$/su; function a(e, t) { return e = p(e = s(e = f(e = g(e = m(e = l(e = d(e = c(e, t)), t), t), t), t))) } function s(e) { return u(e, (e => "import" !== e.type && "export" !== e.type ? e : Object.assign(Object.assign({}, e), {}, { type: "importExport" }))) } function l(e, t) { return u(e, (e => "inlineCode" !== e.type || "preserve" === t.proseWrap ? e : Object.assign(Object.assign({}, e), {}, { value: e.value.replace(/\s+/g, " ") }))) } function c(e, t) { return u(e, (e => "text" === e.type && "*" !== e.value && "_" !== e.value && o.test(e.value) && e.position.end.offset - e.position.start.offset !== e.value.length ? Object.assign(Object.assign({}, e), {}, { value: t.originalText.slice(e.position.start.offset, e.position.end.offset) }) : e)) } function p(e) { return D(e, ((e, t) => "importExport" === e.type && "importExport" === t.type), ((e, t) => ({ type: "importExport", value: e.value + "\n\n" + t.value, position: { start: e.position.start, end: t.position.end } }))) } function D(e, t, n) { return u(e, (e => { if (!e.children) return e; let u = e.children.reduce(((e, u) => { let i = r(e); return i && t(i, u) ? e.splice(-1, 1, n(i, u)) : e.push(u), e }), []); return Object.assign(Object.assign({}, e), {}, { children: u }) })) } function d(e) { return D(e, ((e, t) => "text" === e.type && "text" === t.type), ((e, t) => ({ type: "text", value: e.value + t.value, position: { start: e.position.start, end: t.position.end } }))) } function f(e, t) { return u(e, ((e, r, n) => { let [u] = n; if ("text" !== e.type) return e; let { value: o } = e; return "paragraph" === u.type && (0 === r && (o = o.trimStart()), r === u.children.length - 1 && (o = o.trimEnd())), { type: "sentence", position: e.position, children: i(o, t) } })) } function m(e, t) { return u(e, ((e, r, n) => { if ("code" === e.type) { let r = /^\n?(?: {4,}|\t)/.test(t.originalText.slice(e.position.start.offset, e.position.end.offset)); if (e.isIndented = r, r) for (let e = 0; e < n.length; e++) { let t = n[e]; if (t.hasIndentedCodeblock) break; "list" === t.type && (t.hasIndentedCodeblock = !0) } } return e })) } function g(e, t) { return u(e, ((e, t, r) => { if ("list" === e.type && e.children.length > 0) { for (let t = 0; t < r.length; t++) { let n = r[t]; if ("list" === n.type && !n.isAligned) return e.isAligned = !1, e } e.isAligned = i(e) } return e })); function r(e) { return 0 === e.children.length ? -1 : e.children[0].position.start.column - 1 } function i(e) { if (!e.ordered) return !0; let [u, i] = e.children; if (n(u, t.originalText).leadingSpaces.length > 1) return !0; let o = r(u); return -1 !== o && (1 === e.children.length ? o % t.tabWidth == 0 : o === r(i) && (o % t.tabWidth == 0 || n(i, t.originalText).leadingSpaces.length > 1)) } } t.exports = a } }), gu = m({ "src/language-markdown/clean.js"(e, t) { C(); var r = lu(), { isFrontMatterNode: n } = pe(), { startWithPragma: u } = fu(), i = new Set(["position", "raw"]); function o(e, t, i) { if (("front-matter" === e.type || "code" === e.type || "yaml" === e.type || "import" === e.type || "export" === e.type || "jsx" === e.type) && delete t.value, "list" === e.type && delete t.isAligned, ("list" === e.type || "listItem" === e.type) && (delete t.spread, delete t.loose), "text" === e.type || ("inlineCode" === e.type && (t.value = e.value.replace(/[\t\n ]+/g, " ")), "wikiLink" === e.type && (t.value = e.value.trim().replace(/[\t\n]+/g, " ")), ("definition" === e.type || "linkReference" === e.type || "imageReference" === e.type) && (t.label = r(e.label)), ("definition" === e.type || "link" === e.type || "image" === e.type) && e.title && (t.title = e.title.replace(/\\(["')])/g, "$1")), i && "root" === i.type && i.children.length > 0 && (i.children[0] === e || n(i.children[0]) && i.children[1] === e) && "html" === e.type && u(e.value))) return null } o.ignoredProperties = i, t.exports = o } }), hu = m({ "src/language-markdown/printer-markdown.js"(e, t) { C(); var r = lu(), { getLast: n, getMinNotPresentContinuousCount: u, getMaxContinuousCount: i, getStringWidth: o, isNonEmptyArray: a } = pe(), { builders: { breakParent: s, join: l, line: c, literalline: p, markAsRoot: D, hardline: d, softline: f, ifBreak: m, fill: g, align: h, indent: y, group: E, hardlineWithoutBreakParent: F }, utils: { normalizeDoc: A, replaceTextEndOfLine: v }, printer: { printDocToString: b } } = V(), x = du(), { insertPragma: S } = fu(), { locStart: B, locEnd: T } = cu(), w = mu(), k = gu(), { getFencedCodeBlockValue: N, hasGitDiffFriendlyOrderedList: j, splitText: O, punctuationPattern: I, INLINE_NODE_TYPES: P, INLINE_NODE_WRAPPER_TYPES: L, isAutolink: _ } = Du(), R = new Set(["importExport"]), M = ["heading", "tableCell", "link", "wikiLink"], $ = new Set(["listItem", "definition", "footnoteDefinition"]); function q(e, t, r) { let o = e.getValue(); if (ie(e)) return O(t.originalText.slice(o.position.start.offset, o.position.end.offset), t).map((r => "word" === r.type ? r.value : "" === r.value ? "" : X(e, r.value, t))); switch (o.type) { case "front-matter": return t.originalText.slice(o.position.start.offset, o.position.end.offset); case "root": return 0 === o.children.length ? "" : [A(Y(e, t, r)), R.has(ee(o).type) ? "" : d]; case "paragraph": return Q(e, t, r, { postprocessor: g }); case "sentence": return Q(e, t, r); case "word": { let t = o.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${I})(_+)`, `(_+)(${I}|$)`].join("|"), "g"), ((e, t, r, n, u) => (r ? `${t}${r}` : `${n}${u}`).replace(/_/g, "\\_"))), r = (e, t, r) => "sentence" === e.type && 0 === r, n = (e, t, r) => _(e.children[r - 1]); return t !== o.value && (e.match(void 0, r, n) || e.match(void 0, r, ((e, t, r) => "emphasis" === e.type && 0 === r), n)) && (t = t.replace(/^(\\?[*_])+/, (e => e.replace(/\\/g, "")))), t } case "whitespace": { let r = e.getParentNode(), n = r.children.indexOf(o), u = r.children[n + 1], i = u && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(u.value) ? "never" : t.proseWrap; return X(e, o.value, { proseWrap: i }) } case "emphasis": { let u; if (_(o.children[0])) u = t.originalText[o.position.start.offset]; else { let t = e.getParentNode(), r = t.children.indexOf(o), i = t.children[r - 1], a = t.children[r + 1]; u = i && "sentence" === i.type && i.children.length > 0 && "word" === n(i.children).type && !n(i.children).hasTrailingPunctuation || a && "sentence" === a.type && a.children.length > 0 && "word" === a.children[0].type && !a.children[0].hasLeadingPunctuation || J(e, "emphasis") ? "*" : "_" } return [u, Q(e, t, r), u] } case "strong": return ["**", Q(e, t, r), "**"]; case "delete": return ["~~", Q(e, t, r), "~~"]; case "inlineCode": { let e = u(o.value, "`"), t = "`".repeat(e || 1), r = e && !/^\s/.test(o.value) ? " " : ""; return [t, r, o.value, r, t] } case "wikiLink": { let e = ""; return e = "preserve" === t.proseWrap ? o.value : o.value.replace(/[\t\n]+/g, " "), ["[[", e, "]]"] } case "link": switch (t.originalText[o.position.start.offset]) { case "<": { let e = "mailto:"; return ["<", o.url.startsWith(e) && t.originalText.slice(o.position.start.offset + 1, o.position.start.offset + 1 + e.length) !== e ? o.url.slice(e.length) : o.url, ">"] } case "[": return ["[", Q(e, t, r), "](", oe(o.url, ")"), ae(o.title, t), ")"]; default: return t.originalText.slice(o.position.start.offset, o.position.end.offset) }case "image": return ["![", o.alt || "", "](", oe(o.url, ")"), ae(o.title, t), ")"]; case "blockquote": return ["> ", h("> ", Q(e, t, r))]; case "heading": return ["#".repeat(o.depth) + " ", Q(e, t, r)]; case "code": { if (o.isIndented) { let e = " ".repeat(4); return h(e, [e, ...v(o.value, d)]) } let e = t.__inJsTemplate ? "~" : "`", r = e.repeat(Math.max(3, i(o.value, e) + 1)); return [r, o.lang || "", o.meta ? " " + o.meta : "", d, ...v(N(o, t.originalText), d), d, r] } case "html": { let t = e.getParentNode(), r = "root" === t.type && n(t.children) === o ? o.value.trimEnd() : o.value, u = /^<!--.*-->$/s.test(r); return v(r, u ? d : D(p)) } case "list": { let n = G(o, e.getParentNode()), u = j(o, t); return Q(e, t, r, { processor: (e, i) => { let a = l(), s = e.getValue(); return 2 === s.children.length && "html" === s.children[1].type && s.children[0].position.start.column !== s.children[1].position.start.column ? [a, U(e, t, r, a)] : [a, h(" ".repeat(a.length), U(e, t, r, a))]; function l() { let e = o.ordered ? (0 === i ? o.start : u ? 1 : o.start + i) + (n % 2 == 0 ? ". " : ") ") : n % 2 == 0 ? "- " : "* "; return o.isAligned || o.hasIndentedCodeblock ? W(e, t) : e } } }) } case "thematicBreak": { let t = H(e, "list"); return -1 === t ? "---" : G(e.getParentNode(t), e.getParentNode(t + 1)) % 2 == 0 ? "***" : "---" } case "linkReference": return ["[", Q(e, t, r), "]", "full" === o.referenceType ? ce(o) : "collapsed" === o.referenceType ? "[]" : ""]; case "imageReference": return "full" === o.referenceType ? ["![", o.alt || "", "]", ce(o)] : ["![", o.alt, "]", "collapsed" === o.referenceType ? "[]" : ""]; case "definition": { let e = "always" === t.proseWrap ? c : " "; return E([ce(o), ":", y([e, oe(o.url), null === o.title ? "" : [e, ae(o.title, t, !1)]])]) } case "footnote": return ["[^", Q(e, t, r), "]"]; case "footnoteReference": return De(o); case "footnoteDefinition": { let n = e.getParentNode().children[e.getName() + 1], u = 1 === o.children.length && "paragraph" === o.children[0].type && ("never" === t.proseWrap || "preserve" === t.proseWrap && o.children[0].position.start.line === o.children[0].position.end.line); return [De(o), ": ", u ? Q(e, t, r) : E([h(" ".repeat(4), Q(e, t, r, { processor: (e, t) => 0 === t ? E([f, r()]) : r() })), n && "footnoteDefinition" === n.type ? f : ""])] } case "table": return K(e, t, r); case "tableCell": return Q(e, t, r); case "break": return /\s/.test(t.originalText[o.position.start.offset]) ? ["  ", D(p)] : ["\\", d]; case "liquidNode": return v(o.value, d); case "importExport": return [o.value, d]; case "esComment": return ["{/* ", o.value, " */}"]; case "jsx": return o.value; case "math": return ["$$", d, o.value ? [...v(o.value, d), d] : "", "$$"]; case "inlineMath": return t.originalText.slice(B(o), T(o)); default: throw new Error(`Unknown markdown type ${JSON.stringify(o.type)}`) } } function U(e, t, r, n) { let u = e.getValue(), i = null === u.checked ? "" : u.checked ? "[x] " : "[ ] "; return [i, Q(e, t, r, { processor: (e, u) => { if (0 === u && "list" !== e.getValue().type) return h(" ".repeat(i.length), r()); let o = " ".repeat(se(t.tabWidth - n.length, 0, 3)); return [o, h(o, r())] } })] } function W(e, t) { let r = n(); return e + " ".repeat(r >= 4 ? 0 : r); function n() { let r = e.length % t.tabWidth; return 0 === r ? 0 : t.tabWidth - r } } function G(e, t) { return z(e, t, (t => t.ordered === e.ordered)) } function z(e, t, r) { let n = -1; for (let u of t.children) if (u.type === e.type && r(u) ? n++ : n = -1, u === e) return n } function H(e, t) { let r, n = Array.isArray(t) ? t : [t], u = -1; for (; r = e.getParentNode(++u);)if (n.includes(r.type)) return u; return -1 } function J(e, t) { let r = H(e, t); return -1 === r ? null : e.getParentNode(r) } function X(e, t, r) { if ("preserve" === r.proseWrap && "\n" === t) return d; let n = "always" === r.proseWrap && !J(e, M); return "" !== t ? n ? c : " " : n ? f : "" } function K(e, t, r) { let n = e.getValue(), u = [], i = e.map((e => e.map(((e, n) => { let i = b(r(), t).formatted, a = o(i); return u[n] = Math.max(u[n] || 3, a), { text: i, width: a } }), "children")), "children"), a = p(!1); if ("never" !== t.proseWrap) return [s, a]; let c = p(!0); return [s, E(m(c, a))]; function p(e) { let t = [d(i[0], e), D(e)]; return i.length > 1 && t.push(l(F, i.slice(1).map((t => d(t, e))))), l(F, t) } function D(e) { return `| ${u.map(((t, r) => { let u = n.align[r], i = "center" === u || "right" === u ? ":" : "-"; return `${"center" === u || "left" === u ? ":" : "-"}${e ? "-" : "-".repeat(t - 2)}${i}` })).join(" | ")} |` } function d(e, t) { return `| ${e.map(((e, r) => { let { text: i, width: o } = e; if (t) return i; let a = u[r] - o, s = n.align[r], l = 0; "right" === s ? l = a : "center" === s && (l = Math.floor(a / 2)); let c = a - l; return `${" ".repeat(l)}${i}${" ".repeat(c)}` })).join(" | ")} |` } } function Y(e, t, r) { let n = [], u = null, { children: i } = e.getValue(); for (let [o, a] of i.entries()) switch (te(a)) { case "start": null === u && (u = { index: o, offset: a.position.end.offset }); break; case "end": null !== u && (n.push({ start: u, end: { index: o, offset: a.position.start.offset } }), u = null) }return Q(e, t, r, { processor: (e, u) => { if (n.length > 0) { let e = n[0]; if (u === e.start.index) return [Z(i[e.start.index]), t.originalText.slice(e.start.offset, e.end.offset), Z(i[e.end.index])]; if (e.start.index < u && u < e.end.index) return !1; if (u === e.end.index) return n.shift(), !1 } return r() } }) } function Q(e, t, r) { let n, u = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, { postprocessor: i } = u, o = u.processor || (() => r()), a = e.getValue(), s = []; return e.each(((e, r) => { let u = e.getValue(), i = o(e, r); if (!1 !== i) { let e = { parts: s, prevNode: n, parentNode: a, options: t }; re(u, e) && (s.push(d), n && R.has(n.type) || (ne(u, e) || ue(u, e)) && s.push(d), ue(u, e) && s.push(d)), s.push(i), n = u } }), "children"), i ? i(s) : s } function Z(e) { return "html" === e.type ? e.value : "paragraph" === e.type && Array.isArray(e.children) && 1 === e.children.length && "esComment" === e.children[0].type ? ["{/* ", e.children[0].value, " */}"] : void 0 } function ee(e) { let t = e; for (; a(t.children);)t = n(t.children); return t } function te(e) { let t; if ("html" === e.type) t = e.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/); else { let r; "esComment" === e.type ? r = e : "paragraph" === e.type && 1 === e.children.length && "esComment" === e.children[0].type && (r = e.children[0]), r && (t = r.value.match(/^prettier-ignore(?:-(start|end))?$/)) } return !!t && (t[1] || "next") } function re(e, t) { let r = 0 === t.parts.length, n = P.includes(e.type), u = "html" === e.type && L.includes(t.parentNode.type); return !r && !n && !u } function ne(e, t) { var r, n, u; let i = (t.prevNode && t.prevNode.type) === e.type && $.has(e.type), o = "listItem" === t.parentNode.type && !t.parentNode.loose, a = "listItem" === (null === (r = t.prevNode) || void 0 === r ? void 0 : r.type) && t.prevNode.loose, s = "next" === te(t.prevNode), l = "html" === e.type && "html" === (null === (n = t.prevNode) || void 0 === n ? void 0 : n.type) && t.prevNode.position.end.line + 1 === e.position.start.line, c = "html" === e.type && "listItem" === t.parentNode.type && "paragraph" === (null === (u = t.prevNode) || void 0 === u ? void 0 : u.type) && t.prevNode.position.end.line + 1 === e.position.start.line; return a || !(i || o || s || l || c) } function ue(e, t) { let r = t.prevNode && "list" === t.prevNode.type, n = "code" === e.type && e.isIndented; return r && n } function ie(e) { let t = J(e, ["linkReference", "imageReference"]); return t && ("linkReference" !== t.type || "full" !== t.referenceType) } function oe(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r = [" ", ...Array.isArray(t) ? t : [t]]; return new RegExp(r.map((e => `\\${e}`)).join("|")).test(e) ? `<${e}>` : e } function ae(e, t) { if (!e) return ""; if (!(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]) return " " + ae(e, t, !1); if ((e = e.replace(/\\(["')])/g, "$1")).includes('"') && e.includes("'") && !e.includes(")")) return `(${e})`; let r = e.split("'").length - 1, n = e.split('"').length - 1, u = r > n ? '"' : n > r || t.singleQuote ? "'" : '"'; return `${u}${e = (e = e.replace(/\\/, "\\\\")).replace(new RegExp(`(${u})`, "g"), "\\$1")}${u}` } function se(e, t, r) { return e < t ? t : e > r ? r : e } function le(e) { let t = Number(e.getName()); return 0 !== t && "next" === te(e.getParentNode().children[t - 1]) } function ce(e) { return `[${r(e.label)}]` } function De(e) { return `[^${e.label}]` } t.exports = { preprocess: w, print: q, embed: x, massageAstNode: k, hasPrettierIgnore: le, insertPragma: S } } }), yu = m({ "src/language-markdown/options.js"(e, t) { C(); var r = yn(); t.exports = { proseWrap: r.proseWrap, singleQuote: r.singleQuote } } }), Eu = m({ "src/language-markdown/parsers.js"() { C() } }), Cu = m({ "node_modules/linguist-languages/data/Markdown.json"(e, t) { t.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: !0, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 } } }), Fu = m({ "src/language-markdown/index.js"(e, t) { C(); var r = Kt(), n = hu(), u = yu(), i = Eu(), o = [r(Cu(), (e => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e.filenames, "README"], extensions: e.extensions.filter((e => ".mdx" !== e)) }))), r(Cu(), (() => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] })))], a = { mdast: n }; t.exports = { languages: o, options: u, printers: a, parsers: i } } }), Au = m({ "src/language-html/clean.js"(e, t) { C(); var { isFrontMatterNode: r } = pe(), n = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]); function u(e, t) { if ("text" === e.type || "comment" === e.type || r(e) || "yaml" === e.type || "toml" === e.type) return null; "attribute" === e.type && delete t.value, "docType" === e.type && delete t.value } u.ignoredProperties = n, t.exports = u } }), vu = m({ "src/language-html/constants.evaluate.js"(e, t) { t.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" } } }), bu = m({ "src/language-html/utils/is-unknown-namespace.js"(e, t) { function r(e) { return "element" === e.type && !e.hasExplicitNamespace && !["html", "svg"].includes(e.namespace) } C(), t.exports = r } }), xu = m({ "src/language-html/utils/index.js"(e, t) { C(); var { inferParserByLanguage: r, isFrontMatterNode: n } = pe(), { builders: { line: u, hardline: i, join: o }, utils: { getDocParts: a, replaceTextEndOfLine: s } } = V(), { CSS_DISPLAY_TAGS: l, CSS_DISPLAY_DEFAULT: c, CSS_WHITE_SPACE_TAGS: p, CSS_WHITE_SPACE_DEFAULT: D } = vu(), d = bu(), f = new Set(["\t", "\n", "\f", "\r", " "]), m = e => e.replace(/^[\t\n\f\r ]+/, ""), g = e => e.replace(/[\t\n\f\r ]+$/, ""), h = e => m(g(e)), y = e => e.replace(/^[\t\f\r ]*\n/g, ""), E = e => y(g(e)), F = e => e.split(/[\t\n\f\r ]+/), A = e => e.match(/^[\t\n\f\r ]*/)[0], v = e => { let [, t, r, n] = e.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s); return { leadingWhitespace: t, trailingWhitespace: n, text: r } }, b = e => /[\t\n\f\r ]/.test(e); function x(e, t) { return !!("ieConditionalComment" === e.type && e.lastChild && !e.lastChild.isSelfClosing && !e.lastChild.endSourceSpan || "ieConditionalComment" === e.type && !e.complete || ne(e) && e.children.some((e => "text" !== e.type && "interpolation" !== e.type)) || ge(e, t) && !w(e) && "interpolation" !== e.type) } function S(e) { return !("attribute" === e.type || !e.parent || !e.prev) && B(e.prev) } function B(e) { return "comment" === e.type && "prettier-ignore" === e.value.trim() } function T(e) { return "text" === e.type || "comment" === e.type } function w(e) { return "element" === e.type && ("script" === e.fullName || "style" === e.fullName || "svg:style" === e.fullName || d(e) && ("script" === e.name || "style" === e.name)) } function k(e) { return e.children && !w(e) } function N(e) { return w(e) || "interpolation" === e.type || j(e) } function j(e) { return ae(e).startsWith("pre") } function O(e, t) { let r = u(); return r && !e.prev && e.parent && e.parent.tagDefinition && e.parent.tagDefinition.ignoreFirstLf ? "interpolation" === e.type : r; function u() { return !(n(e) || ("text" !== e.type && "interpolation" !== e.type || !e.prev || "text" !== e.prev.type && "interpolation" !== e.prev.type) && (!e.parent || "none" === e.parent.cssDisplay || !ne(e.parent) && (!e.prev && ("root" === e.parent.type || ne(e) && e.parent || w(e.parent) || fe(e.parent, t) || !Q(e.parent.cssDisplay)) || e.prev && !te(e.prev.cssDisplay)))) } } function I(e, t) { return !(n(e) || ("text" !== e.type && "interpolation" !== e.type || !e.next || "text" !== e.next.type && "interpolation" !== e.next.type) && (!e.parent || "none" === e.parent.cssDisplay || !ne(e.parent) && (!e.next && ("root" === e.parent.type || ne(e) && e.parent || w(e.parent) || fe(e.parent, t) || !Z(e.parent.cssDisplay)) || e.next && !ee(e.next.cssDisplay)))) } function P(e) { return re(e.cssDisplay) && !w(e) } function L(e) { return n(e) || e.next && e.sourceSpan.end && e.sourceSpan.end.line + 1 < e.next.sourceSpan.start.line } function _(e) { return R(e) || "element" === e.type && e.children.length > 0 && (["body", "script", "style"].includes(e.name) || e.children.some((e => H(e)))) || e.firstChild && e.firstChild === e.lastChild && "text" !== e.firstChild.type && U(e.firstChild) && (!e.lastChild.isTrailingSpaceSensitive || W(e.lastChild)) } function R(e) { return "element" === e.type && e.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e.name) || e.cssDisplay.startsWith("table") && "table-cell" !== e.cssDisplay) } function M(e) { return G(e) || e.prev && $(e.prev) || q(e) } function $(e) { return G(e) || "element" === e.type && "br" === e.fullName || q(e) } function q(e) { return U(e) && W(e) } function U(e) { return e.hasLeadingSpaces && (e.prev ? e.prev.sourceSpan.end.line < e.sourceSpan.start.line : "root" === e.parent.type || e.parent.startSourceSpan.end.line < e.sourceSpan.start.line) } function W(e) { return e.hasTrailingSpaces && (e.next ? e.next.sourceSpan.start.line > e.sourceSpan.end.line : "root" === e.parent.type || e.parent.endSourceSpan && e.parent.endSourceSpan.start.line > e.sourceSpan.end.line) } function G(e) { switch (e.type) { case "ieConditionalComment": case "comment": case "directive": return !0; case "element": return ["script", "select"].includes(e.name) }return !1 } function z(e) { return e.lastChild ? z(e.lastChild) : e } function H(e) { return e.children && e.children.some((e => "text" !== e.type)) } function J(e) { let { type: t, lang: r } = e.attrMap; return "module" === t || "text/javascript" === t || "text/babel" === t || "application/javascript" === t || "jsx" === r ? "babel" : "application/x-typescript" === t || "ts" === r || "tsx" === r ? "typescript" : "text/markdown" === t ? "markdown" : "text/html" === t ? "html" : t && (t.endsWith("json") || t.endsWith("importmap")) || "speculationrules" === t ? "json" : "text/x-handlebars-template" === t ? "glimmer" : void 0 } function X(e, t) { let { lang: n } = e.attrMap; return n && "postcss" !== n && "css" !== n ? "scss" === n ? "scss" : "less" === n ? "less" : "stylus" === n ? r("stylus", t) : void 0 : "css" } function K(e, t) { return "script" !== e.name || e.attrMap.src ? "style" === e.name ? X(e, t) : t && ge(e, t) ? J(e) || !("src" in e.attrMap) && r(e.attrMap.lang, t) : void 0 : e.attrMap.lang || e.attrMap.type ? J(e) : "babel" } function Y(e) { return "block" === e || "list-item" === e || e.startsWith("table") } function Q(e) { return !Y(e) && "inline-block" !== e } function Z(e) { return !Y(e) && "inline-block" !== e } function ee(e) { return !Y(e) } function te(e) { return !Y(e) } function re(e) { return !Y(e) && "inline-block" !== e } function ne(e) { return ae(e).startsWith("pre") } function ue(e, t) { let r = 0; for (let n = e.stack.length - 1; n >= 0; n--) { let u = e.stack[n]; u && "object" == typeof u && !Array.isArray(u) && t(u) && r++ } return r } function ie(e, t) { let r = e; for (; r;) { if (t(r)) return !0; r = r.parent } return !1 } function oe(e, t) { if (e.prev && "comment" === e.prev.type) { let t = e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/); if (t) return t[1] } let r = !1; if ("element" === e.type && "svg" === e.namespace) { if (!ie(e, (e => "svg:foreignObject" === e.fullName))) return "svg" === e.name ? "inline-block" : "block"; r = !0 } switch (t.htmlWhitespaceSensitivity) { case "strict": return "inline"; case "ignore": return "block"; default: return "vue" === t.parser && e.parent && "root" === e.parent.type ? "block" : "element" === e.type && (!e.namespace || r || d(e)) && l[e.name] || c } } function ae(e) { return "element" === e.type && (!e.namespace || d(e)) && p[e.name] || D } function se(e) { let t = Number.POSITIVE_INFINITY; for (let r of e.split("\n")) { if (0 === r.length) continue; if (!f.has(r[0])) return 0; let e = A(r).length; r.length !== e && e < t && (t = e) } return t === Number.POSITIVE_INFINITY ? 0 : t } function le(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : se(e); return 0 === t ? e : e.split("\n").map((e => e.slice(t))).join("\n") } function ce(e, t) { let r = 0; for (let n = 0; n < e.length; n++)e[n] === t && r++; return r } function De(e) { return e.replace(/&apos;/g, "'").replace(/&quot;/g, '"') } var de = new Set(["template", "style", "script"]); function fe(e, t) { return me(e, t) && !de.has(e.fullName) } function me(e, t) { return "vue" === t.parser && "element" === e.type && "root" === e.parent.type && "html" !== e.fullName.toLowerCase() } function ge(e, t) { return me(e, t) && (fe(e, t) || e.attrMap.lang && "html" !== e.attrMap.lang) } function he(e) { let t = e.fullName; return "#" === t.charAt(0) || "slot-scope" === t || "v-slot" === t || t.startsWith("v-slot:") } function ye(e, t) { let r = e.parent; if (!me(r, t)) return !1; let n = r.fullName, u = e.fullName; return "script" === n && "setup" === u || "style" === n && "vars" === u } function Ee(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.value; return e.parent.isWhitespaceSensitive ? e.parent.isIndentationSensitive ? s(t) : s(le(E(t)), i) : a(o(u, F(t))) } function Ce(e, t) { return me(e, t) && "script" === e.name } t.exports = { htmlTrim: h, htmlTrimPreserveIndentation: E, hasHtmlWhitespace: b, getLeadingAndTrailingHtmlWhitespace: v, canHaveInterpolation: k, countChars: ce, countParents: ue, dedentString: le, forceBreakChildren: R, forceBreakContent: _, forceNextEmptyLine: L, getLastDescendant: z, getNodeCssStyleDisplay: oe, getNodeCssStyleWhiteSpace: ae, hasPrettierIgnore: S, inferScriptParser: K, isVueCustomBlock: fe, isVueNonHtmlBlock: ge, isVueScriptTag: Ce, isVueSlotAttribute: he, isVueSfcBindingsAttribute: ye, isVueSfcBlock: me, isDanglingSpaceSensitiveNode: P, isIndentationSensitiveNode: j, isLeadingSpaceSensitiveNode: O, isPreLikeNode: ne, isScriptLikeTag: w, isTextLikeNode: T, isTrailingSpaceSensitiveNode: I, isWhitespaceSensitiveNode: N, isUnknownNamespace: d, preferHardlineAsLeadingSpaces: M, preferHardlineAsTrailingSpaces: $, shouldPreserveContent: x, unescapeQuoteEntities: De, getTextValueParts: Ee } } }), Su = m({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) { function t(t) { return t >= e.$TAB && t <= e.$SPACE || t == e.$NBSP } function r(t) { return e.$0 <= t && t <= e.$9 } function n(t) { return t >= e.$a && t <= e.$z || t >= e.$A && t <= e.$Z } function u(t) { return t >= e.$a && t <= e.$f || t >= e.$A && t <= e.$F || r(t) } function i(t) { return t === e.$LF || t === e.$CR } function o(t) { return e.$0 <= t && t <= e.$7 } C(), Object.defineProperty(e, "__esModule", { value: !0 }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96, e.isWhitespace = t, e.isDigit = r, e.isAsciiLetter = n, e.isAsciiHexDigit = u, e.isNewLine = i, e.isOctalDigit = o } }), Bu = m({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = class { constructor(e, t, r) { this.filePath = e, this.name = t, this.members = r } assertNoMembers() { if (this.members.length) throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`) } }; e.StaticSymbol = t; var r = class { constructor() { this.cache = new Map } get(e, r, n) { let u = `"${e}".${r}${(n = n || []).length ? `.${n.join(".")}` : ""}`, i = this.cache.get(u); return i || (i = new t(e, r, n), this.cache.set(u, i)), i } }; e.StaticSymbolCache = r } }), Tu = m({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = /-+([a-z0-9])/g; function r(e) { return e.replace(t, (function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return t[1].toUpperCase() })) } function n(e, t) { return i(e, ":", t) } function u(e, t) { return i(e, ".", t) } function i(e, t, r) { let n = e.indexOf(t); return -1 == n ? r : [e.slice(0, n).trim(), e.slice(n + 1).trim()] } function o(e, t, r) { return Array.isArray(e) ? t.visitArray(e, r) : y(e) ? t.visitStringMap(e, r) : null == e || "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? t.visitPrimitive(e, r) : t.visitOther(e, r) } function a(e) { return null != e } function s(e) { return void 0 === e ? null : e } e.dashCaseToCamelCase = r, e.splitAtColon = n, e.splitAtPeriod = u, e.visitValue = o, e.isDefined = a, e.noUndefined = s; var l = class { visitArray(e, t) { return e.map((e => o(e, this, t))) } visitStringMap(e, t) { let r = {}; return Object.keys(e).forEach((n => { r[n] = o(e[n], this, t) })), r } visitPrimitive(e, t) { return e } visitOther(e, t) { return e } }; function c(e) { throw new Error(`Internal Error: ${e}`) } function p(e, t) { let r = Error(e); return r[D] = !0, t && (r[d] = t), r } e.ValueTransformer = l, e.SyncAsync = { assertSync: e => { if (v(e)) throw new Error("Illegal state: value cannot be a promise"); return e }, then: (e, t) => v(e) ? e.then(t) : t(e), all: e => e.some(v) ? Promise.all(e) : e }, e.error = c, e.syntaxError = p; var D = "ngSyntaxError", d = "ngParseErrors"; function f(e) { return e[D] } function m(e) { return e[d] || [] } function g(e) { return e.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1") } e.isSyntaxError = f, e.getParseErrors = m, e.escapeRegExp = g; var h = Object.getPrototypeOf({}); function y(e) { return "object" == typeof e && null !== e && Object.getPrototypeOf(e) === h } function E(e) { let t = ""; for (let r = 0; r < e.length; r++) { let n = e.charCodeAt(r); if (n >= 55296 && n <= 56319 && e.length > r + 1) { let t = e.charCodeAt(r + 1); t >= 56320 && t <= 57343 && (r++, n = (n - 55296 << 10) + t - 56320 + 65536) } n <= 127 ? t += String.fromCharCode(n) : n <= 2047 ? t += String.fromCharCode(n >> 6 & 31 | 192, 63 & n | 128) : n <= 65535 ? t += String.fromCharCode(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) : n <= 2097151 && (t += String.fromCharCode(n >> 18 & 7 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)) } return t } function F(e) { if ("string" == typeof e) return e; if (e instanceof Array) return "[" + e.map(F).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; if (!e.toString) return "object"; let t = e.toString(); if (null == t) return "" + t; let r = t.indexOf("\n"); return -1 === r ? t : t.substring(0, r) } function A(e) { return "function" == typeof e && e.hasOwnProperty("__forward_ref__") ? e() : e } function v(e) { return !!e && "function" == typeof e.then } e.utf8Encode = E, e.stringify = F, e.resolveForwardRef = A, e.isPromise = v; var b = class { constructor(e) { this.full = e; let t = e.split("."); this.major = t[0], this.minor = t[1], this.patch = t.slice(2).join(".") } }; e.Version = b; var x = typeof window < "u" && window, S = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, B = typeof globalThis < "u" && globalThis || x || S; e.global = B } }), wu = m({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Bu(), r = Tu(), n = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/; function u(e) { return e.replace(/\W/g, "_") } e.sanitizeIdentifier = u; var i, o, a = 0; function s(e) { if (!e || !e.reference) return null; let n = e.reference; if (n instanceof t.StaticSymbol) return n.name; if (n.__anonymousType) return n.__anonymousType; let i = r.stringify(n); return i.indexOf("(") >= 0 ? (i = "anonymous_" + a++, n.__anonymousType = i) : i = u(i), i } function l(e) { let n = e.reference; return n instanceof t.StaticSymbol ? n.filePath : `./${r.stringify(n)}` } function c(e, t) { return `View_${s({ reference: e })}_${t}` } function p(e) { return `RenderType_${s({ reference: e })}` } function D(e) { return `HostView_${s({ reference: e })}` } function d(e) { return `${s({ reference: e })}NgFactory` } function f(e) { return null != e.value ? u(e.value) : s(e.identifier) } function m(e) { return null != e.identifier ? e.identifier.reference : e.value } e.identifierName = s, e.identifierModuleUrl = l, e.viewClassName = c, e.rendererTypeName = p, e.hostViewClassName = D, e.componentFactoryName = d, (o = i = e.CompileSummaryKind || (e.CompileSummaryKind = {}))[o.Pipe = 0] = "Pipe", o[o.Directive = 1] = "Directive", o[o.NgModule = 2] = "NgModule", o[o.Injectable = 3] = "Injectable", e.tokenName = f, e.tokenReference = m; var g = class { constructor() { let { moduleUrl: e, styles: t, styleUrls: r } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.moduleUrl = e || null, this.styles = b(t), this.styleUrls = b(r) } }; e.CompileStylesheetMetadata = g; var h = class { constructor(e) { let { encapsulation: t, template: r, templateUrl: n, htmlAst: u, styles: i, styleUrls: o, externalStylesheets: a, animations: s, ngContentSelectors: l, interpolation: c, isInline: p, preserveWhitespaces: D } = e; if (this.encapsulation = t, this.template = r, this.templateUrl = n, this.htmlAst = u, this.styles = b(i), this.styleUrls = b(o), this.externalStylesheets = b(a), this.animations = s ? S(s) : [], this.ngContentSelectors = l || [], c && 2 != c.length) throw new Error("'interpolation' should have a start and an end symbol."); this.interpolation = c, this.isInline = p, this.preserveWhitespaces = D } toSummary() { return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations } } }; e.CompileTemplateMetadata = h; var y = class { static create(e) { let { isHost: t, type: u, isComponent: i, selector: o, exportAs: a, changeDetection: s, inputs: l, outputs: c, host: p, providers: D, viewProviders: d, queries: f, guards: m, viewQueries: g, entryComponents: h, template: E, componentViewType: C, rendererType: F, componentFactory: A } = e, v = {}, b = {}, x = {}; null != p && Object.keys(p).forEach((e => { let t = p[e], r = e.match(n); null === r ? x[e] = t : null != r[1] ? b[r[1]] = t : null != r[2] && (v[r[2]] = t) })); let S = {}; null != l && l.forEach((e => { let t = r.splitAtColon(e, [e, e]); S[t[0]] = t[1] })); let B = {}; return null != c && c.forEach((e => { let t = r.splitAtColon(e, [e, e]); B[t[0]] = t[1] })), new y({ isHost: t, type: u, isComponent: !!i, selector: o, exportAs: a, changeDetection: s, inputs: S, outputs: B, hostListeners: v, hostProperties: b, hostAttributes: x, providers: D, viewProviders: d, queries: f, guards: m, viewQueries: g, entryComponents: h, template: E, componentViewType: C, rendererType: F, componentFactory: A }) } constructor(e) { let { isHost: t, type: r, isComponent: n, selector: u, exportAs: i, changeDetection: o, inputs: a, outputs: s, hostListeners: l, hostProperties: c, hostAttributes: p, providers: D, viewProviders: d, queries: f, guards: m, viewQueries: g, entryComponents: h, template: y, componentViewType: E, rendererType: C, componentFactory: F } = e; this.isHost = !!t, this.type = r, this.isComponent = n, this.selector = u, this.exportAs = i, this.changeDetection = o, this.inputs = a, this.outputs = s, this.hostListeners = l, this.hostProperties = c, this.hostAttributes = p, this.providers = b(D), this.viewProviders = b(d), this.queries = b(f), this.guards = m, this.viewQueries = b(g), this.entryComponents = b(h), this.template = y, this.componentViewType = E, this.rendererType = C, this.componentFactory = F } toSummary() { return { summaryKind: i.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory } } }; e.CompileDirectiveMetadata = y; var E = class { constructor(e) { let { type: t, name: r, pure: n } = e; this.type = t, this.name = r, this.pure = !!n } toSummary() { return { summaryKind: i.Pipe, type: this.type, name: this.name, pure: this.pure } } }; e.CompilePipeMetadata = E; var F = class { }; e.CompileShallowModuleMetadata = F; var A = class { constructor(e) { let { type: t, providers: r, declaredDirectives: n, exportedDirectives: u, declaredPipes: i, exportedPipes: o, entryComponents: a, bootstrapComponents: s, importedModules: l, exportedModules: c, schemas: p, transitiveModule: D, id: d } = e; this.type = t || null, this.declaredDirectives = b(n), this.exportedDirectives = b(u), this.declaredPipes = b(i), this.exportedPipes = b(o), this.providers = b(r), this.entryComponents = b(a), this.bootstrapComponents = b(s), this.importedModules = b(l), this.exportedModules = b(c), this.schemas = b(p), this.id = d || null, this.transitiveModule = D || null } toSummary() { let e = this.transitiveModule; return { summaryKind: i.NgModule, type: this.type, entryComponents: e.entryComponents, providers: e.providers, modules: e.modules, exportedDirectives: e.exportedDirectives, exportedPipes: e.exportedPipes } } }; e.CompileNgModuleMetadata = A; var v = class { constructor() { this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = [] } addProvider(e, t) { this.providers.push({ provider: e, module: t }) } addDirective(e) { this.directivesSet.has(e.reference) || (this.directivesSet.add(e.reference), this.directives.push(e)) } addExportedDirective(e) { this.exportedDirectivesSet.has(e.reference) || (this.exportedDirectivesSet.add(e.reference), this.exportedDirectives.push(e)) } addPipe(e) { this.pipesSet.has(e.reference) || (this.pipesSet.add(e.reference), this.pipes.push(e)) } addExportedPipe(e) { this.exportedPipesSet.has(e.reference) || (this.exportedPipesSet.add(e.reference), this.exportedPipes.push(e)) } addModule(e) { this.modulesSet.has(e.reference) || (this.modulesSet.add(e.reference), this.modules.push(e)) } addEntryComponent(e) { this.entryComponentsSet.has(e.componentType) || (this.entryComponentsSet.add(e.componentType), this.entryComponents.push(e)) } }; function b(e) { return e || [] } e.TransitiveCompileNgModuleMetadata = v; var x = class { constructor(e, t) { let { useClass: r, useValue: n, useExisting: u, useFactory: i, deps: o, multi: a } = t; this.token = e, this.useClass = r || null, this.useValue = n, this.useExisting = u, this.useFactory = i || null, this.dependencies = o || null, this.multi = !!a } }; function S(e) { return e.reduce(((e, t) => { let r = Array.isArray(t) ? S(t) : t; return e.concat(r) }), []) } function B(e) { return e.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///") } function T(e, r, n) { let u; return u = n.isInline ? r.type.reference instanceof t.StaticSymbol ? `${r.type.reference.filePath}.${r.type.reference.name}.html` : `${s(e)}/${s(r.type)}.html` : n.templateUrl, r.type.reference instanceof t.StaticSymbol ? u : B(u) } function w(e, t) { let r = e.moduleUrl.split(/\/\\/g); return B(`css/${t}${r[r.length - 1]}.ngstyle.js`) } function k(e) { return B(`${s(e.type)}/module.ngfactory.js`) } function N(e, t) { return B(`${s(e)}/${s(t.type)}.ngfactory.js`) } e.ProviderMeta = x, e.flatten = S, e.templateSourceUrl = T, e.sharedStylesheetJitUrl = w, e.ngModuleJitUrl = k, e.templateJitUrl = N } }), ku = m({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) { C(), Object.defineProperty(e, "__esModule", { value: !0 }); var t = Su(), r = wu(), n = class { constructor(e, t, r, n) { this.file = e, this.offset = t, this.line = r, this.col = n } toString() { return null != this.offset ? `${this.file.url}@${this.line}:${this.col}` : this.file.url } moveBy(e) { let r = this.file.content, u = r.length, i = this.offset, o = this.line, a = this.col; for (; i > 0 && e < 0;)if (i--, e++, r.charCodeAt(i) == t.$LF) { o--; let e = r.substr(0, i - 1).lastIndexOf(String.fromCharCode(t.$LF)); a = e > 0 ? i - e : i } else a--; for (; i < u && e > 0;) { let n = r.charCodeAt(i); i++, e--, n == t.$LF ? (o++, a = 0) : a++ } return new n(this.file, i, o, a) } getContext(e, t) { let r = this.file.content, n = this.offset; if (null != n) { n > r.length - 1 && (n = r.length - 1); let u = n, i = 0, o = 0; for (; i < e && n > 0 && (n--, i++, "\n" != r[n] || ++o != t);); for (i = 0, o = 0; i < e && u < r.length - 1 && (u++, i++, "\n" != r[u] || ++o != t);); return { before: r.substring(n, this.offset), after: r.substring(this.offset, u + 1) } } return null } }; e.ParseLocation = n; var u = class { constructor(e, t) { this.content = e, this.url = t } }; e.ParseSourceFile = u; var i, o, a = class { constructor(e, t) { let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; this.start = e, this.end = t, this.details = r } toString() { return this.start.file.content.substring(this.start.offset, this.end.offset) } }; e.ParseSourceSpan = a, e.EMPTY_PARSE_LOCATION = new n(new u("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new a(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION), (o = i = e.ParseErrorLevel || (e.ParseErrorLevel = {}))[o.WARNING = 0] = "WARNING", o[o.ERROR = 1] = "ERROR"; var s = class { constructor(e, t) { let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.ERROR; this.span = e, this.msg = t, this.level = r } contextualMessage() { let e = this.span.start.getContext(100, 3); return e ? `${this.msg} ("${e.before}[${i[this.level]} ->]${e.after}")` : this.msg } toString() { let e = this.span.details ? `, ${this.span.details}` : ""; return `${this.contextualMessage()}: ${this.span.start}${e}` } }; function l(e, t) { let i = r.identifierModuleUrl(t), o = null != i ? `in ${e} ${r.identifierName(t)} in ${i}` : `in ${e} ${r.identifierName(t)}`, s = new u("", o); return new a(new n(s, -1, -1, -1), new n(s, -1, -1, -1)) } function c(e, t, r) { let i = new u("", `in ${e} ${t} in ${r}`); return new a(new n(i, -1, -1, -1), new n(i, -1, -1, -1)) } e.ParseError = s, e.typeSourceSpan = l, e.r3JitTypeSourceSpan = c } }), Nu = m({ "src/language-html/print-preprocess.js"(e, t) { C(); var { ParseSourceSpan: r } = ku(), { htmlTrim: n, getLeadingAndTrailingHtmlWhitespace: u, hasHtmlWhitespace: i, canHaveInterpolation: o, getNodeCssStyleDisplay: a, isDanglingSpaceSensitiveNode: s, isIndentationSensitiveNode: l, isLeadingSpaceSensitiveNode: c, isTrailingSpaceSensitiveNode: p, isWhitespaceSensitiveNode: D, isVueScriptTag: d } = xu(), f = [g, h, E, A, v, S, b, x, B, F, T]; function m(e, t) { for (let r of f) r(e, t); return e } function g(e) { e.walk((e => { if ("element" === e.type && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && "text" === e.children[0].type && "\n" === e.children[0].value[0]) { let t = e.children[0]; 1 === t.value.length ? e.removeChild(t) : t.value = t.value.slice(1) } })) } function h(e) { let t = e => "element" === e.type && e.prev && "ieConditionalStartComment" === e.prev.type && e.prev.sourceSpan.end.offset === e.startSourceSpan.start.offset && e.firstChild && "ieConditionalEndComment" === e.firstChild.type && e.firstChild.sourceSpan.start.offset === e.startSourceSpan.end.offset; e.walk((e => { if (e.children) for (let n = 0; n < e.children.length; n++) { let u = e.children[n]; if (!t(u)) continue; let i = u.prev, o = u.firstChild; e.removeChild(i), n--; let a = new r(i.sourceSpan.start, o.sourceSpan.end), s = new r(a.start, u.sourceSpan.end); u.condition = i.condition, u.sourceSpan = s, u.startSourceSpan = a, u.removeChild(o) } })) } function y(e, t, n) { e.walk((e => { if (e.children) for (let u = 0; u < e.children.length; u++) { let i = e.children[u]; if ("text" !== i.type && !t(i)) continue; "text" !== i.type && (i.type = "text", i.value = n(i)); let o = i.prev; !o || "text" !== o.type || (o.value += i.value, o.sourceSpan = new r(o.sourceSpan.start, i.sourceSpan.end), e.removeChild(i), u--) } })) } function E(e) { return y(e, (e => "cdata" === e.type), (e => `<![CDATA[${e.value}]]>`)) } function F(e) { let t = e => "element" === e.type && 0 === e.attrs.length && 1 === e.children.length && "text" === e.firstChild.type && !i(e.children[0].value) && !e.firstChild.hasLeadingSpaces && !e.firstChild.hasTrailingSpaces && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces && e.prev && "text" === e.prev.type && e.next && "text" === e.next.type; e.walk((e => { if (e.children) for (let n = 0; n < e.children.length; n++) { let u = e.children[n]; if (!t(u)) continue; let i = u.prev, o = u.next; i.value += `<${u.rawName}>` + u.firstChild.value + `</${u.rawName}>` + o.value, i.sourceSpan = new r(i.sourceSpan.start, o.sourceSpan.end), i.isTrailingSpaceSensitive = o.isTrailingSpaceSensitive, i.hasTrailingSpaces = o.hasTrailingSpaces, e.removeChild(u), n--, e.removeChild(o) } })) } function A(e, t) { if ("html" === t.parser) return; let n = /{{(.+?)}}/s; e.walk((e => { if (o(e)) for (let t of e.children) { if ("text" !== t.type) continue; let u = t.sourceSpan.start, i = null, o = t.value.split(n); for (let n = 0; n < o.length; n++, u = i) { let a = o[n]; n % 2 != 0 ? (i = u.moveBy(a.length + 4), e.insertChildBefore(t, { type: "interpolation", sourceSpan: new r(u, i), children: 0 === a.length ? [] : [{ type: "text", value: a, sourceSpan: new r(u.moveBy(2), i.moveBy(-2)) }] })) : (i = u.moveBy(a.length), a.length > 0 && e.insertChildBefore(t, { type: "text", value: a, sourceSpan: new r(u, i) })) } e.removeChild(t) } })) } function v(e) { e.walk((e => { if (!e.children) return; if (0 === e.children.length || 1 === e.children.length && "text" === e.children[0].type && 0 === n(e.children[0].value).length) return e.hasDanglingSpaces = e.children.length > 0, void (e.children = []); let t = D(e), i = l(e); if (!t) for (let n = 0; n < e.children.length; n++) { let t = e.children[n]; if ("text" !== t.type) continue; let { leadingWhitespace: i, text: o, trailingWhitespace: a } = u(t.value), s = t.prev, l = t.next; o ? (t.value = o, t.sourceSpan = new r(t.sourceSpan.start.moveBy(i.length), t.sourceSpan.end.moveBy(-a.length)), i && (s && (s.hasTrailingSpaces = !0), t.hasLeadingSpaces = !0), a && (t.hasTrailingSpaces = !0, l && (l.hasLeadingSpaces = !0))) : (e.removeChild(t), n--, (i || a) && (s && (s.hasTrailingSpaces = !0), l && (l.hasLeadingSpaces = !0))) } e.isWhitespaceSensitive = t, e.isIndentationSensitive = i })) } function b(e) { e.walk((e => { e.isSelfClosing = !e.children || "element" === e.type && (e.tagDefinition.isVoid || e.startSourceSpan === e.endSourceSpan) })) } function x(e, t) { e.walk((e => { "element" === e.type && (e.hasHtmComponentClosingTag = e.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t.originalText.slice(e.endSourceSpan.start.offset, e.endSourceSpan.end.offset))) })) } function S(e, t) { e.walk((e => { e.cssDisplay = a(e, t) })) } function B(e, t) { e.walk((e => { let { children: r } = e; if (r) { if (0 === r.length) return void (e.isDanglingSpaceSensitive = s(e)); for (let e of r) e.isLeadingSpaceSensitive = c(e, t), e.isTrailingSpaceSensitive = p(e, t); for (let e = 0; e < r.length; e++) { let t = r[e]; t.isLeadingSpaceSensitive = (0 === e || t.prev.isTrailingSpaceSensitive) && t.isLeadingSpaceSensitive, t.isTrailingSpaceSensitive = (e === r.length - 1 || t.next.isLeadingSpaceSensitive) && t.isTrailingSpaceSensitive } } })) } function T(e, t) { if ("vue" === t.parser) { let r = e.children.find((e => d(e, t))); if (!r) return; let { lang: n } = r.attrMap; ("ts" === n || "typescript" === n) && (t.__should_parse_vue_template_with_ts = !0) } } t.exports = m } }), ju = m({ "src/language-html/pragma.js"(e, t) { function r(e) { return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e) } function n(e) { return "\x3c!-- @format --\x3e\n\n" + e.replace(/^\s*\n/, "") } C(), t.exports = { hasPragma: r, insertPragma: n } } }), Ou = m({ "src/language-html/loc.js"(e, t) { function r(e) { return e.sourceSpan.start.offset } function n(e) { return e.sourceSpan.end.offset } C(), t.exports = { locStart: r, locEnd: n } } }), Iu = m({ "src/language-html/print/tag.js"(e, t) { C(); var r = Vt(), { isNonEmptyArray: n } = pe(), { builders: { indent: u, join: i, line: o, softline: a, hardline: s }, utils: { replaceTextEndOfLine: l } } = V(), { locStart: c, locEnd: p } = Ou(), { isTextLikeNode: D, getLastDescendant: d, isPreLikeNode: f, hasPrettierIgnore: m, shouldPreserveContent: g, isVueSfcBlock: h } = xu(); function y(e, t) { return [e.isSelfClosing ? "" : E(e, t), F(e, t)] } function E(e, t) { return e.lastChild && w(e.lastChild) ? "" : [A(e, t), b(e, t)] } function F(e, t) { return (e.next ? B(e.next) : T(e.parent)) ? "" : [x(e, t), v(e, t)] } function A(e, t) { return T(e) ? x(e.lastChild, t) : "" } function v(e, t) { return w(e) ? b(e.parent, t) : k(e) ? R(e.next) : "" } function b(e, t) { if (r(!e.isSelfClosing), S(e, t)) return ""; switch (e.type) { case "ieConditionalComment": return "<!"; case "element": if (e.hasHtmComponentClosingTag) return "<//"; default: return `</${e.rawName}` } } function x(e, t) { if (S(e, t)) return ""; switch (e.type) { case "ieConditionalComment": case "ieConditionalEndComment": return "[endif]--\x3e"; case "ieConditionalStartComment": return "]>\x3c!--\x3e"; case "interpolation": return "}}"; case "element": if (e.isSelfClosing) return "/>"; default: return ">" } } function S(e, t) { return !e.isSelfClosing && !e.endSourceSpan && (m(e) || g(e.parent, t)) } function B(e) { return e.prev && "docType" !== e.prev.type && !D(e.prev) && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces } function T(e) { return e.lastChild && e.lastChild.isTrailingSpaceSensitive && !e.lastChild.hasTrailingSpaces && !D(d(e.lastChild)) && !f(e) } function w(e) { return !e.next && !e.hasTrailingSpaces && e.isTrailingSpaceSensitive && D(d(e)) } function k(e) { return e.next && !D(e.next) && D(e) && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces } function N(e) { let t = e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s); return !!t && (!t[1] || t[1].split(/\s+/)) } function j(e) { return !e.prev && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces } function O(e, t, r) { let D = e.getValue(); if (!n(D.attrs)) return D.isSelfClosing ? " " : ""; let d = D.prev && "comment" === D.prev.type && N(D.prev.value), f = "boolean" == typeof d ? () => d : Array.isArray(d) ? e => d.includes(e.rawName) : () => !1, m = e.map((e => { let n = e.getValue(); return f(n) ? l(t.originalText.slice(c(n), p(n))) : r() }), "attrs"), g = "element" === D.type && "script" === D.fullName && 1 === D.attrs.length && "src" === D.attrs[0].fullName && 0 === D.children.length, y = t.singleAttributePerLine && D.attrs.length > 1 && !h(D, t) ? s : o, E = [u([g ? " " : o, i(y, m)])]; return D.firstChild && j(D.firstChild) || D.isSelfClosing && T(D.parent) || g ? E.push(D.isSelfClosing ? " " : "") : E.push(t.bracketSameLine ? D.isSelfClosing ? " " : "" : D.isSelfClosing ? o : a), E } function I(e) { return e.firstChild && j(e.firstChild) ? "" : M(e) } function P(e, t, r) { let n = e.getValue(); return [L(n, t), O(e, t, r), n.isSelfClosing ? "" : I(n)] } function L(e, t) { return e.prev && k(e.prev) ? "" : [_(e, t), R(e)] } function _(e, t) { return j(e) ? M(e.parent) : B(e) ? x(e.prev, t) : "" } function R(e) { switch (e.type) { case "ieConditionalComment": case "ieConditionalStartComment": return `\x3c!--[if ${e.condition}`; case "ieConditionalEndComment": return "\x3c!--<!"; case "interpolation": return "{{"; case "docType": return "<!DOCTYPE"; case "element": if (e.condition) return `\x3c!--[if ${e.condition}]>\x3c!--\x3e<${e.rawName}`; default: return `<${e.rawName}` } } function M(e) { switch (r(!e.isSelfClosing), e.type) { case "ieConditionalComment": return "]>"; case "element": if (e.condition) return ">\x3c!--<![endif]--\x3e"; default: return ">" } } t.exports = { printClosingTag: y, printClosingTagStart: E, printClosingTagStartMarker: b, printClosingTagEndMarker: x, printClosingTagSuffix: v, printClosingTagEnd: F, needsToBorrowLastChildClosingTagEndMarker: T, needsToBorrowParentClosingTagStartMarker: w, needsToBorrowPrevClosingTagEndMarker: B, printOpeningTag: P, printOpeningTagStart: L, printOpeningTagPrefix: _, printOpeningTagStartMarker: R, printOpeningTagEndMarker: M, needsToBorrowNextOpeningTagStartMarker: k, needsToBorrowParentOpeningTagEndMarker: j } } }), Pu = m({ "node_modules/parse-srcset/src/parse-srcset.js"(e, t) { var r, n; C(), r = e, n = function () { return function (e, t) { var r = t && t.logger || console; function n(e) { return " " === e || "\t" === e || "\n" === e || "\f" === e || "\r" === e } function u(t) { var r, n = t.exec(e.substring(h)); if (n) return r = n[0], h += r.length, r } for (var i, o, a, s, l, c = e.length, p = /^[ \t\n\r\u000c]+/, D = /^[, \t\n\r\u000c]+/, d = /^[^ \t\n\r\u000c]+/, f = /[,]+$/, m = /^\d+$/, g = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, h = 0, y = []; ;) { if (u(D), h >= c) return y; i = u(d), o = [], "," === i.slice(-1) ? (i = i.replace(f, ""), C()) : E() } function E() { for (u(p), a = "", s = "in descriptor"; ;) { if (l = e.charAt(h), "in descriptor" === s) if (n(l)) a && (o.push(a), a = "", s = "after descriptor"); else { if ("," === l) return h += 1, a && o.push(a), void C(); if ("(" === l) a += l, s = "in parens"; else { if ("" === l) return a && o.push(a), void C(); a += l } } else if ("in parens" === s) if (")" === l) a += l, s = "in descriptor"; else { if ("" === l) return o.push(a), void C(); a += l } else if ("after descriptor" === s && !n(l)) { if ("" === l) return void C(); s = "in descriptor", h -= 1 } h += 1 } } function C() { var t, n, u, a, s, l, c, p, D, d = !1, f = {}; for (a = 0; a < o.length; a++)l = (s = o[a])[s.length - 1], c = s.substring(0, s.length - 1), p = parseInt(c, 10), D = parseFloat(c), m.test(c) && "w" === l ? ((t || n) && (d = !0), 0 === p ? d = !0 : t = p) : g.test(c) && "x" === l ? ((t || n || u) && (d = !0), D < 0 ? d = !0 : n = D) : m.test(c) && "h" === l ? ((u || n) && (d = !0), 0 === p ? d = !0 : u = p) : d = !0; d ? r && r.error && r.error("Invalid srcset descriptor found in '" + e + "' at '" + s + "'.") : (f.url = i, t && (f.w = t), n && (f.d = n), u && (f.h = u), y.push(f)) } } }, "object" == typeof t && t.exports ? t.exports = n() : r.parseSrcset = n() } }), Lu = m({ "src/language-html/syntax-attribute.js"(e, t) { C(); var r = Pu(), { builders: { ifBreak: n, join: u, line: i } } = V(); function o(e) { let t = r(e, { logger: { error(e) { throw new Error(e) } } }), o = t.some((e => { let { w: t } = e; return t })), a = t.some((e => { let { h: t } = e; return t })); if (o + a + t.some((e => { let { d: t } = e; return t })) > 1) throw new Error("Mixed descriptor in srcset is not supported"); let s = o ? "w" : a ? "h" : "d", l = o ? "w" : a ? "h" : "x", c = e => Math.max(...e), p = t.map((e => e.url)), D = c(p.map((e => e.length))), d = t.map((e => e[s])).map((e => e ? e.toString() : "")), f = d.map((e => { let t = e.indexOf("."); return -1 === t ? e.length : t })), m = c(f); return u([",", i], p.map(((e, t) => { let r = [e], u = d[t]; if (u) { let i = D - e.length + 1, o = m - f[t], a = " ".repeat(i + o); r.push(n(a, " "), u + l) } return r }))) } function a(e) { return e.trim().split(/\s+/).join(" ") } t.exports = { printImgSrcset: o, printClassNames: a } } }), _u = m({ "src/language-html/syntax-vue.js"(e, t) { C(); var { builders: { group: r } } = V(); function n(e, t) { let { left: n, operator: i, right: o } = u(e); return [r(t(`function _(${n}) {}`, { parser: "babel", __isVueForBindingLeft: !0 })), " ", i, " ", t(o, { parser: "__js_expression" }, { stripTrailingHardline: !0 })] } function u(e) { let t = /(.*?)\s+(in|of)\s+(.*)/s, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/, n = /^\(|\)$/g, u = e.match(t); if (!u) return; let i = {}; if (i.for = u[3].trim(), !i.for) return; let o = u[1].trim().replace(n, ""), a = o.match(r); a ? (i.alias = o.replace(r, ""), i.iterator1 = a[1].trim(), a[2] && (i.iterator2 = a[2].trim())) : i.alias = o; let s = [i.alias, i.iterator1, i.iterator2]; return s.some(((e, t) => !e && (0 === t || s.slice(t + 1).some(Boolean)))) ? void 0 : { left: s.filter(Boolean).join(","), operator: u[2], right: i.for } } function i(e, t) { return t(`function _(${e}) {}`, { parser: "babel", __isVueBindings: !0 }) } function o(e) { let t = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, r = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, n = e.trim(); return t.test(n) || r.test(n) } t.exports = { isVueEventBindingExpression: o, printVueFor: n, printVueBindings: i } } }), Ru = m({ "src/language-html/get-node-content.js"(e, t) { C(); var { needsToBorrowParentClosingTagStartMarker: r, printClosingTagStartMarker: n, needsToBorrowLastChildClosingTagEndMarker: u, printClosingTagEndMarker: i, needsToBorrowParentOpeningTagEndMarker: o, printOpeningTagEndMarker: a } = Iu(); function s(e, t) { let s = e.startSourceSpan.end.offset; e.firstChild && o(e.firstChild) && (s -= a(e).length); let l = e.endSourceSpan.start.offset; return e.lastChild && r(e.lastChild) ? l += n(e, t).length : u(e) && (l -= i(e.lastChild, t).length), t.originalText.slice(s, l) } t.exports = s } }), Mu = m({ "src/language-html/embed.js"(e, t) { C(); var { builders: { breakParent: r, group: n, hardline: u, indent: i, line: o, fill: a, softline: s }, utils: { mapDoc: l, replaceTextEndOfLine: c } } = V(), p = wn(), { printClosingTag: D, printClosingTagSuffix: d, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: m, printOpeningTag: g } = Iu(), { printImgSrcset: h, printClassNames: y } = Lu(), { printVueFor: E, printVueBindings: F, isVueEventBindingExpression: A } = _u(), { isScriptLikeTag: v, isVueNonHtmlBlock: b, inferScriptParser: x, htmlTrimPreserveIndentation: S, dedentString: B, unescapeQuoteEntities: T, isVueSlotAttribute: w, isVueSfcBindingsAttribute: k, getTextValueParts: N } = xu(), j = Ru(); function O(e, t, r) { let u = t => new RegExp(t.join("|")).test(e.fullName), l = () => T(e.value), p = !1, D = (e, t) => { let r = "NGRoot" === e.type ? "NGMicrosyntax" === e.node.type && 1 === e.node.body.length && "NGMicrosyntaxExpression" === e.node.body[0].type ? e.node.body[0].expression : e.node : "JsExpressionRoot" === e.type ? e.node : e; r && ("ObjectExpression" === r.type || "ArrayExpression" === r.type || "__vue_expression" === t.parser && ("TemplateLiteral" === r.type || "StringLiteral" === r.type)) && (p = !0) }, d = e => n(e), f = function (e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; return n([i([s, e]), t ? s : ""]) }, m = e => p ? d(e) : f(e), g = (e, r) => t(e, Object.assign({ __onHtmlBindingRoot: D, __embeddedInHtml: !0 }, r)); if ("srcset" === e.fullName && ("img" === e.parent.fullName || "source" === e.parent.fullName)) return f(h(l())); if ("class" === e.fullName && !r.parentParser) { let e = l(); if (!e.includes("{{")) return y(e) } if ("style" === e.fullName && !r.parentParser) { let e = l(); if (!e.includes("{{")) return f(g(e, { parser: "css", __isHTMLStyleAttribute: !0 })) } if ("vue" === r.parser) { if ("v-for" === e.fullName) return E(l(), g); if (w(e) || k(e, r)) return F(l(), g); let t = ["^:", "^v-bind:"], n = ["^v-"]; if (u(["^@", "^v-on:"])) { let e = l(), t = A(e) ? "__js_expression" : r.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding"; return m(g(e, { parser: t })) } if (u(t)) return m(g(l(), { parser: "__vue_expression" })); if (u(n)) return m(g(l(), { parser: "__js_expression" })) } if ("angular" === r.parser) { let t = (e, t) => g(e, Object.assign(Object.assign({}, t), {}, { trailingComma: "none" })), r = ["^\\*"], s = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], p = ["^i18n(-.+)?$"]; if (u(["^\\(.+\\)$", "^on-"])) return m(t(l(), { parser: "__ng_action" })); if (u(s)) return m(t(l(), { parser: "__ng_binding" })); if (u(p)) { let t = l().trim(); return f(a(N(e, t)), !t.includes("@@")) } if (u(r)) return m(t(l(), { parser: "__ng_directive" })); let D = /{{(.+?)}}/s, d = l(); if (D.test(d)) { let e = []; for (let [r, u] of d.split(D).entries()) if (r % 2 == 0) e.push(c(u)); else try { e.push(n(["{{", i([o, t(u, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0 })]), o, "}}"])) } catch { e.push("{{", c(u), "}}") } return n(e) } } return null } function I(e, t, a, s) { let c = e.getValue(); switch (c.type) { case "element": if (v(c) || "interpolation" === c.type) return; if (!c.isSelfClosing && b(c, s)) { let r = x(c, s); if (!r) return; let i = j(c, s), o = /^\s*$/.test(i), l = ""; return o || (l = a(S(i), { parser: r, __embeddedInHtml: !0 }, { stripTrailingHardline: !0 }), o = "" === l), [m(c, s), n(g(e, s, t)), o ? "" : u, l, o ? "" : u, D(c, s), d(c, s)] } break; case "text": if (v(c.parent)) { let e = x(c.parent, s); if (e) { let t = "markdown" === e ? B(c.value.replace(/^[^\S\n]*\n/, "")) : c.value, n = { parser: e, __embeddedInHtml: !0 }; if ("html" === s.parser && "babel" === e) { let e = "script", { attrMap: t } = c.parent; t && ("module" === t.type || "text/babel" === t.type && "module" === t["data-type"]) && (e = "module"), n.__babelSourceType = e } return [r, m(c, s), a(t, n, { stripTrailingHardline: !0 }), d(c, s)] } } else if ("interpolation" === c.parent.type) { let e = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 }; return "angular" === s.parser ? (e.parser = "__ng_interpolation", e.trailingComma = "none") : "vue" === s.parser ? e.parser = s.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : e.parser = "__js_expression", [i([o, a(c.value, e, { stripTrailingHardline: !0 })]), c.parent.next && f(c.parent.next) ? " " : o] } break; case "attribute": { if (!c.value) break; if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(s.originalText.slice(c.valueSpan.start.offset, c.valueSpan.end.offset))) return [c.rawName, "=", c.value]; if ("lwc" === s.parser && /^{.*}$/s.test(s.originalText.slice(c.valueSpan.start.offset, c.valueSpan.end.offset))) return [c.rawName, "=", c.value]; let e = O(c, ((e, t) => a(e, Object.assign({ __isInHtmlAttribute: !0, __embeddedInHtml: !0 }, t), { stripTrailingHardline: !0 })), s); if (e) return [c.rawName, '="', n(l(e, (e => "string" == typeof e ? e.replace(/"/g, "&quot;") : e))), '"']; break } case "front-matter": return p(c, a) } } t.exports = I } }), $u = m({ "src/language-html/print/children.js"(e, t) { C(); var { builders: { breakParent: r, group: n, ifBreak: u, line: i, softline: o, hardline: a }, utils: { replaceTextEndOfLine: s } } = V(), { locStart: l, locEnd: c } = Ou(), { forceBreakChildren: p, forceNextEmptyLine: D, isTextLikeNode: d, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: m } = xu(), { printOpeningTagPrefix: g, needsToBorrowNextOpeningTagStartMarker: h, printOpeningTagStartMarker: y, needsToBorrowPrevClosingTagEndMarker: E, printClosingTagEndMarker: F, printClosingTagSuffix: A, needsToBorrowParentClosingTagStartMarker: v } = Iu(); function b(e, t, r) { let n = e.getValue(); return f(n) ? [g(n, t), ...s(t.originalText.slice(l(n) + (n.prev && h(n.prev) ? y(n).length : 0), c(n) - (n.next && E(n.next) ? F(n, t).length : 0))), A(n, t)] : r() } function x(e, t) { return d(e) && d(t) ? e.isTrailingSpaceSensitive ? e.hasTrailingSpaces ? m(t) ? a : i : "" : m(t) ? a : o : h(e) && (f(t) || t.firstChild || t.isSelfClosing || "element" === t.type && t.attrs.length > 0) || "element" === e.type && e.isSelfClosing && E(t) ? "" : !t.isLeadingSpaceSensitive || m(t) || E(t) && e.lastChild && v(e.lastChild) && e.lastChild.lastChild && v(e.lastChild.lastChild) ? a : t.hasLeadingSpaces ? i : o } function S(e, t, i) { let s = e.getValue(); if (p(s)) return [r, ...e.map((e => { let r = e.getValue(), n = r.prev ? x(r.prev, r) : ""; return [n ? [n, D(r.prev) ? a : ""] : "", b(e, t, i)] }), "children")]; let l = s.children.map((() => Symbol(""))); return e.map(((e, r) => { let s = e.getValue(); if (d(s)) { if (s.prev && d(s.prev)) { let r = x(s.prev, s); if (r) return D(s.prev) ? [a, a, b(e, t, i)] : [r, b(e, t, i)] } return b(e, t, i) } let c = [], p = [], f = [], m = [], g = s.prev ? x(s.prev, s) : "", h = s.next ? x(s, s.next) : ""; return g && (D(s.prev) ? c.push(a, a) : g === a ? c.push(a) : d(s.prev) ? p.push(g) : p.push(u("", o, { groupId: l[r - 1] }))), h && (D(s) ? d(s.next) && m.push(a, a) : h === a ? d(s.next) && m.push(a) : f.push(h)), [...c, n([...p, n([b(e, t, i), ...f], { id: l[r] })]), ...m] }), "children") } t.exports = { printChildren: S } } }), qu = m({ "src/language-html/print/element.js"(e, t) { C(); var { builders: { breakParent: r, dedentToRoot: n, group: u, ifBreak: i, indentIfBreak: o, indent: a, line: s, softline: l }, utils: { replaceTextEndOfLine: c } } = V(), p = Ru(), { shouldPreserveContent: D, isScriptLikeTag: d, isVueCustomBlock: f, countParents: m, forceBreakContent: g } = xu(), { printOpeningTagPrefix: h, printOpeningTag: y, printClosingTagSuffix: E, printClosingTag: F, needsToBorrowPrevClosingTagEndMarker: A, needsToBorrowLastChildClosingTagEndMarker: v } = Iu(), { printChildren: b } = $u(); function x(e, t, C) { let x = e.getValue(); if (D(x, t)) return [h(x, t), u(y(e, t, C)), ...c(p(x, t)), ...F(x, t), E(x, t)]; let S = 1 === x.children.length && "interpolation" === x.firstChild.type && x.firstChild.isLeadingSpaceSensitive && !x.firstChild.hasLeadingSpaces && x.lastChild.isTrailingSpaceSensitive && !x.lastChild.hasTrailingSpaces, B = Symbol("element-attr-group-id"), T = r => u([u(y(e, t, C), { id: B }), r, F(x, t)]), w = e => S ? o(e, { groupId: B }) : !d(x) && !f(x, t) || "root" !== x.parent.type || "vue" !== t.parser || t.vueIndentScriptAndStyle ? a(e) : e, k = () => S ? i(l, "", { groupId: B }) : x.firstChild.hasLeadingSpaces && x.firstChild.isLeadingSpaceSensitive ? s : "text" === x.firstChild.type && x.isWhitespaceSensitive && x.isIndentationSensitive ? n(l) : l, N = () => (x.next ? A(x.next) : v(x.parent)) ? x.lastChild.hasTrailingSpaces && x.lastChild.isTrailingSpaceSensitive ? " " : "" : S ? i(l, "", { groupId: B }) : x.lastChild.hasTrailingSpaces && x.lastChild.isTrailingSpaceSensitive ? s : ("comment" === x.lastChild.type || "text" === x.lastChild.type && x.isWhitespaceSensitive && x.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t.tabWidth * m(e, (e => e.parent && "root" !== e.parent.type))}}$`).test(x.lastChild.value) ? "" : l; return 0 === x.children.length ? T(x.hasDanglingSpaces && x.isDanglingSpaceSensitive ? s : "") : T([g(x) ? r : "", w([k(), b(e, t, C)]), N()]) } t.exports = { printElement: x } } }), Vu = m({ "src/language-html/printer-html.js"(e, t) { C(); var { builders: { fill: r, group: n, hardline: u, literalline: i }, utils: { cleanDoc: o, getDocParts: a, isConcat: s, replaceTextEndOfLine: l } } = V(), c = Au(), { countChars: p, unescapeQuoteEntities: D, getTextValueParts: d } = xu(), f = Nu(), { insertPragma: m } = ju(), { locStart: g, locEnd: h } = Ou(), y = Mu(), { printClosingTagSuffix: E, printClosingTagEnd: F, printOpeningTagPrefix: A, printOpeningTagStart: v } = Iu(), { printElement: b } = qu(), { printChildren: x } = $u(); function S(e, t, c) { let f = e.getValue(); switch (f.type) { case "front-matter": return l(f.raw); case "root": return t.__onHtmlRoot && t.__onHtmlRoot(f), [n(x(e, t, c)), u]; case "element": case "ieConditionalComment": return b(e, t, c); case "ieConditionalStartComment": case "ieConditionalEndComment": return [v(f), F(f)]; case "interpolation": return [v(f, t), ...e.map(c, "children"), F(f, t)]; case "text": { if ("interpolation" === f.parent.type) { let e = /\n[^\S\n]*$/, t = e.test(f.value), r = t ? f.value.replace(e, "") : f.value; return [...l(r), t ? u : ""] } let e = o([A(f, t), ...d(f), E(f, t)]); return s(e) || "fill" === e.type ? r(a(e)) : e } case "docType": return [n([v(f, t), " ", f.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), F(f, t)]; case "comment": return [A(f, t), ...l(t.originalText.slice(g(f), h(f)), i), E(f, t)]; case "attribute": { if (null === f.value) return f.rawName; let e = D(f.value), t = p(e, "'") < p(e, '"') ? "'" : '"'; return [f.rawName, "=", t, ...l('"' === t ? e.replace(/"/g, "&quot;") : e.replace(/'/g, "&apos;")), t] } default: throw new Error(`Unexpected node type ${f.type}`) } } t.exports = { preprocess: f, print: S, insertPragma: m, massageAstNode: c, embed: y } } }), Uu = m({ "src/language-html/options.js"(e, t) { C(); var r = yn(), n = "HTML"; t.exports = { bracketSameLine: r.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: n, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: r.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: n, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } } } }), Wu = m({ "src/language-html/parsers.js"() { C() } }), Gu = m({ "node_modules/linguist-languages/data/HTML.json"(e, t) { t.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 } } }), zu = m({ "node_modules/linguist-languages/data/Vue.json"(e, t) { t.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 } } }), Hu = m({ "src/language-html/index.js"(e, t) { C(); var r = Kt(), n = Vu(), u = Uu(), i = Wu(), o = [r(Gu(), (() => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] }))), r(Gu(), (e => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e.extensions, ".mjml"] }))), r(Gu(), (() => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] }))), r(zu(), (() => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] })))], a = { html: n }; t.exports = { languages: o, printers: a, options: u, parsers: i } } }), Ju = m({ "src/language-yaml/pragma.js"(e, t) { function r(e) { return /^\s*@(?:prettier|format)\s*$/.test(e) } function n(e) { return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e) } function u(e) { return `# @format\n\n${e}` } C(), t.exports = { isPragma: r, hasPragma: n, insertPragma: u } } }), Xu = m({ "src/language-yaml/loc.js"(e, t) { function r(e) { return e.position.start.offset } function n(e) { return e.position.end.offset } C(), t.exports = { locStart: r, locEnd: n } } }), Ku = m({ "src/language-yaml/embed.js"(e, t) { function r(e, t, r, n) { if ("root" === e.getValue().type && n.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(n.filepath)) return r(n.originalText, Object.assign(Object.assign({}, n), {}, { parser: "json" })) } C(), t.exports = r } }), Yu = m({ "src/language-yaml/utils.js"(e, t) { C(); var { getLast: r, isNonEmptyArray: n } = pe(); function u(e, t) { let r = 0, n = e.stack.length - 1; for (let u = 0; u < n; u++) { let n = e.stack[u]; i(n) && t(n) && r++ } return r } function i(e, t) { return e && "string" == typeof e.type && (!t || t.includes(e.type)) } function o(e, t, r) { return t("children" in e ? Object.assign(Object.assign({}, e), {}, { children: e.children.map((r => o(r, t, e))) }) : e, r) } function a(e, t, r) { Object.defineProperty(e, t, { get: r, enumerable: !1 }) } function s(e, t) { let r = 0, n = t.length; for (let u = e.position.end.offset - 1; u < n; u++) { let e = t[u]; if ("\n" === e && r++, 1 === r && /\S/.test(e)) return !1; if (2 === r) return !0 } return !1 } function l(e) { switch (e.getValue().type) { case "tag": case "anchor": case "comment": return !1 }let t = e.stack.length; for (let r = 1; r < t; r++) { let t = e.stack[r], n = e.stack[r - 1]; if (Array.isArray(n) && "number" == typeof t && t !== n.length - 1) return !1 } return !0 } function c(e) { return n(e.children) ? c(r(e.children)) : e } function p(e) { return "prettier-ignore" === e.value.trim() } function D(e) { let t = e.getValue(); if ("documentBody" === t.type) { let t = e.getParentNode(); return E(t.head) && p(r(t.head.endComments)) } return m(t) && p(r(t.leadingComments)) } function d(e) { return !n(e.children) && !f(e) } function f(e) { return m(e) || g(e) || h(e) || y(e) || E(e) } function m(e) { return n(null == e ? void 0 : e.leadingComments) } function g(e) { return n(null == e ? void 0 : e.middleComments) } function h(e) { return null == e ? void 0 : e.indicatorComment } function y(e) { return null == e ? void 0 : e.trailingComment } function E(e) { return n(null == e ? void 0 : e.endComments) } function F(e) { let t, r = []; for (let n of e.split(/( +)/)) " " !== n ? " " === t ? r.push(n) : r.push((r.pop() || "") + n) : void 0 === t && r.unshift(""), t = n; return " " === t && r.push((r.pop() || "") + " "), "" === r[0] && (r.shift(), r.unshift(" " + (r.shift() || ""))), r } function A(e, t, n) { let u = t.split("\n").map(((e, t, r) => 0 === t && t === r.length - 1 ? e : 0 !== t && t !== r.length - 1 ? e.trim() : 0 === t ? e.trimEnd() : e.trimStart())); return "preserve" === n.proseWrap ? u.map((e => 0 === e.length ? [] : [e])) : u.map((e => 0 === e.length ? [] : F(e))).reduce(((t, n, i) => 0 !== i && u[i - 1].length > 0 && n.length > 0 && ("quoteDouble" !== e || !r(r(t)).endsWith("\\")) ? [...t.slice(0, -1), [...r(t), ...n]] : [...t, n]), []).map((e => "never" === n.proseWrap ? [e.join(" ")] : e)) } function v(e, t) { let n, { parentIndent: u, isLastDescendant: i, options: o } = t, a = e.position.start.line === e.position.end.line ? "" : o.originalText.slice(e.position.start.offset, e.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1]; if (null === e.indent) { let e = a.match(/^(?<leadingSpace> *)[^\n\r ]/m); n = e ? e.groups.leadingSpace.length : Number.POSITIVE_INFINITY } else n = e.indent - 1 + u; let s = a.split("\n").map((e => e.slice(n))); return "preserve" === o.proseWrap || "blockLiteral" === e.type ? l(s.map((e => 0 === e.length ? [] : [e]))) : l(s.map((e => 0 === e.length ? [] : F(e))).reduce(((e, t, n) => 0 !== n && s[n - 1].length > 0 && t.length > 0 && !/^\s/.test(t[0]) && !/^\s|\s$/.test(r(e)) ? [...e.slice(0, -1), [...r(e), ...t]] : [...e, t]), []).map((e => e.reduce(((e, t) => e.length > 0 && /\s$/.test(r(e)) ? [...e.slice(0, -1), r(e) + " " + t] : [...e, t]), []))).map((e => "never" === o.proseWrap ? [e.join(" ")] : e))); function l(t) { if ("keep" === e.chomping) return 0 === r(t).length ? t.slice(0, -1) : t; let n = 0; for (let e = t.length - 1; e >= 0 && 0 === t[e].length; e--)n++; return 0 === n ? t : n >= 2 && !i ? t.slice(0, -(n - 1)) : t.slice(0, -n) } } function b(e) { if (!e) return !0; switch (e.type) { case "plain": case "quoteDouble": case "quoteSingle": case "alias": case "flowMapping": case "flowSequence": return !0; default: return !1 } } t.exports = { getLast: r, getAncestorCount: u, isNode: i, isEmptyNode: d, isInlineNode: b, mapNode: o, defineShortcut: a, isNextLineEmpty: s, isLastDescendantNode: l, getBlockValueLineContents: v, getFlowScalarLineContents: A, getLastDescendantNode: c, hasPrettierIgnore: D, hasLeadingComments: m, hasMiddleComments: g, hasIndicatorComment: h, hasTrailingComment: y, hasEndComments: E } } }), Qu = m({ "src/language-yaml/print-preprocess.js"(e, t) { C(); var { defineShortcut: r, mapNode: n } = Yu(); function u(e) { return n(e, i) } function i(e) { switch (e.type) { case "document": r(e, "head", (() => e.children[0])), r(e, "body", (() => e.children[1])); break; case "documentBody": case "sequenceItem": case "flowSequenceItem": case "mappingKey": case "mappingValue": r(e, "content", (() => e.children[0])); break; case "mappingItem": case "flowMappingItem": r(e, "key", (() => e.children[0])), r(e, "value", (() => e.children[1])) }return e } t.exports = u } }), Zu = m({ "src/language-yaml/print/misc.js"(e, t) { C(); var { builders: { softline: r, align: n } } = V(), { hasEndComments: u, isNextLineEmpty: i, isNode: o } = Yu(), a = new WeakMap; function s(e, t) { let n, u = e.getValue(), o = e.stack[0]; return a.has(o) ? n = a.get(o) : (n = new Set, a.set(o, n)), n.has(u.position.end.line) || (n.add(u.position.end.line), !i(u, t) || l(e.getParentNode())) ? "" : r } function l(e) { return u(e) && !o(e, ["documentHead", "documentBody", "flowMapping", "flowSequence"]) } function c(e, t) { return n(" ".repeat(e), t) } t.exports = { alignWithSpaces: c, shouldPrintEndComments: l, printNextEmptyLine: s } } }), ei = m({ "src/language-yaml/print/flow-mapping-sequence.js"(e, t) { C(); var { builders: { ifBreak: r, line: n, softline: u, hardline: i, join: o } } = V(), { isEmptyNode: a, getLast: s, hasEndComments: l } = Yu(), { printNextEmptyLine: c, alignWithSpaces: p } = Zu(); function D(e, t, c) { let D = e.getValue(), f = "flowMapping" === D.type, m = f ? "{" : "[", g = f ? "}" : "]", h = u; f && D.children.length > 0 && c.bracketSpacing && (h = n); let y = s(D.children), E = y && "flowMappingItem" === y.type && a(y.key) && a(y.value); return [m, p(c.tabWidth, [h, d(e, t, c), "none" === c.trailingComma ? "" : r(","), l(D) ? [i, o(i, e.map(t, "endComments"))] : ""]), E ? "" : h, g] } function d(e, t, r) { let u = e.getValue(); return e.map(((e, i) => [t(), i === u.children.length - 1 ? "" : [",", n, u.children[i].position.start.line !== u.children[i + 1].position.start.line ? c(e, r.originalText) : ""]]), "children") } t.exports = { printFlowMapping: D, printFlowSequence: D } } }), ti = m({ "src/language-yaml/print/mapping-item.js"(e, t) { C(); var { builders: { conditionalGroup: r, group: n, hardline: u, ifBreak: i, join: o, line: a } } = V(), { hasLeadingComments: s, hasMiddleComments: l, hasTrailingComment: c, hasEndComments: p, isNode: D, isEmptyNode: d, isInlineNode: f } = Yu(), { alignWithSpaces: m } = Zu(); function g(e, t, g, C, F) { let { key: A, value: v } = e, b = d(A), x = d(v); if (b && x) return ": "; let S = C("key"), B = y(e) ? " " : ""; if (x) return "flowMappingItem" === e.type && "flowMapping" === t.type ? S : "mappingItem" !== e.type || !h(A.content, F) || c(A.content) || t.tag && "tag:yaml.org,2002:set" === t.tag.value ? ["? ", m(2, S)] : [S, B, ":"]; let T = C("value"); if (b) return [": ", m(2, T)]; if (s(v) || !f(A.content)) return ["? ", m(2, S), u, o("", g.map(C, "value", "leadingComments").map((e => [e, u]))), ": ", m(2, T)]; if (E(A.content) && !s(A.content) && !l(A.content) && !c(A.content) && !p(A) && !s(v.content) && !l(v.content) && !p(v) && h(v.content, F)) return [S, B, ": ", T]; let w = Symbol("mappingKey"), k = n([i("? "), n(m(2, S), { id: w })]), N = [u, ": ", m(2, T)], j = [B, ":"]; s(v.content) || p(v) && v.content && !D(v.content, ["mapping", "sequence"]) || "mapping" === t.type && c(A.content) && f(v.content) || D(v.content, ["mapping", "sequence"]) && null === v.content.tag && null === v.content.anchor ? j.push(u) : v.content && j.push(a), j.push(T); let O = m(F.tabWidth, j); return !h(A.content, F) || s(A.content) || l(A.content) || p(A) ? r([[k, i(N, O, { groupId: w })]]) : r([[S, O]]) } function h(e, t) { if (!e) return !0; switch (e.type) { case "plain": case "quoteSingle": case "quoteDouble": break; case "alias": return !0; default: return !1 }if ("preserve" === t.proseWrap) return e.position.start.line === e.position.end.line; if (/\\$/m.test(t.originalText.slice(e.position.start.offset, e.position.end.offset))) return !1; switch (t.proseWrap) { case "never": return !e.value.includes("\n"); case "always": return !/[\n ]/.test(e.value); default: return !1 } } function y(e) { return e.key.content && "alias" === e.key.content.type } function E(e) { if (!e) return !0; switch (e.type) { case "plain": case "quoteDouble": case "quoteSingle": return e.position.start.line === e.position.end.line; case "alias": return !0; default: return !1 } } t.exports = g } }), ri = m({ "src/language-yaml/print/block.js"(e, t) { C(); var { builders: { dedent: r, dedentToRoot: n, fill: u, hardline: i, join: o, line: a, literalline: s, markAsRoot: l }, utils: { getDocParts: c } } = V(), { getAncestorCount: p, getBlockValueLineContents: D, hasIndicatorComment: d, isLastDescendantNode: f, isNode: m } = Yu(), { alignWithSpaces: g } = Zu(); function h(e, t, h) { let y = e.getValue(), E = p(e, (e => m(e, ["sequence", "mapping"]))), C = f(e), F = ["blockFolded" === y.type ? ">" : "|"]; null !== y.indent && F.push(y.indent.toString()), "clip" !== y.chomping && F.push("keep" === y.chomping ? "+" : "-"), d(y) && F.push(" ", t("indicatorComment")); let A = D(y, { parentIndent: E, isLastDescendant: C, options: h }), v = []; for (let [r, p] of A.entries()) 0 === r && v.push(i), v.push(u(c(o(a, p)))), r !== A.length - 1 ? v.push(0 === p.length ? i : l(s)) : "keep" === y.chomping && C && v.push(n(0 === p.length ? i : s)); return null === y.indent ? F.push(r(g(h.tabWidth, v))) : F.push(n(g(y.indent - 1 + E, v))), F } t.exports = h } }), ni = m({ "src/language-yaml/printer-yaml.js"(e, t) { C(); var { builders: { breakParent: r, fill: n, group: u, hardline: i, join: o, line: a, lineSuffix: s, literalline: l }, utils: { getDocParts: c, replaceTextEndOfLine: p } } = V(), { isPreviousLineEmpty: D } = pe(), { insertPragma: d, isPragma: f } = Ju(), { locStart: m } = Xu(), g = Ku(), { getFlowScalarLineContents: h, getLastDescendantNode: y, hasLeadingComments: E, hasMiddleComments: F, hasTrailingComment: A, hasEndComments: v, hasPrettierIgnore: b, isLastDescendantNode: x, isNode: S, isInlineNode: B } = Yu(), T = Qu(), { alignWithSpaces: w, printNextEmptyLine: k, shouldPrintEndComments: N } = Zu(), { printFlowMapping: j, printFlowSequence: O } = ei(), I = ti(), P = ri(); function L(e, t, n) { let a = e.getValue(), c = []; "mappingValue" !== a.type && E(a) && c.push([o(i, e.map(n, "leadingComments")), i]); let { tag: d, anchor: f } = a; d && c.push(n("tag")), d && f && c.push(" "), f && c.push(n("anchor")); let g = ""; S(a, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !x(e) && (g = k(e, t.originalText)), (d || f) && (S(a, ["sequence", "mapping"]) && !F(a) ? c.push(i) : c.push(" ")), F(a) && c.push([1 === a.middleComments.length ? "" : i, o(i, e.map(n, "middleComments")), i]); let h = e.getParentNode(); return b(e) ? c.push(p(t.originalText.slice(a.position.start.offset, a.position.end.offset).trimEnd(), l)) : c.push(u(_(a, h, e, t, n))), A(a) && !S(a, ["document", "documentHead"]) && c.push(s(["mappingValue" !== a.type || a.content ? " " : "", "mappingKey" === h.type && "mapping" === e.getParentNode(2).type && B(a) ? "" : r, n("trailingComment")])), N(a) && c.push(w("sequenceItem" === a.type ? 2 : 0, [i, o(i, e.map((e => [D(t.originalText, e.getValue(), m) ? i : "", n()]), "endComments"))])), c.push(g), c } function _(e, t, r, n, u) { switch (e.type) { case "root": { let { children: t } = e, n = []; r.each(((e, r) => { let o = t[r], a = t[r + 1]; 0 !== r && n.push(i), n.push(u()), M(o, a) ? (n.push(i, "..."), A(o) && n.push(" ", u("trailingComment"))) : a && !A(a.head) && n.push(i, "---") }), "children"); let o = y(e); return (!S(o, ["blockLiteral", "blockFolded"]) || "keep" !== o.chomping) && n.push(i), n } case "document": { let a = []; return "head" === $(e, t.children[r.getName() + 1], t, n) && ((e.head.children.length > 0 || e.head.endComments.length > 0) && a.push(u("head")), A(e.head) ? a.push(["---", " ", u(["head", "trailingComment"])]) : a.push("---")), R(e) && a.push(u("body")), o(i, a) } case "documentHead": return o(i, [...r.map(u, "children"), ...r.map(u, "endComments")]); case "documentBody": { let { children: t, endComments: n } = e, a = ""; if (t.length > 0 && n.length > 0) { let t = y(e); S(t, ["blockFolded", "blockLiteral"]) ? "keep" !== t.chomping && (a = [i, i]) : a = i } return [o(i, r.map(u, "children")), a, o(i, r.map(u, "endComments"))] } case "directive": return ["%", o(" ", [e.name, ...e.parameters])]; case "comment": return ["#", e.value]; case "alias": return ["*", e.value]; case "tag": return n.originalText.slice(e.position.start.offset, e.position.end.offset); case "anchor": return ["&", e.value]; case "plain": return q(e.type, n.originalText.slice(e.position.start.offset, e.position.end.offset), n); case "quoteDouble": case "quoteSingle": { let t = "'", r = '"', u = n.originalText.slice(e.position.start.offset + 1, e.position.end.offset - 1); if ("quoteSingle" === e.type && u.includes("\\") || "quoteDouble" === e.type && /\\[^"]/.test(u)) { let i = "quoteDouble" === e.type ? r : t; return [i, q(e.type, u, n), i] } if (u.includes(r)) return [t, q(e.type, "quoteDouble" === e.type ? u.replace(/\\"/g, r).replace(/'/g, t.repeat(2)) : u, n), t]; if (u.includes(t)) return [r, q(e.type, "quoteSingle" === e.type ? u.replace(/''/g, t) : u, n), r]; let i = n.singleQuote ? t : r; return [i, q(e.type, u, n), i] } case "blockFolded": case "blockLiteral": return P(r, u, n); case "mapping": case "sequence": return o(i, r.map(u, "children")); case "sequenceItem": return ["- ", w(2, e.content ? u("content") : "")]; case "mappingKey": case "mappingValue": return e.content ? u("content") : ""; case "mappingItem": case "flowMappingItem": return I(e, t, r, u, n); case "flowMapping": return j(r, u, n); case "flowSequence": return O(r, u, n); case "flowSequenceItem": return u("content"); default: throw new Error(`Unexpected node type ${e.type}`) } } function R(e) { return e.body.children.length > 0 || v(e.body) } function M(e, t) { return A(e) || t && (t.head.children.length > 0 || v(t.head)) } function $(e, t, r, n) { return r.children[0] === e && /---(?:\s|$)/.test(n.originalText.slice(m(e), m(e) + 4)) || e.head.children.length > 0 || v(e.head) || A(e.head) ? "head" : !M(e, t) && !!t && "root" } function q(e, t, r) { let u = h(e, t, r); return o(i, u.map((e => n(c(o(a, e)))))) } function U(e, t) { if (S(t)) switch (delete t.position, t.type) { case "comment": if (f(t.value)) return null; break; case "quoteDouble": case "quoteSingle": t.type = "quote" } } t.exports = { preprocess: T, embed: g, print: L, massageAstNode: U, insertPragma: d } } }), ui = m({ "src/language-yaml/options.js"(e, t) { C(); var r = yn(); t.exports = { bracketSpacing: r.bracketSpacing, singleQuote: r.singleQuote, proseWrap: r.proseWrap } } }), ii = m({ "src/language-yaml/parsers.js"() { C() } }), oi = m({ "node_modules/linguist-languages/data/YAML.json"(e, t) { t.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 } } }), ai = m({ "src/language-yaml/index.js"(e, t) { C(); var r = Kt(), n = ni(), u = ui(), i = ii(), o = [r(oi(), (e => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e.filenames.filter((e => "yarn.lock" !== e)), ".prettierrc", ".stylelintrc", ".lintstagedrc"] })))]; t.exports = { languages: o, printers: { yaml: n }, options: u, parsers: i } } }), si = m({ "src/languages.js"(e, t) { C(), t.exports = [Bn(), Hn(), tu(), su(), Fu(), Hu(), ai()] } }); C(); var { version: li } = F(), ci = Jt(), { getSupportInfo: pi } = ue(), Di = Xt(), di = si(), fi = V(); function mi(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1; return function () { for (var r = arguments.length, n = new Array(r), u = 0; u < r; u++)n[u] = arguments[u]; let i = n[t] || {}, o = i.plugins || []; return n[t] = Object.assign(Object.assign({}, i), {}, { plugins: [...di, ...Array.isArray(o) ? o : Object.values(o)] }), e(...n) } } var gi = mi(ci.formatWithCursor); t.exports = { formatWithCursor: gi, format: (e, t) => gi(e, t).formatted, check(e, t) { let { formatted: r } = gi(e, t); return r === e }, doc: fi, getSupportInfo: mi(pi, 0), version: li, util: Di, __debug: { parse: mi(ci.parse), formatAST: mi(ci.formatAST), formatDoc: mi(ci.formatDoc), printToDoc: mi(ci.printToDoc), printDocToString: mi(ci.printDocToString) } }
    })), $e()); const Ve = t(qe.exports); var Ue = { exports: {} }; !function (t) {
        t.exports = function () {
            var t = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), r = t(((t, r) => { var n = function (e) { return e && e.Math == Math && e }; r.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || function () { return this }() || Function("return this")() })), n = t(((e, t) => { t.exports = function (e) { try { return !!e() } catch { return !0 } } })), u = t(((e, t) => { var r = n(); t.exports = !r((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })) })), i = t(((e, t) => { var r = n(); t.exports = !r((function () { var e = function () { }.bind(); return "function" != typeof e || e.hasOwnProperty("prototype") })) })), o = t(((e, t) => { var r = i(), n = Function.prototype.call; t.exports = r ? n.bind(n) : function () { return n.apply(n, arguments) } })), a = t((e => { var t = {}.propertyIsEnumerable, r = Object.getOwnPropertyDescriptor, n = r && !t.call({ 1: 2 }, 1); e.f = n ? function (e) { var t = r(this, e); return !!t && t.enumerable } : t })), s = t(((e, t) => { t.exports = function (e, t) { return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t } } })), l = t(((e, t) => { var r = i(), n = Function.prototype, u = n.call, o = r && n.bind.bind(u, u); t.exports = r ? o : function (e) { return function () { return u.apply(e, arguments) } } })), c = t(((e, t) => { var r = l(), n = r({}.toString), u = r("".slice); t.exports = function (e) { return u(n(e), 8, -1) } })), p = t(((e, t) => { var r = l(), u = n(), i = c(), o = Object, a = r("".split); t.exports = u((function () { return !o("z").propertyIsEnumerable(0) })) ? function (e) { return "String" == i(e) ? a(e, "") : o(e) } : o })), D = t(((e, t) => { t.exports = function (e) { return null == e } })), d = t(((e, t) => { var r = D(), n = TypeError; t.exports = function (e) { if (r(e)) throw n("Can't call method on " + e); return e } })), f = t(((e, t) => { var r = p(), n = d(); t.exports = function (e) { return r(n(e)) } })), m = t(((e, t) => { var r = "object" == typeof document && document.all, n = typeof r > "u" && void 0 !== r; t.exports = { all: r, IS_HTMLDDA: n } })), g = t(((e, t) => { var r = m(), n = r.all; t.exports = r.IS_HTMLDDA ? function (e) { return "function" == typeof e || e === n } : function (e) { return "function" == typeof e } })), h = t(((e, t) => { var r = g(), n = m(), u = n.all; t.exports = n.IS_HTMLDDA ? function (e) { return "object" == typeof e ? null !== e : r(e) || e === u } : function (e) { return "object" == typeof e ? null !== e : r(e) } })), y = t(((e, t) => { var n = r(), u = g(), i = function (e) { return u(e) ? e : void 0 }; t.exports = function (e, t) { return arguments.length < 2 ? i(n[e]) : n[e] && n[e][t] } })), E = t(((e, t) => { var r = l(); t.exports = r({}.isPrototypeOf) })), C = t(((e, t) => { var r = y(); t.exports = r("navigator", "userAgent") || "" })), F = t(((e, t) => { var n, u, i = r(), o = C(), a = i.process, s = i.Deno, l = a && a.versions || s && s.version, c = l && l.v8; c && (u = (n = c.split("."))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])), !u && o && (!(n = o.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = o.match(/Chrome\/(\d+)/)) && (u = +n[1]), t.exports = u })), A = t(((e, t) => { var r = F(), u = n(); t.exports = !!Object.getOwnPropertySymbols && !u((function () { var e = Symbol(); return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && r && r < 41 })) })), v = t(((e, t) => { var r = A(); t.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator })), b = t(((e, t) => { var r = y(), n = g(), u = E(), i = v(), o = Object; t.exports = i ? function (e) { return "symbol" == typeof e } : function (e) { var t = r("Symbol"); return n(t) && u(t.prototype, o(e)) } })), x = t(((e, t) => { var r = String; t.exports = function (e) { try { return r(e) } catch { return "Object" } } })), S = t(((e, t) => { var r = g(), n = x(), u = TypeError; t.exports = function (e) { if (r(e)) return e; throw u(n(e) + " is not a function") } })), B = t(((e, t) => { var r = S(), n = D(); t.exports = function (e, t) { var u = e[t]; return n(u) ? void 0 : r(u) } })), T = t(((e, t) => { var r = o(), n = g(), u = h(), i = TypeError; t.exports = function (e, t) { var o, a; if ("string" === t && n(o = e.toString) && !u(a = r(o, e)) || n(o = e.valueOf) && !u(a = r(o, e)) || "string" !== t && n(o = e.toString) && !u(a = r(o, e))) return a; throw i("Can't convert object to primitive value") } })), w = t(((e, t) => { t.exports = !1 })), k = t(((e, t) => { var n = r(), u = Object.defineProperty; t.exports = function (e, t) { try { u(n, e, { value: t, configurable: !0, writable: !0 }) } catch { n[e] = t } return t } })), N = t(((e, t) => { var n = r(), u = k(), i = "__core-js_shared__", o = n[i] || u(i, {}); t.exports = o })), j = t(((e, t) => { var r = w(), n = N(); (t.exports = function (e, t) { return n[e] || (n[e] = void 0 !== t ? t : {}) })("versions", []).push({ version: "3.26.1", mode: r ? "pure" : "global", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" }) })), O = t(((e, t) => { var r = d(), n = Object; t.exports = function (e) { return n(r(e)) } })), I = t(((e, t) => { var r = l(), n = O(), u = r({}.hasOwnProperty); t.exports = Object.hasOwn || function (e, t) { return u(n(e), t) } })), P = t(((e, t) => { var r = l(), n = 0, u = Math.random(), i = r(1..toString); t.exports = function (e) { return "Symbol(" + (void 0 === e ? "" : e) + ")_" + i(++n + u, 36) } })), L = t(((e, t) => { var n = r(), u = j(), i = I(), o = P(), a = A(), s = v(), l = u("wks"), c = n.Symbol, p = c && c.for, D = s ? c : c && c.withoutSetter || o; t.exports = function (e) { if (!i(l, e) || !a && "string" != typeof l[e]) { var t = "Symbol." + e; a && i(c, e) ? l[e] = c[e] : l[e] = s && p ? p(t) : D(t) } return l[e] } })), _ = t(((e, t) => { var r = o(), n = h(), u = b(), i = B(), a = T(), s = L(), l = TypeError, c = s("toPrimitive"); t.exports = function (e, t) { if (!n(e) || u(e)) return e; var o, s = i(e, c); if (s) { if (void 0 === t && (t = "default"), o = r(s, e, t), !n(o) || u(o)) return o; throw l("Can't convert object to primitive value") } return void 0 === t && (t = "number"), a(e, t) } })), R = t(((e, t) => { var r = _(), n = b(); t.exports = function (e) { var t = r(e, "string"); return n(t) ? t : t + "" } })), M = t(((e, t) => { var n = r(), u = h(), i = n.document, o = u(i) && u(i.createElement); t.exports = function (e) { return o ? i.createElement(e) : {} } })), $ = t(((e, t) => { var r = u(), i = n(), o = M(); t.exports = !r && !i((function () { return 7 != Object.defineProperty(o("div"), "a", { get: function () { return 7 } }).a })) })), q = t((e => { var t = u(), r = o(), n = a(), i = s(), l = f(), c = R(), p = I(), D = $(), d = Object.getOwnPropertyDescriptor; e.f = t ? d : function (e, t) { if (e = l(e), t = c(t), D) try { return d(e, t) } catch { } if (p(e, t)) return i(!r(n.f, e, t), e[t]) } })), V = t(((e, t) => { var r = u(), i = n(); t.exports = r && i((function () { return 42 != Object.defineProperty((function () { }), "prototype", { value: 42, writable: !1 }).prototype })) })), U = t(((e, t) => { var r = h(), n = String, u = TypeError; t.exports = function (e) { if (r(e)) return e; throw u(n(e) + " is not an object") } })), W = t((e => { var t = u(), r = $(), n = V(), i = U(), o = R(), a = TypeError, s = Object.defineProperty, l = Object.getOwnPropertyDescriptor, c = "enumerable", p = "configurable", D = "writable"; e.f = t ? n ? function (e, t, r) { if (i(e), t = o(t), i(r), "function" == typeof e && "prototype" === t && "value" in r && D in r && !r[D]) { var n = l(e, t); n && n[D] && (e[t] = r.value, r = { configurable: p in r ? r[p] : n[p], enumerable: c in r ? r[c] : n[c], writable: !1 }) } return s(e, t, r) } : s : function (e, t, n) { if (i(e), t = o(t), i(n), r) try { return s(e, t, n) } catch { } if ("get" in n || "set" in n) throw a("Accessors not supported"); return "value" in n && (e[t] = n.value), e } })), G = t(((e, t) => { var r = u(), n = W(), i = s(); t.exports = r ? function (e, t, r) { return n.f(e, t, i(1, r)) } : function (e, t, r) { return e[t] = r, e } })), z = t(((e, t) => { var r = u(), n = I(), i = Function.prototype, o = r && Object.getOwnPropertyDescriptor, a = n(i, "name"), s = a && "something" === function () { }.name, l = a && (!r || r && o(i, "name").configurable); t.exports = { EXISTS: a, PROPER: s, CONFIGURABLE: l } })), H = t(((e, t) => { var r = l(), n = g(), u = N(), i = r(Function.toString); n(u.inspectSource) || (u.inspectSource = function (e) { return i(e) }), t.exports = u.inspectSource })), J = t(((e, t) => { var n = r(), u = g(), i = n.WeakMap; t.exports = u(i) && /native code/.test(String(i)) })), X = t(((e, t) => { var r = j(), n = P(), u = r("keys"); t.exports = function (e) { return u[e] || (u[e] = n(e)) } })), K = t(((e, t) => { t.exports = {} })), Y = t(((e, t) => { var n, u, i, o, a, s = J(), l = r(), c = h(), p = G(), D = I(), d = N(), f = X(), m = K(), g = "Object already initialized", y = l.TypeError, E = l.WeakMap, C = function (e) { return i(e) ? u(e) : n(e, {}) }, F = function (e) { return function (t) { var r; if (!c(t) || (r = u(t)).type !== e) throw y("Incompatible receiver, " + e + " required"); return r } }; s || d.state ? ((o = d.state || (d.state = new E)).get = o.get, o.has = o.has, o.set = o.set, n = function (e, t) { if (o.has(e)) throw y(g); return t.facade = e, o.set(e, t), t }, u = function (e) { return o.get(e) || {} }, i = function (e) { return o.has(e) }) : (m[a = f("state")] = !0, n = function (e, t) { if (D(e, a)) throw y(g); return t.facade = e, p(e, a, t), t }, u = function (e) { return D(e, a) ? e[a] : {} }, i = function (e) { return D(e, a) }), t.exports = { set: n, get: u, has: i, enforce: C, getterFor: F } })), Q = t(((e, t) => { var r = n(), i = g(), o = I(), a = u(), s = z().CONFIGURABLE, l = H(), c = Y(), p = c.enforce, D = c.get, d = Object.defineProperty, f = a && !r((function () { return 8 !== d((function () { }), "length", { value: 8 }).length })), m = String(String).split("String"), h = t.exports = function (e, t, r) { "Symbol(" === String(t).slice(0, 7) && (t = "[" + String(t).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), r && r.getter && (t = "get " + t), r && r.setter && (t = "set " + t), (!o(e, "name") || s && e.name !== t) && (a ? d(e, "name", { value: t, configurable: !0 }) : e.name = t), f && r && o(r, "arity") && e.length !== r.arity && d(e, "length", { value: r.arity }); try { r && o(r, "constructor") && r.constructor ? a && d(e, "prototype", { writable: !1 }) : e.prototype && (e.prototype = void 0) } catch { } var n = p(e); return o(n, "source") || (n.source = m.join("string" == typeof t ? t : "")), e }; Function.prototype.toString = h((function () { return i(this) && D(this).source || l(this) }), "toString") })), Z = t(((e, t) => { var r = g(), n = W(), u = Q(), i = k(); t.exports = function (e, t, o, a) { a || (a = {}); var s = a.enumerable, l = void 0 !== a.name ? a.name : t; if (r(o) && u(o, l, a), a.global) s ? e[t] = o : i(t, o); else { try { a.unsafe ? e[t] && (s = !0) : delete e[t] } catch { } s ? e[t] = o : n.f(e, t, { value: o, enumerable: !1, configurable: !a.nonConfigurable, writable: !a.nonWritable }) } return e } })), ee = t(((e, t) => { var r = Math.ceil, n = Math.floor; t.exports = Math.trunc || function (e) { var t = +e; return (t > 0 ? n : r)(t) } })), te = t(((e, t) => { var r = ee(); t.exports = function (e) { var t = +e; return t != t || 0 === t ? 0 : r(t) } })), re = t(((e, t) => { var r = te(), n = Math.max, u = Math.min; t.exports = function (e, t) { var i = r(e); return i < 0 ? n(i + t, 0) : u(i, t) } })), ne = t(((e, t) => { var r = te(), n = Math.min; t.exports = function (e) { return e > 0 ? n(r(e), 9007199254740991) : 0 } })), ue = t(((e, t) => { var r = ne(); t.exports = function (e) { return r(e.length) } })), ie = t(((e, t) => { var r = f(), n = re(), u = ue(), i = function (e) { return function (t, i, o) { var a, s = r(t), l = u(s), c = n(o, l); if (e && i != i) { for (; l > c;)if ((a = s[c++]) != a) return !0 } else for (; l > c; c++)if ((e || c in s) && s[c] === i) return e || c || 0; return !e && -1 } }; t.exports = { includes: i(!0), indexOf: i(!1) } })), oe = t(((e, t) => { var r = l(), n = I(), u = f(), i = ie().indexOf, o = K(), a = r([].push); t.exports = function (e, t) { var r, s = u(e), l = 0, c = []; for (r in s) !n(o, r) && n(s, r) && a(c, r); for (; t.length > l;)n(s, r = t[l++]) && (~i(c, r) || a(c, r)); return c } })), ae = t(((e, t) => { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] })), se = t((e => { var t = oe(), r = ae().concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (e) { return t(e, r) } })), le = t((e => { e.f = Object.getOwnPropertySymbols })), ce = t(((e, t) => { var r = y(), n = l(), u = se(), i = le(), o = U(), a = n([].concat); t.exports = r("Reflect", "ownKeys") || function (e) { var t = u.f(o(e)), r = i.f; return r ? a(t, r(e)) : t } })), pe = t(((e, t) => { var r = I(), n = ce(), u = q(), i = W(); t.exports = function (e, t, o) { for (var a = n(t), s = i.f, l = u.f, c = 0; c < a.length; c++) { var p = a[c]; !r(e, p) && (!o || !r(o, p)) && s(e, p, l(t, p)) } } })), De = t(((e, t) => { var r = n(), u = g(), i = /#|\.prototype\./, o = function (e, t) { var n = s[a(e)]; return n == c || n != l && (u(t) ? r(t) : !!t) }, a = o.normalize = function (e) { return String(e).replace(i, ".").toLowerCase() }, s = o.data = {}, l = o.NATIVE = "N", c = o.POLYFILL = "P"; t.exports = o })), de = t(((e, t) => { var n = r(), u = q().f, i = G(), o = Z(), a = k(), s = pe(), l = De(); t.exports = function (e, t) { var r, c, p, D, d, f = e.target, m = e.global, g = e.stat; if (r = m ? n : g ? n[f] || a(f, {}) : (n[f] || {}).prototype) for (c in t) { if (D = t[c], p = e.dontCallGetSet ? (d = u(r, c)) && d.value : r[c], !l(m ? c : f + (g ? "." : "#") + c, e.forced) && void 0 !== p) { if (typeof D == typeof p) continue; s(D, p) } (e.sham || p && p.sham) && i(D, "sham", !0), o(r, c, D, e) } } })), fe = t(((e, t) => { var r = c(); t.exports = Array.isArray || function (e) { return "Array" == r(e) } })), me = t(((e, t) => { var r = TypeError, n = 9007199254740991; t.exports = function (e) { if (e > n) throw r("Maximum allowed index exceeded"); return e } })), ge = t(((e, t) => { var r = c(), n = l(); t.exports = function (e) { if ("Function" === r(e)) return n(e) } })), he = t(((e, t) => { var r = ge(), n = S(), u = i(), o = r(r.bind); t.exports = function (e, t) { return n(e), void 0 === t ? e : u ? o(e, t) : function () { return e.apply(t, arguments) } } })), ye = t(((e, t) => { var r = fe(), n = ue(), u = me(), i = he(), o = function (e, t, a, s, l, c, p, D) { for (var d, f, m = l, g = 0, h = !!p && i(p, D); g < s;)g in a && (d = h ? h(a[g], g, t) : a[g], c > 0 && r(d) ? (f = n(d), m = o(e, t, d, f, m, c - 1) - 1) : (u(m + 1), e[m] = d), m++), g++; return m }; t.exports = o })), Ee = t(((e, t) => { var r = {}; r[L()("toStringTag")] = "z", t.exports = "[object z]" === String(r) })), Ce = t(((e, t) => { var r = Ee(), n = g(), u = c(), i = L()("toStringTag"), o = Object, a = "Arguments" == u(function () { return arguments }()), s = function (e, t) { try { return e[t] } catch { } }; t.exports = r ? u : function (e) { var t, r, l; return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (r = s(t = o(e), i)) ? r : a ? u(t) : "Object" == (l = u(t)) && n(t.callee) ? "Arguments" : l } })), Fe = t(((e, t) => { var r = l(), u = n(), i = g(), o = Ce(), a = y(), s = H(), c = function () { }, p = [], D = a("Reflect", "construct"), d = /^\s*(?:class|function)\b/, f = r(d.exec), m = !d.exec(c), h = function (e) { if (!i(e)) return !1; try { return D(c, p, e), !0 } catch { return !1 } }, E = function (e) { if (!i(e)) return !1; switch (o(e)) { case "AsyncFunction": case "GeneratorFunction": case "AsyncGeneratorFunction": return !1 }try { return m || !!f(d, s(e)) } catch { return !0 } }; E.sham = !0, t.exports = !D || u((function () { var e; return h(h.call) || !h(Object) || !h((function () { e = !0 })) || e })) ? E : h })), Ae = t(((e, t) => { var r = fe(), n = Fe(), u = h(), i = L()("species"), o = Array; t.exports = function (e) { var t; return r(e) && (t = e.constructor, (n(t) && (t === o || r(t.prototype)) || u(t) && null === (t = t[i])) && (t = void 0)), void 0 === t ? o : t } })), ve = t(((e, t) => { var r = Ae(); t.exports = function (e, t) { return new (r(e))(0 === t ? 0 : t) } })), be = t((() => { var e = de(), t = ye(), r = S(), n = O(), u = ue(), i = ve(); e({ target: "Array", proto: !0 }, { flatMap: function (e) { var o, a = n(this), s = u(a); return r(e), (o = i(a, 0)).length = t(o, a, a, s, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), o } }) })), xe = t(((e, t) => { t.exports = {} })), Se = t(((e, t) => { var r = L(), n = xe(), u = r("iterator"), i = Array.prototype; t.exports = function (e) { return void 0 !== e && (n.Array === e || i[u] === e) } })), Be = t(((e, t) => { var r = Ce(), n = B(), u = D(), i = xe(), o = L()("iterator"); t.exports = function (e) { if (!u(e)) return n(e, o) || n(e, "@@iterator") || i[r(e)] } })), Te = t(((e, t) => { var r = o(), n = S(), u = U(), i = x(), a = Be(), s = TypeError; t.exports = function (e, t) { var o = arguments.length < 2 ? a(e) : t; if (n(o)) return u(r(o, e)); throw s(i(e) + " is not iterable") } })), we = t(((e, t) => { var r = o(), n = U(), u = B(); t.exports = function (e, t, i) { var o, a; n(e); try { if (!(o = u(e, "return"))) { if ("throw" === t) throw i; return i } o = r(o, e) } catch (s) { a = !0, o = s } if ("throw" === t) throw i; if (a) throw o; return n(o), i } })), ke = t(((e, t) => { var r = he(), n = o(), u = U(), i = x(), a = Se(), s = ue(), l = E(), c = Te(), p = Be(), D = we(), d = TypeError, f = function (e, t) { this.stopped = e, this.result = t }, m = f.prototype; t.exports = function (e, t, o) { var g, h, y, E, C, F, A, v = o && o.that, b = !(!o || !o.AS_ENTRIES), x = !(!o || !o.IS_RECORD), S = !(!o || !o.IS_ITERATOR), B = !(!o || !o.INTERRUPTED), T = r(t, v), w = function (e) { return g && D(g, "normal", e), new f(!0, e) }, k = function (e) { return b ? (u(e), B ? T(e[0], e[1], w) : T(e[0], e[1])) : B ? T(e, w) : T(e) }; if (x) g = e.iterator; else if (S) g = e; else { if (!(h = p(e))) throw d(i(e) + " is not iterable"); if (a(h)) { for (y = 0, E = s(e); E > y; y++)if ((C = k(e[y])) && l(m, C)) return C; return new f(!1) } g = c(e, h) } for (F = x ? e.next : g.next; !(A = n(F, g)).done;) { try { C = k(A.value) } catch (N) { D(g, "throw", N) } if ("object" == typeof C && C && l(m, C)) return C } return new f(!1) } })), Ne = t(((e, t) => { var r = R(), n = W(), u = s(); t.exports = function (e, t, i) { var o = r(t); o in e ? n.f(e, o, u(0, i)) : e[o] = i } })), je = t((() => { var e = de(), t = ke(), r = Ne(); e({ target: "Object", stat: !0 }, { fromEntries: function (e) { var n = {}; return t(e, (function (e, t) { r(n, e, t) }), { AS_ENTRIES: !0 }), n } }) })), Oe = t(((e, t) => {
                var r = ["cliName", "cliCategory", "cliDescription"]; function n(e, t) { if (null == e) return {}; var r, n, i = u(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (n = 0; n < o.length; n++)r = o[n], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (i[r] = e[r]) } return i } function u(e, t) { if (null == e) return {}; var r, n, u = {}, i = Object.keys(e); for (n = 0; n < i.length; n++)r = i[n], !(t.indexOf(r) >= 0) && (u[r] = e[r]); return u } be(), je(); var i, o = Object.create, a = Object.defineProperty, s = Object.getOwnPropertyDescriptor, l = Object.getOwnPropertyNames, c = Object.getPrototypeOf, p = Object.prototype.hasOwnProperty, D = (e, t) => function () { return e && (t = (0, e[l(e)[0]])(e = 0)), t }, d = (e, t) => function () { return t || (0, e[l(e)[0]])((t = { exports: {} }).exports, t), t.exports }, f = (e, t) => { for (var r in t) a(e, r, { get: t[r], enumerable: !0 }) }, m = (e, t, r, n) => { if (t && "object" == typeof t || "function" == typeof t) for (let u of l(t)) !p.call(e, u) && u !== r && a(e, u, { get: () => t[u], enumerable: !(n = s(t, u)) || n.enumerable }); return e }, g = (e, t, r) => (r = null != e ? o(c(e)) : {}, m(!t && e && e.__esModule ? r : a(r, "default", { value: e, enumerable: !0 }), e)), h = e => m(a({}, "__esModule", { value: !0 }), e), y = D({ "<define:process>"() { i = { env: {}, argv: [] } } }), E = d({ "node_modules/xtend/immutable.js"(e, t) { y(), t.exports = n; var r = Object.prototype.hasOwnProperty; function n() { for (var e = {}, t = 0; t < arguments.length; t++) { var n = arguments[t]; for (var u in n) r.call(n, u) && (e[u] = n[u]) } return e } } }), C = d({ "node_modules/inherits/inherits_browser.js"(e, t) { y(), "function" == typeof Object.create ? t.exports = function (e, t) { t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })) } : t.exports = function (e, t) { if (t) { e.super_ = t; var r = function () { }; r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e } } } }), F = d({ "node_modules/unherit/index.js"(e, t) { y(); var r = E(), n = C(); function u(e) { var t, u, i; for (u in n(a, e), n(o, a), t = a.prototype) (i = t[u]) && "object" == typeof i && (t[u] = "concat" in i ? i.concat() : r(i)); return a; function o(t) { return e.apply(this, t) } function a() { return this instanceof a ? e.apply(this, arguments) : new o(arguments) } } t.exports = u } }), A = d({ "node_modules/state-toggle/index.js"(e, t) { function r(e, t, r) { return n; function n() { var n = r || this, u = n[e]; return n[e] = !t, i; function i() { n[e] = u } } } y(), t.exports = r } }), v = d({ "node_modules/vfile-location/index.js"(e, t) { function r(e) { for (var t = String(e), r = [], n = /\r?\n|\r/g; n.exec(t);)r.push(n.lastIndex); return r.push(t.length + 1), { toPoint: u, toPosition: u, toOffset: i }; function u(e) { var t = -1; if (e > -1 && e < r[r.length - 1]) for (; ++t < r.length;)if (r[t] > e) return { line: t + 1, column: e - (r[t - 1] || 0) + 1, offset: e }; return {} } function i(e) { var t, n = e && e.line, u = e && e.column; return !isNaN(n) && !isNaN(u) && n - 1 in r && (t = (r[n - 2] || 0) + u - 1 || 0), t > -1 && t < r[r.length - 1] ? t : -1 } } y(), t.exports = r } }), b = d({ "node_modules/remark-parse/lib/unescape.js"(e, t) { y(), t.exports = n; var r = "\\"; function n(e, t) { return n; function n(n) { for (var u, i = 0, o = n.indexOf(r), a = e[t], s = []; -1 !== o;)s.push(n.slice(i, o)), i = o + 1, (!(u = n.charAt(i)) || -1 === a.indexOf(u)) && s.push(r), o = n.indexOf(r, i + 1); return s.push(n.slice(i)), s.join("") } } } }), x = d({ "node_modules/character-entities-legacy/index.json"(e, t) { t.exports = { AElig: "Ã", AMP: "&", Aacute: "Ã", Acirc: "Ã", Agrave: "Ã", Aring: "Ã", Atilde: "Ã", Auml: "Ã", COPY: "Â©", Ccedil: "Ã", ETH: "Ã", Eacute: "Ã", Ecirc: "Ã", Egrave: "Ã", Euml: "Ã", GT: ">", Iacute: "Ã", Icirc: "Ã", Igrave: "Ã", Iuml: "Ã", LT: "<", Ntilde: "Ã", Oacute: "Ã", Ocirc: "Ã", Ograve: "Ã", Oslash: "Ã", Otilde: "Ã", Ouml: "Ã", QUOT: '"', REG: "Â®", THORN: "Ã", Uacute: "Ã", Ucirc: "Ã", Ugrave: "Ã", Uuml: "Ã", Yacute: "Ã", aacute: "Ã¡", acirc: "Ã¢", acute: "Â´", aelig: "Ã¦", agrave: "Ã ", amp: "&", aring: "Ã¥", atilde: "Ã£", auml: "Ã¤", brvbar: "Â¦", ccedil: "Ã§", cedil: "Â¸", cent: "Â¢", copy: "Â©", curren: "Â¤", deg: "Â°", divide: "Ã·", eacute: "Ã©", ecirc: "Ãª", egrave: "Ã¨", eth: "Ã°", euml: "Ã«", frac12: "Â½", frac14: "Â¼", frac34: "Â¾", gt: ">", iacute: "Ã­", icirc: "Ã®", iexcl: "Â¡", igrave: "Ã¬", iquest: "Â¿", iuml: "Ã¯", laquo: "Â«", lt: "<", macr: "Â¯", micro: "Âµ", middot: "Â·", nbsp: "Â ", not: "Â¬", ntilde: "Ã±", oacute: "Ã³", ocirc: "Ã´", ograve: "Ã²", ordf: "Âª", ordm: "Âº", oslash: "Ã¸", otilde: "Ãµ", ouml: "Ã¶", para: "Â¶", plusmn: "Â±", pound: "Â£", quot: '"', raquo: "Â»", reg: "Â®", sect: "Â§", shy: "Â­", sup1: "Â¹", sup2: "Â²", sup3: "Â³", szlig: "Ã", thorn: "Ã¾", times: "Ã", uacute: "Ãº", ucirc: "Ã»", ugrave: "Ã¹", uml: "Â¨", uuml: "Ã¼", yacute: "Ã½", yen: "Â¥", yuml: "Ã¿" } } }), S = d({ "node_modules/character-reference-invalid/index.json"(e, t) { t.exports = { 0: "ï¿½", 128: "â¬", 130: "â", 131: "Æ", 132: "â", 133: "â¦", 134: "â ", 135: "â¡", 136: "Ë", 137: "â°", 138: "Å ", 139: "â¹", 140: "Å", 142: "Å½", 145: "â", 146: "â", 147: "â", 148: "â", 149: "â¢", 150: "â", 151: "â", 152: "Ë", 153: "â¢", 154: "Å¡", 155: "âº", 156: "Å", 158: "Å¾", 159: "Å¸" } } }), B = d({ "node_modules/is-decimal/index.js"(e, t) { function r(e) { var t = "string" == typeof e ? e.charCodeAt(0) : e; return t >= 48 && t <= 57 } y(), t.exports = r } }), T = d({ "node_modules/is-hexadecimal/index.js"(e, t) { function r(e) { var t = "string" == typeof e ? e.charCodeAt(0) : e; return t >= 97 && t <= 102 || t >= 65 && t <= 70 || t >= 48 && t <= 57 } y(), t.exports = r } }), w = d({ "node_modules/is-alphabetical/index.js"(e, t) { function r(e) { var t = "string" == typeof e ? e.charCodeAt(0) : e; return t >= 97 && t <= 122 || t >= 65 && t <= 90 } y(), t.exports = r } }), k = d({ "node_modules/is-alphanumerical/index.js"(e, t) { y(); var r = w(), n = B(); function u(e) { return r(e) || n(e) } t.exports = u } }), N = d({ "node_modules/character-entities/index.json"(e, t) { t.exports = { AEli: "Ã", AElig: "Ã", AM: "&", AMP: "&", Aacut: "Ã", Aacute: "Ã", Abreve: "Ä", Acir: "Ã", Acirc: "Ã", Acy: "Ð", Afr: "ð", Agrav: "Ã", Agrave: "Ã", Alpha: "Î", Amacr: "Ä", And: "â©", Aogon: "Ä", Aopf: "ð¸", ApplyFunction: "â¡", Arin: "Ã", Aring: "Ã", Ascr: "ð", Assign: "â", Atild: "Ã", Atilde: "Ã", Aum: "Ã", Auml: "Ã", Backslash: "â", Barv: "â«§", Barwed: "â", Bcy: "Ð", Because: "âµ", Bernoullis: "â¬", Beta: "Î", Bfr: "ð", Bopf: "ð¹", Breve: "Ë", Bscr: "â¬", Bumpeq: "â", CHcy: "Ð§", COP: "Â©", COPY: "Â©", Cacute: "Ä", Cap: "â", CapitalDifferentialD: "â", Cayleys: "â­", Ccaron: "Ä", Ccedi: "Ã", Ccedil: "Ã", Ccirc: "Ä", Cconint: "â°", Cdot: "Ä", Cedilla: "Â¸", CenterDot: "Â·", Cfr: "â­", Chi: "Î§", CircleDot: "â", CircleMinus: "â", CirclePlus: "â", CircleTimes: "â", ClockwiseContourIntegral: "â²", CloseCurlyDoubleQuote: "â", CloseCurlyQuote: "â", Colon: "â·", Colone: "â©´", Congruent: "â¡", Conint: "â¯", ContourIntegral: "â®", Copf: "â", Coproduct: "â", CounterClockwiseContourIntegral: "â³", Cross: "â¨¯", Cscr: "ð", Cup: "â", CupCap: "â", DD: "â", DDotrahd: "â¤", DJcy: "Ð", DScy: "Ð", DZcy: "Ð", Dagger: "â¡", Darr: "â¡", Dashv: "â«¤", Dcaron: "Ä", Dcy: "Ð", Del: "â", Delta: "Î", Dfr: "ð", DiacriticalAcute: "Â´", DiacriticalDot: "Ë", DiacriticalDoubleAcute: "Ë", DiacriticalGrave: "`", DiacriticalTilde: "Ë", Diamond: "â", DifferentialD: "â", Dopf: "ð»", Dot: "Â¨", DotDot: "â", DotEqual: "â", DoubleContourIntegral: "â¯", DoubleDot: "Â¨", DoubleDownArrow: "â", DoubleLeftArrow: "â", DoubleLeftRightArrow: "â", DoubleLeftTee: "â«¤", DoubleLongLeftArrow: "â¸", DoubleLongLeftRightArrow: "âº", DoubleLongRightArrow: "â¹", DoubleRightArrow: "â", DoubleRightTee: "â¨", DoubleUpArrow: "â", DoubleUpDownArrow: "â", DoubleVerticalBar: "â¥", DownArrow: "â", DownArrowBar: "â¤", DownArrowUpArrow: "âµ", DownBreve: "Ì", DownLeftRightVector: "â¥", DownLeftTeeVector: "â¥", DownLeftVector: "â½", DownLeftVectorBar: "â¥", DownRightTeeVector: "â¥", DownRightVector: "â", DownRightVectorBar: "â¥", DownTee: "â¤", DownTeeArrow: "â§", Downarrow: "â", Dscr: "ð", Dstrok: "Ä", ENG: "Å", ET: "Ã", ETH: "Ã", Eacut: "Ã", Eacute: "Ã", Ecaron: "Ä", Ecir: "Ã", Ecirc: "Ã", Ecy: "Ð­", Edot: "Ä", Efr: "ð", Egrav: "Ã", Egrave: "Ã", Element: "â", Emacr: "Ä", EmptySmallSquare: "â»", EmptyVerySmallSquare: "â«", Eogon: "Ä", Eopf: "ð¼", Epsilon: "Î", Equal: "â©µ", EqualTilde: "â", Equilibrium: "â", Escr: "â°", Esim: "â©³", Eta: "Î", Eum: "Ã", Euml: "Ã", Exists: "â", ExponentialE: "â", Fcy: "Ð¤", Ffr: "ð", FilledSmallSquare: "â¼", FilledVerySmallSquare: "âª", Fopf: "ð½", ForAll: "â", Fouriertrf: "â±", Fscr: "â±", GJcy: "Ð", G: ">", GT: ">", Gamma: "Î", Gammad: "Ï", Gbreve: "Ä", Gcedil: "Ä¢", Gcirc: "Ä", Gcy: "Ð", Gdot: "Ä ", Gfr: "ð", Gg: "â", Gopf: "ð¾", GreaterEqual: "â¥", GreaterEqualLess: "â", GreaterFullEqual: "â§", GreaterGreater: "âª¢", GreaterLess: "â·", GreaterSlantEqual: "â©¾", GreaterTilde: "â³", Gscr: "ð¢", Gt: "â«", HARDcy: "Ðª", Hacek: "Ë", Hat: "^", Hcirc: "Ä¤", Hfr: "â", HilbertSpace: "â", Hopf: "â", HorizontalLine: "â", Hscr: "â", Hstrok: "Ä¦", HumpDownHump: "â", HumpEqual: "â", IEcy: "Ð", IJlig: "Ä²", IOcy: "Ð", Iacut: "Ã", Iacute: "Ã", Icir: "Ã", Icirc: "Ã", Icy: "Ð", Idot: "Ä°", Ifr: "â", Igrav: "Ã", Igrave: "Ã", Im: "â", Imacr: "Äª", ImaginaryI: "â", Implies: "â", Int: "â¬", Integral: "â«", Intersection: "â", InvisibleComma: "â£", InvisibleTimes: "â¢", Iogon: "Ä®", Iopf: "ð", Iota: "Î", Iscr: "â", Itilde: "Ä¨", Iukcy: "Ð", Ium: "Ã", Iuml: "Ã", Jcirc: "Ä´", Jcy: "Ð", Jfr: "ð", Jopf: "ð", Jscr: "ð¥", Jsercy: "Ð", Jukcy: "Ð", KHcy: "Ð¥", KJcy: "Ð", Kappa: "Î", Kcedil: "Ä¶", Kcy: "Ð", Kfr: "ð", Kopf: "ð", Kscr: "ð¦", LJcy: "Ð", L: "<", LT: "<", Lacute: "Ä¹", Lambda: "Î", Lang: "âª", Laplacetrf: "â", Larr: "â", Lcaron: "Ä½", Lcedil: "Ä»", Lcy: "Ð", LeftAngleBracket: "â¨", LeftArrow: "â", LeftArrowBar: "â¤", LeftArrowRightArrow: "â", LeftCeiling: "â", LeftDoubleBracket: "â¦", LeftDownTeeVector: "â¥¡", LeftDownVector: "â", LeftDownVectorBar: "â¥", LeftFloor: "â", LeftRightArrow: "â", LeftRightVector: "â¥", LeftTee: "â£", LeftTeeArrow: "â¤", LeftTeeVector: "â¥", LeftTriangle: "â²", LeftTriangleBar: "â§", LeftTriangleEqual: "â´", LeftUpDownVector: "â¥", LeftUpTeeVector: "â¥ ", LeftUpVector: "â¿", LeftUpVectorBar: "â¥", LeftVector: "â¼", LeftVectorBar: "â¥", Leftarrow: "â", Leftrightarrow: "â", LessEqualGreater: "â", LessFullEqual: "â¦", LessGreater: "â¶", LessLess: "âª¡", LessSlantEqual: "â©½", LessTilde: "â²", Lfr: "ð", Ll: "â", Lleftarrow: "â", Lmidot: "Ä¿", LongLeftArrow: "âµ", LongLeftRightArrow: "â·", LongRightArrow: "â¶", Longleftarrow: "â¸", Longleftrightarrow: "âº", Longrightarrow: "â¹", Lopf: "ð", LowerLeftArrow: "â", LowerRightArrow: "â", Lscr: "â", Lsh: "â°", Lstrok: "Å", Lt: "âª", Map: "â¤", Mcy: "Ð", MediumSpace: "â", Mellintrf: "â³", Mfr: "ð", MinusPlus: "â", Mopf: "ð", Mscr: "â³", Mu: "Î", NJcy: "Ð", Nacute: "Å", Ncaron: "Å", Ncedil: "Å", Ncy: "Ð", NegativeMediumSpace: "â", NegativeThickSpace: "â", NegativeThinSpace: "â", NegativeVeryThinSpace: "â", NestedGreaterGreater: "â«", NestedLessLess: "âª", NewLine: "\n", Nfr: "ð", NoBreak: "â ", NonBreakingSpace: "Â ", Nopf: "â", Not: "â«¬", NotCongruent: "â¢", NotCupCap: "â­", NotDoubleVerticalBar: "â¦", NotElement: "â", NotEqual: "â ", NotEqualTilde: "âÌ¸", NotExists: "â", NotGreater: "â¯", NotGreaterEqual: "â±", NotGreaterFullEqual: "â§Ì¸", NotGreaterGreater: "â«Ì¸", NotGreaterLess: "â¹", NotGreaterSlantEqual: "â©¾Ì¸", NotGreaterTilde: "âµ", NotHumpDownHump: "âÌ¸", NotHumpEqual: "âÌ¸", NotLeftTriangle: "âª", NotLeftTriangleBar: "â§Ì¸", NotLeftTriangleEqual: "â¬", NotLess: "â®", NotLessEqual: "â°", NotLessGreater: "â¸", NotLessLess: "âªÌ¸", NotLessSlantEqual: "â©½Ì¸", NotLessTilde: "â´", NotNestedGreaterGreater: "âª¢Ì¸", NotNestedLessLess: "âª¡Ì¸", NotPrecedes: "â", NotPrecedesEqual: "âª¯Ì¸", NotPrecedesSlantEqual: "â ", NotReverseElement: "â", NotRightTriangle: "â«", NotRightTriangleBar: "â§Ì¸", NotRightTriangleEqual: "â­", NotSquareSubset: "âÌ¸", NotSquareSubsetEqual: "â¢", NotSquareSuperset: "âÌ¸", NotSquareSupersetEqual: "â£", NotSubset: "ââ", NotSubsetEqual: "â", NotSucceeds: "â", NotSucceedsEqual: "âª°Ì¸", NotSucceedsSlantEqual: "â¡", NotSucceedsTilde: "â¿Ì¸", NotSuperset: "ââ", NotSupersetEqual: "â", NotTilde: "â", NotTildeEqual: "â", NotTildeFullEqual: "â", NotTildeTilde: "â", NotVerticalBar: "â¤", Nscr: "ð©", Ntild: "Ã", Ntilde: "Ã", Nu: "Î", OElig: "Å", Oacut: "Ã", Oacute: "Ã", Ocir: "Ã", Ocirc: "Ã", Ocy: "Ð", Odblac: "Å", Ofr: "ð", Ograv: "Ã", Ograve: "Ã", Omacr: "Å", Omega: "Î©", Omicron: "Î", Oopf: "ð", OpenCurlyDoubleQuote: "â", OpenCurlyQuote: "â", Or: "â©", Oscr: "ðª", Oslas: "Ã", Oslash: "Ã", Otild: "Ã", Otilde: "Ã", Otimes: "â¨·", Oum: "Ã", Ouml: "Ã", OverBar: "â¾", OverBrace: "â", OverBracket: "â´", OverParenthesis: "â", PartialD: "â", Pcy: "Ð", Pfr: "ð", Phi: "Î¦", Pi: "Î ", PlusMinus: "Â±", Poincareplane: "â", Popf: "â", Pr: "âª»", Precedes: "âº", PrecedesEqual: "âª¯", PrecedesSlantEqual: "â¼", PrecedesTilde: "â¾", Prime: "â³", Product: "â", Proportion: "â·", Proportional: "â", Pscr: "ð«", Psi: "Î¨", QUO: '"', QUOT: '"', Qfr: "ð", Qopf: "â", Qscr: "ð¬", RBarr: "â¤", RE: "Â®", REG: "Â®", Racute: "Å", Rang: "â«", Rarr: "â ", Rarrtl: "â¤", Rcaron: "Å", Rcedil: "Å", Rcy: "Ð ", Re: "â", ReverseElement: "â", ReverseEquilibrium: "â", ReverseUpEquilibrium: "â¥¯", Rfr: "â", Rho: "Î¡", RightAngleBracket: "â©", RightArrow: "â", RightArrowBar: "â¥", RightArrowLeftArrow: "â", RightCeiling: "â", RightDoubleBracket: "â§", RightDownTeeVector: "â¥", RightDownVector: "â", RightDownVectorBar: "â¥", RightFloor: "â", RightTee: "â¢", RightTeeArrow: "â¦", RightTeeVector: "â¥", RightTriangle: "â³", RightTriangleBar: "â§", RightTriangleEqual: "âµ", RightUpDownVector: "â¥", RightUpTeeVector: "â¥", RightUpVector: "â¾", RightUpVectorBar: "â¥", RightVector: "â", RightVectorBar: "â¥", Rightarrow: "â", Ropf: "â", RoundImplies: "â¥°", Rrightarrow: "â", Rscr: "â", Rsh: "â±", RuleDelayed: "â§´", SHCHcy: "Ð©", SHcy: "Ð¨", SOFTcy: "Ð¬", Sacute: "Å", Sc: "âª¼", Scaron: "Å ", Scedil: "Å", Scirc: "Å", Scy: "Ð¡", Sfr: "ð", ShortDownArrow: "â", ShortLeftArrow: "â", ShortRightArrow: "â", ShortUpArrow: "â", Sigma: "Î£", SmallCircle: "â", Sopf: "ð", Sqrt: "â", Square: "â¡", SquareIntersection: "â", SquareSubset: "â", SquareSubsetEqual: "â", SquareSuperset: "â", SquareSupersetEqual: "â", SquareUnion: "â", Sscr: "ð®", Star: "â", Sub: "â", Subset: "â", SubsetEqual: "â", Succeeds: "â»", SucceedsEqual: "âª°", SucceedsSlantEqual: "â½", SucceedsTilde: "â¿", SuchThat: "â", Sum: "â", Sup: "â", Superset: "â", SupersetEqual: "â", Supset: "â", THOR: "Ã", THORN: "Ã", TRADE: "â¢", TSHcy: "Ð", TScy: "Ð¦", Tab: "\t", Tau: "Î¤", Tcaron: "Å¤", Tcedil: "Å¢", Tcy: "Ð¢", Tfr: "ð", Therefore: "â´", Theta: "Î", ThickSpace: "ââ", ThinSpace: "â", Tilde: "â¼", TildeEqual: "â", TildeFullEqual: "â", TildeTilde: "â", Topf: "ð", TripleDot: "â", Tscr: "ð¯", Tstrok: "Å¦", Uacut: "Ã", Uacute: "Ã", Uarr: "â", Uarrocir: "â¥", Ubrcy: "Ð", Ubreve: "Å¬", Ucir: "Ã", Ucirc: "Ã", Ucy: "Ð£", Udblac: "Å°", Ufr: "ð", Ugrav: "Ã", Ugrave: "Ã", Umacr: "Åª", UnderBar: "_", UnderBrace: "â", UnderBracket: "âµ", UnderParenthesis: "â", Union: "â", UnionPlus: "â", Uogon: "Å²", Uopf: "ð", UpArrow: "â", UpArrowBar: "â¤", UpArrowDownArrow: "â", UpDownArrow: "â", UpEquilibrium: "â¥®", UpTee: "â¥", UpTeeArrow: "â¥", Uparrow: "â", Updownarrow: "â", UpperLeftArrow: "â", UpperRightArrow: "â", Upsi: "Ï", Upsilon: "Î¥", Uring: "Å®", Uscr: "ð°", Utilde: "Å¨", Uum: "Ã", Uuml: "Ã", VDash: "â«", Vbar: "â««", Vcy: "Ð", Vdash: "â©", Vdashl: "â«¦", Vee: "â", Verbar: "â", Vert: "â", VerticalBar: "â£", VerticalLine: "|", VerticalSeparator: "â", VerticalTilde: "â", VeryThinSpace: "â", Vfr: "ð", Vopf: "ð", Vscr: "ð±", Vvdash: "âª", Wcirc: "Å´", Wedge: "â", Wfr: "ð", Wopf: "ð", Wscr: "ð²", Xfr: "ð", Xi: "Î", Xopf: "ð", Xscr: "ð³", YAcy: "Ð¯", YIcy: "Ð", YUcy: "Ð®", Yacut: "Ã", Yacute: "Ã", Ycirc: "Å¶", Ycy: "Ð«", Yfr: "ð", Yopf: "ð", Yscr: "ð´", Yuml: "Å¸", ZHcy: "Ð", Zacute: "Å¹", Zcaron: "Å½", Zcy: "Ð", Zdot: "Å»", ZeroWidthSpace: "â", Zeta: "Î", Zfr: "â¨", Zopf: "â¤", Zscr: "ðµ", aacut: "Ã¡", aacute: "Ã¡", abreve: "Ä", ac: "â¾", acE: "â¾Ì³", acd: "â¿", acir: "Ã¢", acirc: "Ã¢", acut: "Â´", acute: "Â´", acy: "Ð°", aeli: "Ã¦", aelig: "Ã¦", af: "â¡", afr: "ð", agrav: "Ã ", agrave: "Ã ", alefsym: "âµ", aleph: "âµ", alpha: "Î±", amacr: "Ä", amalg: "â¨¿", am: "&", amp: "&", and: "â§", andand: "â©", andd: "â©", andslope: "â©", andv: "â©", ang: "â ", ange: "â¦¤", angle: "â ", angmsd: "â¡", angmsdaa: "â¦¨", angmsdab: "â¦©", angmsdac: "â¦ª", angmsdad: "â¦«", angmsdae: "â¦¬", angmsdaf: "â¦­", angmsdag: "â¦®", angmsdah: "â¦¯", angrt: "â", angrtvb: "â¾", angrtvbd: "â¦", angsph: "â¢", angst: "Ã", angzarr: "â¼", aogon: "Ä", aopf: "ð", ap: "â", apE: "â©°", apacir: "â©¯", ape: "â", apid: "â", apos: "'", approx: "â", approxeq: "â", arin: "Ã¥", aring: "Ã¥", ascr: "ð¶", ast: "*", asymp: "â", asympeq: "â", atild: "Ã£", atilde: "Ã£", aum: "Ã¤", auml: "Ã¤", awconint: "â³", awint: "â¨", bNot: "â«­", backcong: "â", backepsilon: "Ï¶", backprime: "âµ", backsim: "â½", backsimeq: "â", barvee: "â½", barwed: "â", barwedge: "â", bbrk: "âµ", bbrktbrk: "â¶", bcong: "â", bcy: "Ð±", bdquo: "â", becaus: "âµ", because: "âµ", bemptyv: "â¦°", bepsi: "Ï¶", bernou: "â¬", beta: "Î²", beth: "â¶", between: "â¬", bfr: "ð", bigcap: "â", bigcirc: "â¯", bigcup: "â", bigodot: "â¨", bigoplus: "â¨", bigotimes: "â¨", bigsqcup: "â¨", bigstar: "â", bigtriangledown: "â½", bigtriangleup: "â³", biguplus: "â¨", bigvee: "â", bigwedge: "â", bkarow: "â¤", blacklozenge: "â§«", blacksquare: "âª", blacktriangle: "â´", blacktriangledown: "â¾", blacktriangleleft: "â", blacktriangleright: "â¸", blank: "â£", blk12: "â", blk14: "â", blk34: "â", block: "â", bne: "=â¥", bnequiv: "â¡â¥", bnot: "â", bopf: "ð", bot: "â¥", bottom: "â¥", bowtie: "â", boxDL: "â", boxDR: "â", boxDl: "â", boxDr: "â", boxH: "â", boxHD: "â¦", boxHU: "â©", boxHd: "â¤", boxHu: "â§", boxUL: "â", boxUR: "â", boxUl: "â", boxUr: "â", boxV: "â", boxVH: "â¬", boxVL: "â£", boxVR: "â ", boxVh: "â«", boxVl: "â¢", boxVr: "â", boxbox: "â§", boxdL: "â", boxdR: "â", boxdl: "â", boxdr: "â", boxh: "â", boxhD: "â¥", boxhU: "â¨", boxhd: "â¬", boxhu: "â´", boxminus: "â", boxplus: "â", boxtimes: "â ", boxuL: "â", boxuR: "â", boxul: "â", boxur: "â", boxv: "â", boxvH: "âª", boxvL: "â¡", boxvR: "â", boxvh: "â¼", boxvl: "â¤", boxvr: "â", bprime: "âµ", breve: "Ë", brvba: "Â¦", brvbar: "Â¦", bscr: "ð·", bsemi: "â", bsim: "â½", bsime: "â", bsol: "\\", bsolb: "â§", bsolhsub: "â", bull: "â¢", bullet: "â¢", bump: "â", bumpE: "âª®", bumpe: "â", bumpeq: "â", cacute: "Ä", cap: "â©", capand: "â©", capbrcup: "â©", capcap: "â©", capcup: "â©", capdot: "â©", caps: "â©ï¸", caret: "â", caron: "Ë", ccaps: "â©", ccaron: "Ä", ccedi: "Ã§", ccedil: "Ã§", ccirc: "Ä", ccups: "â©", ccupssm: "â©", cdot: "Ä", cedi: "Â¸", cedil: "Â¸", cemptyv: "â¦²", cen: "Â¢", cent: "Â¢", centerdot: "Â·", cfr: "ð ", chcy: "Ñ", check: "â", checkmark: "â", chi: "Ï", cir: "â", cirE: "â§", circ: "Ë", circeq: "â", circlearrowleft: "âº", circlearrowright: "â»", circledR: "Â®", circledS: "â", circledast: "â", circledcirc: "â", circleddash: "â", cire: "â", cirfnint: "â¨", cirmid: "â«¯", cirscir: "â§", clubs: "â£", clubsuit: "â£", colon: ":", colone: "â", coloneq: "â", comma: ",", commat: "@", comp: "â", compfn: "â", complement: "â", complexes: "â", cong: "â", congdot: "â©­", conint: "â®", copf: "ð", coprod: "â", cop: "Â©", copy: "Â©", copysr: "â", crarr: "âµ", cross: "â", cscr: "ð¸", csub: "â«", csube: "â«", csup: "â«", csupe: "â«", ctdot: "â¯", cudarrl: "â¤¸", cudarrr: "â¤µ", cuepr: "â", cuesc: "â", cularr: "â¶", cularrp: "â¤½", cup: "âª", cupbrcap: "â©", cupcap: "â©", cupcup: "â©", cupdot: "â", cupor: "â©", cups: "âªï¸", curarr: "â·", curarrm: "â¤¼", curlyeqprec: "â", curlyeqsucc: "â", curlyvee: "â", curlywedge: "â", curre: "Â¤", curren: "Â¤", curvearrowleft: "â¶", curvearrowright: "â·", cuvee: "â", cuwed: "â", cwconint: "â²", cwint: "â±", cylcty: "â­", dArr: "â", dHar: "â¥¥", dagger: "â ", daleth: "â¸", darr: "â", dash: "â", dashv: "â£", dbkarow: "â¤", dblac: "Ë", dcaron: "Ä", dcy: "Ð´", dd: "â", ddagger: "â¡", ddarr: "â", ddotseq: "â©·", de: "Â°", deg: "Â°", delta: "Î´", demptyv: "â¦±", dfisht: "â¥¿", dfr: "ð¡", dharl: "â", dharr: "â", diam: "â", diamond: "â", diamondsuit: "â¦", diams: "â¦", die: "Â¨", digamma: "Ï", disin: "â²", div: "Ã·", divid: "Ã·", divide: "Ã·", divideontimes: "â", divonx: "â", djcy: "Ñ", dlcorn: "â", dlcrop: "â", dollar: "$", dopf: "ð", dot: "Ë", doteq: "â", doteqdot: "â", dotminus: "â¸", dotplus: "â", dotsquare: "â¡", doublebarwedge: "â", downarrow: "â", downdownarrows: "â", downharpoonleft: "â", downharpoonright: "â", drbkarow: "â¤", drcorn: "â", drcrop: "â", dscr: "ð¹", dscy: "Ñ", dsol: "â§¶", dstrok: "Ä", dtdot: "â±", dtri: "â¿", dtrif: "â¾", duarr: "âµ", duhar: "â¥¯", dwangle: "â¦¦", dzcy: "Ñ", dzigrarr: "â¿", eDDot: "â©·", eDot: "â", eacut: "Ã©", eacute: "Ã©", easter: "â©®", ecaron: "Ä", ecir: "Ãª", ecirc: "Ãª", ecolon: "â", ecy: "Ñ", edot: "Ä", ee: "â", efDot: "â", efr: "ð¢", eg: "âª", egrav: "Ã¨", egrave: "Ã¨", egs: "âª", egsdot: "âª", el: "âª", elinters: "â§", ell: "â", els: "âª", elsdot: "âª", emacr: "Ä", empty: "â", emptyset: "â", emptyv: "â", emsp13: "â", emsp14: "â", emsp: "â", eng: "Å", ensp: "â", eogon: "Ä", eopf: "ð", epar: "â", eparsl: "â§£", eplus: "â©±", epsi: "Îµ", epsilon: "Îµ", epsiv: "Ïµ", eqcirc: "â", eqcolon: "â", eqsim: "â", eqslantgtr: "âª", eqslantless: "âª", equals: "=", equest: "â", equiv: "â¡", equivDD: "â©¸", eqvparsl: "â§¥", erDot: "â", erarr: "â¥±", escr: "â¯", esdot: "â", esim: "â", eta: "Î·", et: "Ã°", eth: "Ã°", eum: "Ã«", euml: "Ã«", euro: "â¬", excl: "!", exist: "â", expectation: "â°", exponentiale: "â", fallingdotseq: "â", fcy: "Ñ", female: "â", ffilig: "ï¬", fflig: "ï¬", ffllig: "ï¬", ffr: "ð£", filig: "ï¬", fjlig: "fj", flat: "â­", fllig: "ï¬", fltns: "â±", fnof: "Æ", fopf: "ð", forall: "â", fork: "â", forkv: "â«", fpartint: "â¨", frac1: "Â¼", frac12: "Â½", frac13: "â", frac14: "Â¼", frac15: "â", frac16: "â", frac18: "â", frac23: "â", frac25: "â", frac3: "Â¾", frac34: "Â¾", frac35: "â", frac38: "â", frac45: "â", frac56: "â", frac58: "â", frac78: "â", frasl: "â", frown: "â¢", fscr: "ð»", gE: "â§", gEl: "âª", gacute: "Çµ", gamma: "Î³", gammad: "Ï", gap: "âª", gbreve: "Ä", gcirc: "Ä", gcy: "Ð³", gdot: "Ä¡", ge: "â¥", gel: "â", geq: "â¥", geqq: "â§", geqslant: "â©¾", ges: "â©¾", gescc: "âª©", gesdot: "âª", gesdoto: "âª", gesdotol: "âª", gesl: "âï¸", gesles: "âª", gfr: "ð¤", gg: "â«", ggg: "â", gimel: "â·", gjcy: "Ñ", gl: "â·", glE: "âª", gla: "âª¥", glj: "âª¤", gnE: "â©", gnap: "âª", gnapprox: "âª", gne: "âª", gneq: "âª", gneqq: "â©", gnsim: "â§", gopf: "ð", grave: "`", gscr: "â", gsim: "â³", gsime: "âª", gsiml: "âª", g: ">", gt: ">", gtcc: "âª§", gtcir: "â©º", gtdot: "â", gtlPar: "â¦", gtquest: "â©¼", gtrapprox: "âª", gtrarr: "â¥¸", gtrdot: "â", gtreqless: "â", gtreqqless: "âª", gtrless: "â·", gtrsim: "â³", gvertneqq: "â©ï¸", gvnE: "â©ï¸", hArr: "â", hairsp: "â", half: "Â½", hamilt: "â", hardcy: "Ñ", harr: "â", harrcir: "â¥", harrw: "â­", hbar: "â", hcirc: "Ä¥", hearts: "â¥", heartsuit: "â¥", hellip: "â¦", hercon: "â¹", hfr: "ð¥", hksearow: "â¤¥", hkswarow: "â¤¦", hoarr: "â¿", homtht: "â»", hookleftarrow: "â©", hookrightarrow: "âª", hopf: "ð", horbar: "â", hscr: "ð½", hslash: "â", hstrok: "Ä§", hybull: "â", hyphen: "â", iacut: "Ã­", iacute: "Ã­", ic: "â£", icir: "Ã®", icirc: "Ã®", icy: "Ð¸", iecy: "Ðµ", iexc: "Â¡", iexcl: "Â¡", iff: "â", ifr: "ð¦", igrav: "Ã¬", igrave: "Ã¬", ii: "â", iiiint: "â¨", iiint: "â­", iinfin: "â§", iiota: "â©", ijlig: "Ä³", imacr: "Ä«", image: "â", imagline: "â", imagpart: "â", imath: "Ä±", imof: "â·", imped: "Æµ", in: "â", incare: "â", infin: "â", infintie: "â§", inodot: "Ä±", int: "â«", intcal: "âº", integers: "â¤", intercal: "âº", intlarhk: "â¨", intprod: "â¨¼", iocy: "Ñ", iogon: "Ä¯", iopf: "ð", iota: "Î¹", iprod: "â¨¼", iques: "Â¿", iquest: "Â¿", iscr: "ð¾", isin: "â", isinE: "â¹", isindot: "âµ", isins: "â´", isinsv: "â³", isinv: "â", it: "â¢", itilde: "Ä©", iukcy: "Ñ", ium: "Ã¯", iuml: "Ã¯", jcirc: "Äµ", jcy: "Ð¹", jfr: "ð§", jmath: "È·", jopf: "ð", jscr: "ð¿", jsercy: "Ñ", jukcy: "Ñ", kappa: "Îº", kappav: "Ï°", kcedil: "Ä·", kcy: "Ðº", kfr: "ð¨", kgreen: "Ä¸", khcy: "Ñ", kjcy: "Ñ", kopf: "ð", kscr: "ð", lAarr: "â", lArr: "â", lAtail: "â¤", lBarr: "â¤", lE: "â¦", lEg: "âª", lHar: "â¥¢", lacute: "Äº", laemptyv: "â¦´", lagran: "â", lambda: "Î»", lang: "â¨", langd: "â¦", langle: "â¨", lap: "âª", laqu: "Â«", laquo: "Â«", larr: "â", larrb: "â¤", larrbfs: "â¤", larrfs: "â¤", larrhk: "â©", larrlp: "â«", larrpl: "â¤¹", larrsim: "â¥³", larrtl: "â¢", lat: "âª«", latail: "â¤", late: "âª­", lates: "âª­ï¸", lbarr: "â¤", lbbrk: "â²", lbrace: "{", lbrack: "[", lbrke: "â¦", lbrksld: "â¦", lbrkslu: "â¦", lcaron: "Ä¾", lcedil: "Ä¼", lceil: "â", lcub: "{", lcy: "Ð»", ldca: "â¤¶", ldquo: "â", ldquor: "â", ldrdhar: "â¥§", ldrushar: "â¥", ldsh: "â²", le: "â¤", leftarrow: "â", leftarrowtail: "â¢", leftharpoondown: "â½", leftharpoonup: "â¼", leftleftarrows: "â", leftrightarrow: "â", leftrightarrows: "â", leftrightharpoons: "â", leftrightsquigarrow: "â­", leftthreetimes: "â", leg: "â", leq: "â¤", leqq: "â¦", leqslant: "â©½", les: "â©½", lescc: "âª¨", lesdot: "â©¿", lesdoto: "âª", lesdotor: "âª", lesg: "âï¸", lesges: "âª", lessapprox: "âª", lessdot: "â", lesseqgtr: "â", lesseqqgtr: "âª", lessgtr: "â¶", lesssim: "â²", lfisht: "â¥¼", lfloor: "â", lfr: "ð©", lg: "â¶", lgE: "âª", lhard: "â½", lharu: "â¼", lharul: "â¥ª", lhblk: "â", ljcy: "Ñ", ll: "âª", llarr: "â", llcorner: "â", llhard: "â¥«", lltri: "âº", lmidot: "Å", lmoust: "â°", lmoustache: "â°", lnE: "â¨", lnap: "âª", lnapprox: "âª", lne: "âª", lneq: "âª", lneqq: "â¨", lnsim: "â¦", loang: "â¬", loarr: "â½", lobrk: "â¦", longleftarrow: "âµ", longleftrightarrow: "â·", longmapsto: "â¼", longrightarrow: "â¶", looparrowleft: "â«", looparrowright: "â¬", lopar: "â¦", lopf: "ð", loplus: "â¨­", lotimes: "â¨´", lowast: "â", lowbar: "_", loz: "â", lozenge: "â", lozf: "â§«", lpar: "(", lparlt: "â¦", lrarr: "â", lrcorner: "â", lrhar: "â", lrhard: "â¥­", lrm: "â", lrtri: "â¿", lsaquo: "â¹", lscr: "ð", lsh: "â°", lsim: "â²", lsime: "âª", lsimg: "âª", lsqb: "[", lsquo: "â", lsquor: "â", lstrok: "Å", l: "<", lt: "<", ltcc: "âª¦", ltcir: "â©¹", ltdot: "â", lthree: "â", ltimes: "â", ltlarr: "â¥¶", ltquest: "â©»", ltrPar: "â¦", ltri: "â", ltrie: "â´", ltrif: "â", lurdshar: "â¥", luruhar: "â¥¦", lvertneqq: "â¨ï¸", lvnE: "â¨ï¸", mDDot: "âº", mac: "Â¯", macr: "Â¯", male: "â", malt: "â ", maltese: "â ", map: "â¦", mapsto: "â¦", mapstodown: "â§", mapstoleft: "â¤", mapstoup: "â¥", marker: "â®", mcomma: "â¨©", mcy: "Ð¼", mdash: "â", measuredangle: "â¡", mfr: "ðª", mho: "â§", micr: "Âµ", micro: "Âµ", mid: "â£", midast: "*", midcir: "â«°", middo: "Â·", middot: "Â·", minus: "â", minusb: "â", minusd: "â¸", minusdu: "â¨ª", mlcp: "â«", mldr: "â¦", mnplus: "â", models: "â§", mopf: "ð", mp: "â", mscr: "ð", mstpos: "â¾", mu: "Î¼", multimap: "â¸", mumap: "â¸", nGg: "âÌ¸", nGt: "â«â", nGtv: "â«Ì¸", nLeftarrow: "â", nLeftrightarrow: "â", nLl: "âÌ¸", nLt: "âªâ", nLtv: "âªÌ¸", nRightarrow: "â", nVDash: "â¯", nVdash: "â®", nabla: "â", nacute: "Å", nang: "â â", nap: "â", napE: "â©°Ì¸", napid: "âÌ¸", napos: "Å", napprox: "â", natur: "â®", natural: "â®", naturals: "â", nbs: "Â ", nbsp: "Â ", nbump: "âÌ¸", nbumpe: "âÌ¸", ncap: "â©", ncaron: "Å", ncedil: "Å", ncong: "â", ncongdot: "â©­Ì¸", ncup: "â©", ncy: "Ð½", ndash: "â", ne: "â ", neArr: "â", nearhk: "â¤¤", nearr: "â", nearrow: "â", nedot: "âÌ¸", nequiv: "â¢", nesear: "â¤¨", nesim: "âÌ¸", nexist: "â", nexists: "â", nfr: "ð«", ngE: "â§Ì¸", nge: "â±", ngeq: "â±", ngeqq: "â§Ì¸", ngeqslant: "â©¾Ì¸", nges: "â©¾Ì¸", ngsim: "âµ", ngt: "â¯", ngtr: "â¯", nhArr: "â", nharr: "â®", nhpar: "â«²", ni: "â", nis: "â¼", nisd: "âº", niv: "â", njcy: "Ñ", nlArr: "â", nlE: "â¦Ì¸", nlarr: "â", nldr: "â¥", nle: "â°", nleftarrow: "â", nleftrightarrow: "â®", nleq: "â°", nleqq: "â¦Ì¸", nleqslant: "â©½Ì¸", nles: "â©½Ì¸", nless: "â®", nlsim: "â´", nlt: "â®", nltri: "âª", nltrie: "â¬", nmid: "â¤", nopf: "ð", no: "Â¬", not: "Â¬", notin: "â", notinE: "â¹Ì¸", notindot: "âµÌ¸", notinva: "â", notinvb: "â·", notinvc: "â¶", notni: "â", notniva: "â", notnivb: "â¾", notnivc: "â½", npar: "â¦", nparallel: "â¦", nparsl: "â«½â¥", npart: "âÌ¸", npolint: "â¨", npr: "â", nprcue: "â ", npre: "âª¯Ì¸", nprec: "â", npreceq: "âª¯Ì¸", nrArr: "â", nrarr: "â", nrarrc: "â¤³Ì¸", nrarrw: "âÌ¸", nrightarrow: "â", nrtri: "â«", nrtrie: "â­", nsc: "â", nsccue: "â¡", nsce: "âª°Ì¸", nscr: "ð", nshortmid: "â¤", nshortparallel: "â¦", nsim: "â", nsime: "â", nsimeq: "â", nsmid: "â¤", nspar: "â¦", nsqsube: "â¢", nsqsupe: "â£", nsub: "â", nsubE: "â«Ì¸", nsube: "â", nsubset: "ââ", nsubseteq: "â", nsubseteqq: "â«Ì¸", nsucc: "â", nsucceq: "âª°Ì¸", nsup: "â", nsupE: "â«Ì¸", nsupe: "â", nsupset: "ââ", nsupseteq: "â", nsupseteqq: "â«Ì¸", ntgl: "â¹", ntild: "Ã±", ntilde: "Ã±", ntlg: "â¸", ntriangleleft: "âª", ntrianglelefteq: "â¬", ntriangleright: "â«", ntrianglerighteq: "â­", nu: "Î½", num: "#", numero: "â", numsp: "â", nvDash: "â­", nvHarr: "â¤", nvap: "ââ", nvdash: "â¬", nvge: "â¥â", nvgt: ">â", nvinfin: "â§", nvlArr: "â¤", nvle: "â¤â", nvlt: "<â", nvltrie: "â´â", nvrArr: "â¤", nvrtrie: "âµâ", nvsim: "â¼â", nwArr: "â", nwarhk: "â¤£", nwarr: "â", nwarrow: "â", nwnear: "â¤§", oS: "â", oacut: "Ã³", oacute: "Ã³", oast: "â", ocir: "Ã´", ocirc: "Ã´", ocy: "Ð¾", odash: "â", odblac: "Å", odiv: "â¨¸", odot: "â", odsold: "â¦¼", oelig: "Å", ofcir: "â¦¿", ofr: "ð¬", ogon: "Ë", ograv: "Ã²", ograve: "Ã²", ogt: "â§", ohbar: "â¦µ", ohm: "Î©", oint: "â®", olarr: "âº", olcir: "â¦¾", olcross: "â¦»", oline: "â¾", olt: "â§", omacr: "Å", omega: "Ï", omicron: "Î¿", omid: "â¦¶", ominus: "â", oopf: "ð ", opar: "â¦·", operp: "â¦¹", oplus: "â", or: "â¨", orarr: "â»", ord: "Âº", order: "â´", orderof: "â´", ordf: "Âª", ordm: "Âº", origof: "â¶", oror: "â©", orslope: "â©", orv: "â©", oscr: "â´", oslas: "Ã¸", oslash: "Ã¸", osol: "â", otild: "Ãµ", otilde: "Ãµ", otimes: "â", otimesas: "â¨¶", oum: "Ã¶", ouml: "Ã¶", ovbar: "â½", par: "Â¶", para: "Â¶", parallel: "â¥", parsim: "â«³", parsl: "â«½", part: "â", pcy: "Ð¿", percnt: "%", period: ".", permil: "â°", perp: "â¥", pertenk: "â±", pfr: "ð­", phi: "Ï", phiv: "Ï", phmmat: "â³", phone: "â", pi: "Ï", pitchfork: "â", piv: "Ï", planck: "â", planckh: "â", plankv: "â", plus: "+", plusacir: "â¨£", plusb: "â", pluscir: "â¨¢", plusdo: "â", plusdu: "â¨¥", pluse: "â©²", plusm: "Â±", plusmn: "Â±", plussim: "â¨¦", plustwo: "â¨§", pm: "Â±", pointint: "â¨", popf: "ð¡", poun: "Â£", pound: "Â£", pr: "âº", prE: "âª³", prap: "âª·", prcue: "â¼", pre: "âª¯", prec: "âº", precapprox: "âª·", preccurlyeq: "â¼", preceq: "âª¯", precnapprox: "âª¹", precneqq: "âªµ", precnsim: "â¨", precsim: "â¾", prime: "â²", primes: "â", prnE: "âªµ", prnap: "âª¹", prnsim: "â¨", prod: "â", profalar: "â®", profline: "â", profsurf: "â", prop: "â", propto: "â", prsim: "â¾", prurel: "â°", pscr: "ð", psi: "Ï", puncsp: "â", qfr: "ð®", qint: "â¨", qopf: "ð¢", qprime: "â", qscr: "ð", quaternions: "â", quatint: "â¨", quest: "?", questeq: "â", quo: '"', quot: '"', rAarr: "â", rArr: "â", rAtail: "â¤", rBarr: "â¤", rHar: "â¥¤", race: "â½Ì±", racute: "Å", radic: "â", raemptyv: "â¦³", rang: "â©", rangd: "â¦", range: "â¦¥", rangle: "â©", raqu: "Â»", raquo: "Â»", rarr: "â", rarrap: "â¥µ", rarrb: "â¥", rarrbfs: "â¤ ", rarrc: "â¤³", rarrfs: "â¤", rarrhk: "âª", rarrlp: "â¬", rarrpl: "â¥", rarrsim: "â¥´", rarrtl: "â£", rarrw: "â", ratail: "â¤", ratio: "â¶", rationals: "â", rbarr: "â¤", rbbrk: "â³", rbrace: "}", rbrack: "]", rbrke: "â¦", rbrksld: "â¦", rbrkslu: "â¦", rcaron: "Å", rcedil: "Å", rceil: "â", rcub: "}", rcy: "Ñ", rdca: "â¤·", rdldhar: "â¥©", rdquo: "â", rdquor: "â", rdsh: "â³", real: "â", realine: "â", realpart: "â", reals: "â", rect: "â­", re: "Â®", reg: "Â®", rfisht: "â¥½", rfloor: "â", rfr: "ð¯", rhard: "â", rharu: "â", rharul: "â¥¬", rho: "Ï", rhov: "Ï±", rightarrow: "â", rightarrowtail: "â£", rightharpoondown: "â", rightharpoonup: "â", rightleftarrows: "â", rightleftharpoons: "â", rightrightarrows: "â", rightsquigarrow: "â", rightthreetimes: "â", ring: "Ë", risingdotseq: "â", rlarr: "â", rlhar: "â", rlm: "â", rmoust: "â±", rmoustache: "â±", rnmid: "â«®", roang: "â­", roarr: "â¾", robrk: "â§", ropar: "â¦", ropf: "ð£", roplus: "â¨®", rotimes: "â¨µ", rpar: ")", rpargt: "â¦", rppolint: "â¨", rrarr: "â", rsaquo: "âº", rscr: "ð", rsh: "â±", rsqb: "]", rsquo: "â", rsquor: "â", rthree: "â", rtimes: "â", rtri: "â¹", rtrie: "âµ", rtrif: "â¸", rtriltri: "â§", ruluhar: "â¥¨", rx: "â", sacute: "Å", sbquo: "â", sc: "â»", scE: "âª´", scap: "âª¸", scaron: "Å¡", sccue: "â½", sce: "âª°", scedil: "Å", scirc: "Å", scnE: "âª¶", scnap: "âªº", scnsim: "â©", scpolint: "â¨", scsim: "â¿", scy: "Ñ", sdot: "â", sdotb: "â¡", sdote: "â©¦", seArr: "â", searhk: "â¤¥", searr: "â", searrow: "â", sec: "Â§", sect: "Â§", semi: ";", seswar: "â¤©", setminus: "â", setmn: "â", sext: "â¶", sfr: "ð°", sfrown: "â¢", sharp: "â¯", shchcy: "Ñ", shcy: "Ñ", shortmid: "â£", shortparallel: "â¥", sh: "Â­", shy: "Â­", sigma: "Ï", sigmaf: "Ï", sigmav: "Ï", sim: "â¼", simdot: "â©ª", sime: "â", simeq: "â", simg: "âª", simgE: "âª ", siml: "âª", simlE: "âª", simne: "â", simplus: "â¨¤", simrarr: "â¥²", slarr: "â", smallsetminus: "â", smashp: "â¨³", smeparsl: "â§¤", smid: "â£", smile: "â£", smt: "âªª", smte: "âª¬", smtes: "âª¬ï¸", softcy: "Ñ", sol: "/", solb: "â§", solbar: "â¿", sopf: "ð¤", spades: "â ", spadesuit: "â ", spar: "â¥", sqcap: "â", sqcaps: "âï¸", sqcup: "â", sqcups: "âï¸", sqsub: "â", sqsube: "â", sqsubset: "â", sqsubseteq: "â", sqsup: "â", sqsupe: "â", sqsupset: "â", sqsupseteq: "â", squ: "â¡", square: "â¡", squarf: "âª", squf: "âª", srarr: "â", sscr: "ð", ssetmn: "â", ssmile: "â£", sstarf: "â", star: "â", starf: "â", straightepsilon: "Ïµ", straightphi: "Ï", strns: "Â¯", sub: "â", subE: "â«", subdot: "âª½", sube: "â", subedot: "â«", submult: "â«", subnE: "â«", subne: "â", subplus: "âª¿", subrarr: "â¥¹", subset: "â", subseteq: "â", subseteqq: "â«", subsetneq: "â", subsetneqq: "â«", subsim: "â«", subsub: "â«", subsup: "â«", succ: "â»", succapprox: "âª¸", succcurlyeq: "â½", succeq: "âª°", succnapprox: "âªº", succneqq: "âª¶", succnsim: "â©", succsim: "â¿", sum: "â", sung: "âª", sup: "â", sup1: "Â¹", sup2: "Â²", sup3: "Â³", supE: "â«", supdot: "âª¾", supdsub: "â«", supe: "â", supedot: "â«", suphsol: "â", suphsub: "â«", suplarr: "â¥»", supmult: "â«", supnE: "â«", supne: "â", supplus: "â«", supset: "â", supseteq: "â", supseteqq: "â«", supsetneq: "â", supsetneqq: "â«", supsim: "â«", supsub: "â«", supsup: "â«", swArr: "â", swarhk: "â¤¦", swarr: "â", swarrow: "â", swnwar: "â¤ª", szli: "Ã", szlig: "Ã", target: "â", tau: "Ï", tbrk: "â´", tcaron: "Å¥", tcedil: "Å£", tcy: "Ñ", tdot: "â", telrec: "â", tfr: "ð±", there4: "â´", therefore: "â´", theta: "Î¸", thetasym: "Ï", thetav: "Ï", thickapprox: "â", thicksim: "â¼", thinsp: "â", thkap: "â", thksim: "â¼", thor: "Ã¾", thorn: "Ã¾", tilde: "Ë", time: "Ã", times: "Ã", timesb: "â ", timesbar: "â¨±", timesd: "â¨°", tint: "â­", toea: "â¤¨", top: "â¤", topbot: "â¶", topcir: "â«±", topf: "ð¥", topfork: "â«", tosa: "â¤©", tprime: "â´", trade: "â¢", triangle: "âµ", triangledown: "â¿", triangleleft: "â", trianglelefteq: "â´", triangleq: "â", triangleright: "â¹", trianglerighteq: "âµ", tridot: "â¬", trie: "â", triminus: "â¨º", triplus: "â¨¹", trisb: "â§", tritime: "â¨»", trpezium: "â¢", tscr: "ð", tscy: "Ñ", tshcy: "Ñ", tstrok: "Å§", twixt: "â¬", twoheadleftarrow: "â", twoheadrightarrow: "â ", uArr: "â", uHar: "â¥£", uacut: "Ãº", uacute: "Ãº", uarr: "â", ubrcy: "Ñ", ubreve: "Å­", ucir: "Ã»", ucirc: "Ã»", ucy: "Ñ", udarr: "â", udblac: "Å±", udhar: "â¥®", ufisht: "â¥¾", ufr: "ð²", ugrav: "Ã¹", ugrave: "Ã¹", uharl: "â¿", uharr: "â¾", uhblk: "â", ulcorn: "â", ulcorner: "â", ulcrop: "â", ultri: "â¸", umacr: "Å«", um: "Â¨", uml: "Â¨", uogon: "Å³", uopf: "ð¦", uparrow: "â", updownarrow: "â", upharpoonleft: "â¿", upharpoonright: "â¾", uplus: "â", upsi: "Ï", upsih: "Ï", upsilon: "Ï", upuparrows: "â", urcorn: "â", urcorner: "â", urcrop: "â", uring: "Å¯", urtri: "â¹", uscr: "ð", utdot: "â°", utilde: "Å©", utri: "âµ", utrif: "â´", uuarr: "â", uum: "Ã¼", uuml: "Ã¼", uwangle: "â¦§", vArr: "â", vBar: "â«¨", vBarv: "â«©", vDash: "â¨", vangrt: "â¦", varepsilon: "Ïµ", varkappa: "Ï°", varnothing: "â", varphi: "Ï", varpi: "Ï", varpropto: "â", varr: "â", varrho: "Ï±", varsigma: "Ï", varsubsetneq: "âï¸", varsubsetneqq: "â«ï¸", varsupsetneq: "âï¸", varsupsetneqq: "â«ï¸", vartheta: "Ï", vartriangleleft: "â²", vartriangleright: "â³", vcy: "Ð²", vdash: "â¢", vee: "â¨", veebar: "â»", veeeq: "â", vellip: "â®", verbar: "|", vert: "|", vfr: "ð³", vltri: "â²", vnsub: "ââ", vnsup: "ââ", vopf: "ð§", vprop: "â", vrtri: "â³", vscr: "ð", vsubnE: "â«ï¸", vsubne: "âï¸", vsupnE: "â«ï¸", vsupne: "âï¸", vzigzag: "â¦", wcirc: "Åµ", wedbar: "â©", wedge: "â§", wedgeq: "â", weierp: "â", wfr: "ð´", wopf: "ð¨", wp: "â", wr: "â", wreath: "â", wscr: "ð", xcap: "â", xcirc: "â¯", xcup: "â", xdtri: "â½", xfr: "ðµ", xhArr: "âº", xharr: "â·", xi: "Î¾", xlArr: "â¸", xlarr: "âµ", xmap: "â¼", xnis: "â»", xodot: "â¨", xopf: "ð©", xoplus: "â¨", xotime: "â¨", xrArr: "â¹", xrarr: "â¶", xscr: "ð", xsqcup: "â¨", xuplus: "â¨", xutri: "â³", xvee: "â", xwedge: "â", yacut: "Ã½", yacute: "Ã½", yacy: "Ñ", ycirc: "Å·", ycy: "Ñ", ye: "Â¥", yen: "Â¥", yfr: "ð¶", yicy: "Ñ", yopf: "ðª", yscr: "ð", yucy: "Ñ", yum: "Ã¿", yuml: "Ã¿", zacute: "Åº", zcaron: "Å¾", zcy: "Ð·", zdot: "Å¼", zeetrf: "â¨", zeta: "Î¶", zfr: "ð·", zhcy: "Ð¶", zigrarr: "â", zopf: "ð«", zscr: "ð", zwj: "â", zwnj: "â" } } }), j = d({ "node_modules/parse-entities/decode-entity.js"(e, t) { y(); var r = N(); t.exports = u; var n = {}.hasOwnProperty; function u(e) { return !!n.call(r, e) && r[e] } } }), O = d({ "node_modules/parse-entities/index.js"(e, t) { y(); var r = x(), n = S(), u = B(), i = T(), o = k(), a = j(); t.exports = W; var s = {}.hasOwnProperty, l = String.fromCharCode, c = Function.prototype, p = { warning: null, reference: null, text: null, warningContext: null, referenceContext: null, textContext: null, position: {}, additional: null, attribute: !1, nonTerminated: !0 }, D = 9, d = 10, f = 12, m = 32, g = 38, h = 59, E = 60, C = 61, F = 35, A = 88, v = 120, b = 65533, w = "named", N = "hexadecimal", O = "decimal", I = {}; I[N] = 16, I[O] = 10; var P = {}; P[w] = o, P[O] = u, P[N] = i; var L = 1, _ = 2, R = 3, M = 4, $ = 5, q = 6, V = 7, U = {}; function W(e, t) { var r, n, u = {}; for (n in t || (t = {}), p) r = t[n], u[n] = null == r ? p[n] : r; return (u.position.indent || u.position.start) && (u.indent = u.position.indent || [], u.position = u.position.start), G(e, u) } function G(e, t) { var u, i, p, y, x, S, B, T, k, j, W, G, J, X, K, Y, Q, Z, ee, te = t.additional, re = t.nonTerminated, ne = t.text, ue = t.reference, ie = t.warning, oe = t.textContext, ae = t.referenceContext, se = t.warningContext, le = t.position, ce = t.indent || [], pe = e.length, De = 0, de = -1, fe = le.column || 1, me = le.line || 1, ge = "", he = []; for ("string" == typeof te && (te = te.charCodeAt(0)), Y = ye(), T = ie ? Ee : c, De--, pe++; ++De < pe;)if (x === d && (fe = ce[de] || 1), (x = e.charCodeAt(De)) === g) { if ((B = e.charCodeAt(De + 1)) === D || B === d || B === f || B === m || B === g || B === E || B != B || te && B === te) { ge += l(x), fe++; continue } for (G = J = De + 1, ee = J, B === F ? (ee = ++G, (B = e.charCodeAt(ee)) === A || B === v ? (X = N, ee = ++G) : X = O) : X = w, u = "", W = "", y = "", K = P[X], ee--; ++ee < pe && K(B = e.charCodeAt(ee));)y += l(B), X === w && s.call(r, y) && (u = y, W = r[y]); (p = e.charCodeAt(ee) === h) && (ee++, (i = X === w && a(y)) && (u = y, W = i)), Z = 1 + ee - J, !p && !re || (y ? X === w ? (p && !W ? T($, 1) : (u !== y && (Z = 1 + (ee = G + u.length) - G, p = !1), p || (k = u ? L : R, t.attribute ? (B = e.charCodeAt(ee)) === C ? (T(k, Z), W = null) : o(B) ? W = null : T(k, Z) : T(k, Z))), S = W) : (p || T(_, Z), z(S = parseInt(y, I[X])) ? (T(V, Z), S = l(b)) : S in n ? (T(q, Z), S = n[S]) : (j = "", H(S) && T(q, Z), S > 65535 && (j += l((S -= 65536) >>> 10 | 55296), S = 56320 | 1023 & S), S = j + l(S))) : X !== w && T(M, Z)), S ? (Ce(), Y = ye(), De = ee - 1, fe += ee - J + 1, he.push(S), (Q = ye()).offset++, ue && ue.call(ae, S, { start: Y, end: Q }, e.slice(J - 1, ee)), Y = Q) : (y = e.slice(J - 1, ee), ge += y, fe += y.length, De = ee - 1) } else 10 === x && (me++, de++, fe = 0), x == x ? (ge += l(x), fe++) : Ce(); return he.join(""); function ye() { return { line: me, column: fe, offset: De + (le.offset || 0) } } function Ee(e, t) { var r = ye(); r.column += t, r.offset += t, ie.call(se, U[e], r, e) } function Ce() { ge && (he.push(ge), ne && ne.call(oe, ge, { start: Y, end: ye() }), ge = "") } } function z(e) { return e >= 55296 && e <= 57343 || e > 1114111 } function H(e) { return e >= 1 && e <= 8 || 11 === e || e >= 13 && e <= 31 || e >= 127 && e <= 159 || e >= 64976 && e <= 65007 || !(65535 & ~e) || 65534 == (65535 & e) } U[L] = "Named character references must be terminated by a semicolon", U[_] = "Numeric character references must be terminated by a semicolon", U[R] = "Named character references cannot be empty", U[M] = "Numeric character references cannot be empty", U[$] = "Named character references must be known", U[q] = "Numeric character references cannot be disallowed", U[V] = "Numeric character references cannot be outside the permissible Unicode range" } }), I = d({ "node_modules/remark-parse/lib/decode.js"(e, t) { y(); var r = E(), n = O(); function u(e) { return u.raw = i, u; function t(t) { for (var r = e.offset, n = t.line, u = []; ++n && n in r;)u.push((r[n] || 0) + 1); return { start: t, indent: u } } function u(r, u, i) { n(r, { position: t(u), warning: o, text: i, reference: i, textContext: e, referenceContext: e }) } function i(e, u, i) { return n(e, r(i, { position: t(u), warning: o })) } function o(t, r, n) { 3 !== n && e.file.message(t, r) } } t.exports = u } }), P = d({ "node_modules/remark-parse/lib/tokenizer.js"(e, t) { function r(e) { return t; function t(t, r) { var o, a, s, l, c, p = this, D = p.offset, d = [], f = p[e + "Methods"], m = p[e + "Tokenizers"], g = r.line, h = r.column; if (!t) return d; for (x.now = C, x.file = p.file, y(""); t;) { for (o = -1, a = f.length, l = !1; ++o < a && (!(s = m[f[o]]) || s.onlyAtStart && !p.atStart || s.notInList && p.inList || s.notInBlock && p.inBlock || s.notInLink && p.inLink || (c = t.length, s.apply(p, [x, t]), !(l = c !== t.length)));); l || p.file.fail(new Error("Infinite loop"), x.now()) } return p.eof = C(), d; function y(e) { for (var t = -1, r = e.indexOf("\n"); -1 !== r;)g++, t = r, r = e.indexOf("\n", r + 1); -1 === t ? h += e.length : h = e.length - t, g in D && (-1 !== t ? h += D[g] : h <= D[g] && (h = D[g] + 1)) } function E() { var e = [], t = g + 1; return function () { for (var r = g + 1; t < r;)e.push((D[t] || 0) + 1), t++; return e } } function C() { var e = { line: g, column: h }; return e.offset = p.toOffset(e), e } function F(e) { this.start = e, this.end = C() } function A(e) { t.slice(0, e.length) !== e && p.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), C()) } function v() { var e = C(); return t; function t(t, r) { var n = t.position, u = n ? n.start : e, i = [], o = n && n.end.line, a = e.line; if (t.position = new F(u), n && r && n.indent) { if (i = n.indent, o < a) { for (; ++o < a;)i.push((D[o] || 0) + 1); i.push(e.column) } r = i.concat(r) } return t.position.indent = r || [], t } } function b(e, t) { var r = t ? t.children : d, o = r[r.length - 1]; return o && e.type === o.type && ("text" === e.type || "blockquote" === e.type) && n(o) && n(e) && (e = ("text" === e.type ? u : i).call(p, o, e)), e !== o && r.push(e), p.atStart && 0 !== d.length && p.exitStart(), e } function x(e) { var r = E(), n = v(), u = C(); return A(e), i.reset = o, o.test = a, i.test = a, t = t.slice(e.length), y(e), r = r(), i; function i(e, t) { return n(b(n(e), t), r) } function o() { var r = i.apply(null, arguments); return g = u.line, h = u.column, t = e + t, r } function a() { var r = n({}); return g = u.line, h = u.column, t = e + t, r.position } } } } function n(e) { var t, r; return "text" !== e.type || !e.position || (t = e.position.start, r = e.position.end, t.line !== r.line || r.column - t.column === e.value.length) } function u(e, t) { return e.value += t.value, e } function i(e, t) { return this.options.commonmark || this.options.gfm ? t : (e.children = e.children.concat(t.children), e) } y(), t.exports = r } }), L = d({ "node_modules/markdown-escapes/index.js"(e, t) { y(), t.exports = i; var r = ["\\", "`", "*", "{", "}", "[", "]", "(", ")", "#", "+", "-", ".", "!", "_", ">"], n = r.concat(["~", "|"]), u = n.concat(["\n", '"', "$", "%", "&", "'", ",", "/", ":", ";", "<", "=", "?", "@", "^"]); function i(e) { var t = e || {}; return t.commonmark ? u : t.gfm ? n : r } i.default = r, i.gfm = n, i.commonmark = u } }), _ = d({ "node_modules/remark-parse/lib/block-elements.js"(e, t) { y(), t.exports = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "meta", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "pre", "section", "source", "title", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"] } }), R = d({ "node_modules/remark-parse/lib/defaults.js"(e, t) { y(), t.exports = { position: !0, gfm: !0, commonmark: !1, pedantic: !1, blocks: _() } } }), M = d({ "node_modules/remark-parse/lib/set-options.js"(e, t) { y(); var r = E(), n = L(), u = R(); function i(e) { var t, i, o = this, a = o.options; if (null == e) e = {}; else { if ("object" != typeof e) throw new Error("Invalid value `" + e + "` for setting `options`"); e = r(e) } for (t in u) { if (null == (i = e[t]) && (i = a[t]), "blocks" !== t && "boolean" != typeof i || "blocks" === t && "object" != typeof i) throw new Error("Invalid value `" + i + "` for setting `options." + t + "`"); e[t] = i } return o.options = e, o.escape = n(e), o } t.exports = i } }), $ = d({ "node_modules/unist-util-is/convert.js"(e, t) { function r(e) { if (null == e) return o; if ("string" == typeof e) return i(e); if ("object" == typeof e) return "length" in e ? u(e) : n(e); if ("function" == typeof e) return e; throw new Error("Expected function, string, or object as test") } function n(e) { return t; function t(t) { var r; for (r in e) if (t[r] !== e[r]) return !1; return !0 } } function u(e) { for (var t = [], n = -1; ++n < e.length;)t[n] = r(e[n]); return u; function u() { for (var e = -1; ++e < t.length;)if (t[e].apply(this, arguments)) return !0; return !1 } } function i(e) { return t; function t(t) { return Boolean(t && t.type === e) } } function o() { return !0 } y(), t.exports = r } }), q = d({ "node_modules/unist-util-visit-parents/color.browser.js"(e, t) { function r(e) { return e } y(), t.exports = r } }), V = d({ "node_modules/unist-util-visit-parents/index.js"(e, t) { y(), t.exports = a; var r = $(), n = q(), u = !0, i = "skip", o = !1; function a(e, t, u, a) { var l, c; function p(e, r, D) { var d, f = "object" == typeof e && null !== e ? e : {}; return "string" == typeof f.type && (d = "string" == typeof f.tagName ? f.tagName : "string" == typeof f.name ? f.name : void 0, m.displayName = "node (" + n(f.type + (d ? "<" + d + ">" : "")) + ")"), m; function m() { var n, d, f = D.concat(e), m = []; if ((!t || c(e, r, D[D.length - 1] || null)) && (m = s(u(e, D)))[0] === o) return m; if (e.children && m[0] !== i) for (d = (a ? e.children.length : -1) + l; d > -1 && d < e.children.length;) { if ((n = p(e.children[d], d, f)())[0] === o) return n; d = "number" == typeof n[1] ? n[1] : d + l } return m } } "function" == typeof t && "function" != typeof u && (a = u, u = t, t = null), c = r(t), l = a ? -1 : 1, p(e, null, [])() } function s(e) { return null !== e && "object" == typeof e && "length" in e ? e : "number" == typeof e ? [u, e] : [e] } a.CONTINUE = u, a.SKIP = i, a.EXIT = o } }), U = d({ "node_modules/unist-util-visit/index.js"(e, t) { y(), t.exports = o; var r = V(), n = r.CONTINUE, u = r.SKIP, i = r.EXIT; function o(e, t, n, u) { function i(e, t) { var r = t[t.length - 1], u = r ? r.children.indexOf(e) : null; return n(e, u, r) } "function" == typeof t && "function" != typeof n && (u = n, n = t, t = null), r(e, t, i, u) } o.CONTINUE = n, o.SKIP = u, o.EXIT = i } }), W = d({ "node_modules/unist-util-remove-position/index.js"(e, t) { y(); var r = U(); function n(e, t) { return r(e, t ? u : i), e } function u(e) { delete e.position } function i(e) { e.position = void 0 } t.exports = n } }), G = d({ "node_modules/remark-parse/lib/parse.js"(e, t) { y(); var r = E(), n = W(); t.exports = o; var u = "\n", i = /\r\n|\r/g; function o() { var e, t = this, o = String(t.file), a = { line: 1, column: 1, offset: 0 }, s = r(a); return 65279 === (o = o.replace(i, u)).charCodeAt(0) && (o = o.slice(1), s.column++, s.offset++), e = { type: "root", children: t.tokenizeBlock(o, s), position: { start: a, end: t.eof || r(a) } }, t.options.position || n(e, !0), e } } }), z = d({ "node_modules/remark-parse/lib/tokenize/blank-line.js"(e, t) { y(); var r = /^[ \t]*(\n|$)/; function n(e, t, n) { for (var u, i = "", o = 0, a = t.length; o < a && null != (u = r.exec(t.slice(o)));)o += u[0].length, i += u[0]; if ("" !== i) { if (n) return !0; e(i) } } t.exports = n } }), H = d({ "node_modules/repeat-string/index.js"(e, t) { y(); var r, n = ""; function u(e, t) { if ("string" != typeof e) throw new TypeError("expected a string"); if (1 === t) return e; if (2 === t) return e + e; var u = e.length * t; if (r !== e || typeof r > "u") r = e, n = ""; else if (n.length >= u) return n.substr(0, u); for (; u > n.length && t > 1;)1 & t && (n += e), t >>= 1, e += e; return n = (n += e).substr(0, u) } t.exports = u } }), J = d({ "node_modules/trim-trailing-lines/index.js"(e, t) { function r(e) { return String(e).replace(/\n+$/, "") } y(), t.exports = r } }), X = d({ "node_modules/remark-parse/lib/tokenize/code-indented.js"(e, t) { y(); var r = H(), n = J(); t.exports = s; var u = "\n", i = "\t", o = " ", a = r(o, 4); function s(e, t, r) { for (var s, l, c, p = -1, D = t.length, d = "", f = "", m = "", g = ""; ++p < D;)if (s = t.charAt(p), c) if (c = !1, d += m, f += g, m = "", g = "", s === u) m = s, g = s; else for (d += s, f += s; ++p < D;) { if (!(s = t.charAt(p)) || s === u) { g = s, m = s; break } d += s, f += s } else if (s === o && t.charAt(p + 1) === s && t.charAt(p + 2) === s && t.charAt(p + 3) === s) m += a, p += 3, c = !0; else if (s === i) m += s, c = !0; else { for (l = ""; s === i || s === o;)l += s, s = t.charAt(++p); if (s !== u) break; m += l + s, g += s } if (f) return !!r || e(d)({ type: "code", lang: null, meta: null, value: n(f) }) } } }), K = d({ "node_modules/remark-parse/lib/tokenize/code-fenced.js"(e, t) { y(), t.exports = l; var r = "\n", n = "\t", u = " ", i = "~", o = "`", a = 3, s = 4; function l(e, t, l) { var c, p, D, d, f, m, g, h, y, E, C, F, A, v = this, b = v.options.gfm, x = t.length + 1, S = 0, B = ""; if (b) { for (; S < x && ((D = t.charAt(S)) === u || D === n);)B += D, S++; if (F = S, (D = t.charAt(S)) === i || D === o) { for (S++, p = D, c = 1, B += D; S < x && (D = t.charAt(S)) === p;)B += D, c++, S++; if (!(c < a)) { for (; S < x && ((D = t.charAt(S)) === u || D === n);)B += D, S++; for (d = "", g = ""; S < x && (D = t.charAt(S)) !== r && (p !== o || D !== p);)D === u || D === n ? g += D : (d += g + D, g = ""), S++; if (!(D = t.charAt(S)) || D === r) { if (l) return !0; (A = e.now()).column += B.length, A.offset += B.length, B += d, d = v.decode.raw(v.unescape(d), A), g && (B += g), g = "", E = "", C = "", h = "", y = ""; for (var T = !0; S < x;)if (h += E, y += C, E = "", C = "", (D = t.charAt(S)) === r) { for (T ? (B += D, T = !1) : (E += D, C += D), g = "", S++; S < x && (D = t.charAt(S)) === u;)g += D, S++; if (E += g, C += g.slice(F), !(g.length >= s)) { for (g = ""; S < x && (D = t.charAt(S)) === p;)g += D, S++; if (E += g, C += g, !(g.length < c)) { for (g = ""; S < x && ((D = t.charAt(S)) === u || D === n);)E += D, C += D, S++; if (!D || D === r) break } } } else h += D, C += D, S++; for (B += h + E, S = -1, x = d.length; ++S < x;)if ((D = d.charAt(S)) === u || D === n) f || (f = d.slice(0, S)); else if (f) { m = d.slice(S); break } return e(B)({ type: "code", lang: f || d || null, meta: m || null, value: y }) } } } } } } }), Y = d({ "node_modules/trim/index.js"(e, t) { function r(e) { return e.replace(/^\s*|\s*$/g, "") } y(), (e = t.exports = r).left = function (e) { return e.replace(/^\s*/, "") }, e.right = function (e) { return e.replace(/\s*$/, "") } } }), Q = d({ "node_modules/remark-parse/lib/util/interrupt.js"(e, t) { function r(e, t, r, n) { for (var u, i, o = e.length, a = -1; ++a < o;)if ((void 0 === (i = (u = e[a])[1] || {}).pedantic || i.pedantic === r.options.pedantic) && (void 0 === i.commonmark || i.commonmark === r.options.commonmark) && t[u[0]].apply(r, n)) return !0; return !1 } y(), t.exports = r } }), Z = d({ "node_modules/remark-parse/lib/tokenize/blockquote.js"(e, t) { y(); var r = Y(), n = Q(); t.exports = s; var u = "\n", i = "\t", o = " ", a = ">"; function s(e, t, s) { for (var l, c, p, D, d, f, m, g, h, y = this, E = y.offset, C = y.blockTokenizers, F = y.interruptBlockquote, A = e.now(), v = A.line, b = t.length, x = [], S = [], B = [], T = 0; T < b && ((c = t.charAt(T)) === o || c === i);)T++; if (t.charAt(T) === a) { if (s) return !0; for (T = 0; T < b;) { for (m = T, g = !1, -1 === (D = t.indexOf(u, T)) && (D = b); T < b && ((c = t.charAt(T)) === o || c === i);)T++; if (t.charAt(T) === a ? (T++, g = !0, t.charAt(T) === o && T++) : T = m, d = t.slice(T, D), !g && !r(d)) { T = m; break } if (!g && (p = t.slice(T), n(F, C, y, [e, p, !0]))) break; f = m === T ? d : t.slice(m, D), B.push(T - m), x.push(f), S.push(d), T = D + 1 } for (T = -1, b = B.length, l = e(x.join(u)); ++T < b;)E[v] = (E[v] || 0) + B[T], v++; return h = y.enterBlock(), S = y.tokenizeBlock(S.join(u), A), h(), l({ type: "blockquote", children: S }) } } } }), ee = d({ "node_modules/remark-parse/lib/tokenize/heading-atx.js"(e, t) { y(), t.exports = a; var r = "\n", n = "\t", u = " ", i = "#", o = 6; function a(e, t, a) { for (var s, l, c, p = this, D = p.options.pedantic, d = t.length + 1, f = -1, m = e.now(), g = "", h = ""; ++f < d;) { if ((s = t.charAt(f)) !== u && s !== n) { f--; break } g += s } for (c = 0; ++f <= d;) { if ((s = t.charAt(f)) !== i) { f--; break } g += s, c++ } if (!(c > o) && c && (D || t.charAt(f + 1) !== i)) { for (d = t.length + 1, l = ""; ++f < d;) { if ((s = t.charAt(f)) !== u && s !== n) { f--; break } l += s } if (D || 0 !== l.length || !s || s === r) { if (a) return !0; for (g += l, l = "", h = ""; ++f < d && (s = t.charAt(f)) && s !== r;)if (s === u || s === n || s === i) { for (; s === u || s === n;)l += s, s = t.charAt(++f); if (D || !h || l || s !== i) { for (; s === i;)l += s, s = t.charAt(++f); for (; s === u || s === n;)l += s, s = t.charAt(++f); f-- } else h += s } else h += l + s, l = ""; return m.column += g.length, m.offset += g.length, e(g += h + l)({ type: "heading", depth: c, children: p.tokenizeInline(h, m) }) } } } } }), te = d({ "node_modules/remark-parse/lib/tokenize/thematic-break.js"(e, t) { y(), t.exports = l; var r = "\t", n = "\n", u = " ", i = "*", o = "-", a = "_", s = 3; function l(e, t, l) { for (var c, p, D, d, f = -1, m = t.length + 1, g = ""; ++f < m && ((c = t.charAt(f)) === r || c === u);)g += c; if (c === i || c === o || c === a) for (p = c, g += c, D = 1, d = ""; ++f < m;)if ((c = t.charAt(f)) === p) D++, g += d + p, d = ""; else { if (c !== u) return D >= s && (!c || c === n) ? (g += d, !!l || e(g)({ type: "thematicBreak" })) : void 0; d += c } } } }), re = d({ "node_modules/remark-parse/lib/util/get-indentation.js"(e, t) { y(), t.exports = o; var r = "\t", n = " ", u = 1, i = 4; function o(e) { for (var t, o = 0, a = 0, s = e.charAt(o), l = {}, c = 0; s === r || s === n;) { for (a += t = s === r ? i : u, t > 1 && (a = Math.floor(a / t) * t); c < a;)l[++c] = o; s = e.charAt(++o) } return { indent: a, stops: l } } } }), ne = d({ "node_modules/remark-parse/lib/util/remove-indentation.js"(e, t) { y(); var r = Y(), n = H(), u = re(); t.exports = s; var i = "\n", o = " ", a = "!"; function s(e, t) { var s, l, c, p = e.split(i), D = p.length + 1, d = 1 / 0, f = []; for (p.unshift(n(o, t) + a); D--;)if (l = u(p[D]), f[D] = l.stops, 0 !== r(p[D]).length) { if (!l.indent) { d = 1 / 0; break } l.indent > 0 && l.indent < d && (d = l.indent) } if (d !== 1 / 0) for (D = p.length; D--;) { for (c = f[D], s = d; s && !(s in c);)s--; p[D] = p[D].slice(c[s] + 1) } return p.shift(), p.join(i) } } }), ue = d({ "node_modules/remark-parse/lib/tokenize/list.js"(e, t) { y(); var r = Y(), n = H(), u = B(), i = re(), o = ne(), a = Q(); t.exports = x; var s = "*", l = "_", c = "+", p = "-", D = ".", d = " ", f = "\n", m = "\t", g = ")", h = "x", E = 4, C = /\n\n(?!\s*$)/, F = /^\[([ X\tx])][ \t]/, A = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/, v = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/, b = /^( {1,4}|\t)?/gm; function x(e, t, n) { for (var i, o, h, y, C, F, A, v, b, x, B, T, w, k, N, j, O, I, P, L, _, R, M, $ = this, q = $.options.commonmark, V = $.options.pedantic, U = $.blockTokenizers, W = $.interruptList, G = 0, z = t.length, H = null, J = !1; G < z && ((y = t.charAt(G)) === m || y === d);)G++; if ((y = t.charAt(G)) === s || y === c || y === p) C = y, h = !1; else { for (h = !0, o = ""; G < z && (y = t.charAt(G), u(y));)o += y, G++; if (y = t.charAt(G), !o || !(y === D || q && y === g) || n && "1" !== o) return; H = parseInt(o, 10), C = y } if ((y = t.charAt(++G)) === d || y === m || !(V || y !== f && "" !== y)) { if (n) return !0; for (G = 0, k = [], N = [], j = []; G < z;) { for (A = G, v = !1, M = !1, -1 === (F = t.indexOf(f, G)) && (F = z), i = 0; G < z;) { if ((y = t.charAt(G)) === m) i += E - i % E; else { if (y !== d) break; i++ } G++ } if (O && i >= O.indent && (M = !0), y = t.charAt(G), b = null, !M) { if (y === s || y === c || y === p) b = y, G++, i++; else { for (o = ""; G < z && (y = t.charAt(G), u(y));)o += y, G++; y = t.charAt(G), G++, o && (y === D || q && y === g) && (b = y, i += o.length + 1) } if (b) if ((y = t.charAt(G)) === m) i += E - i % E, G++; else if (y === d) { for (R = G + E; G < R && t.charAt(G) === d;)G++, i++; G === R && t.charAt(G) === d && (G -= E - 1, i -= E - 1) } else y !== f && "" !== y && (b = null) } if (b) { if (!V && C !== b) break; v = !0 } else q || M || t.charAt(A) !== d ? q && O && (M = i >= O.indent || i > E) : M = !0, v = !1, G = A; if (B = t.slice(A, F), x = A === G ? B : t.slice(G, F), (b === s || b === l || b === p) && U.thematicBreak.call($, e, B, !0)) break; if (T = w, w = !v && !r(x).length, M && O) O.value = O.value.concat(j, B), N = N.concat(j, B), j = []; else if (v) 0 !== j.length && (J = !0, O.value.push(""), O.trail = j.concat()), O = { value: [B], indent: i, trail: [] }, k.push(O), N = N.concat(j, B), j = []; else if (w) { if (T && !q) break; j.push(B) } else { if (T || a(W, U, $, [e, B, !0])) break; O.value = O.value.concat(j, B), N = N.concat(j, B), j = [] } G = F + 1 } for (L = e(N.join(f)).reset({ type: "list", ordered: h, start: H, spread: J, children: [] }), I = $.enterList(), P = $.enterBlock(), G = -1, z = k.length; ++G < z;)O = k[G].value.join(f), _ = e.now(), e(O)(S($, O, _), L), O = k[G].trail.join(f), G !== z - 1 && (O += f), e(O); return I(), P(), L } } function S(e, t, r) { var n, u, i = e.offset, o = null; return t = (e.options.pedantic ? T : w).apply(null, arguments), e.options.gfm && (n = t.match(F)) && (u = n[0].length, o = n[1].toLowerCase() === h, i[r.line] += u, t = t.slice(u)), { type: "listItem", spread: C.test(t), checked: o, children: e.tokenizeBlock(t, r) } } function T(e, t, r) { var n = e.offset, u = r.line; return t = t.replace(v, i), u = r.line, t.replace(b, i); function i(e) { return n[u] = (n[u] || 0) + e.length, u++, "" } } function w(e, t, r) { var u, a, s, l, c, p, D, m = e.offset, g = r.line; for (l = (t = t.replace(A, h)).split(f), (c = o(t, i(u).indent).split(f))[0] = s, m[g] = (m[g] || 0) + a.length, g++, p = 0, D = l.length; ++p < D;)m[g] = (m[g] || 0) + l[p].length - c[p].length, g++; return c.join(f); function h(e, t, r, i, o) { return a = t + r + i, s = o, Number(r) < 10 && a.length % 2 == 1 && (r = d + r), (u = t + n(d, r.length) + i) + s } } } }), ie = d({ "node_modules/remark-parse/lib/tokenize/heading-setext.js"(e, t) { y(), t.exports = c; var r = "\n", n = "\t", u = " ", i = "=", o = "-", a = 3, s = 1, l = 2; function c(e, t, c) { for (var p, D, d, f, m, g = this, h = e.now(), y = t.length, E = -1, C = ""; ++E < y;) { if ((d = t.charAt(E)) !== u || E >= a) { E--; break } C += d } for (p = "", D = ""; ++E < y;) { if ((d = t.charAt(E)) === r) { E--; break } d === u || d === n ? D += d : (p += D + d, D = "") } if (h.column += C.length, h.offset += C.length, C += p + D, d = t.charAt(++E), f = t.charAt(++E), d === r && (f === i || f === o)) { for (C += d, D = f, m = f === i ? s : l; ++E < y;) { if ((d = t.charAt(E)) !== f) { if (d !== r) return; E--; break } D += d } return !!c || e(C + D)({ type: "heading", depth: m, children: g.tokenizeInline(p, h) }) } } } }), oe = d({ "node_modules/remark-parse/lib/util/html.js"(e) { y(); var t = "<[A-Za-z][A-Za-z0-9\\-]*(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*(?:[^\"'=<>`\\u0000-\\u0020]+|'[^']*'|\"[^\"]*\"))?)*\\s*\\/?>", r = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", n = "\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e", u = "<[?].*?[?]>", i = "<![A-Za-z]+\\s+[^>]*>", o = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"; e.openCloseTag = new RegExp("^(?:" + t + "|" + r + ")"), e.tag = new RegExp("^(?:" + t + "|" + r + "|" + n + "|" + u + "|" + i + "|" + o + ")") } }), ae = d({ "node_modules/remark-parse/lib/tokenize/html-block.js"(e, t) { y(); var r = oe().openCloseTag; t.exports = C; var n = "\t", u = " ", i = "\n", o = "<", a = /^<(script|pre|style)(?=(\s|>|$))/i, s = /<\/(script|pre|style)>/i, l = /^<!--/, c = /-->/, p = /^<\?/, D = /\?>/, d = /^<![A-Za-z]/, f = />/, m = /^<!\[CDATA\[/, g = /]]>/, h = /^$/, E = new RegExp(r.source + "\\s*$"); function C(e, t, r) { for (var y, C, F, A, v, b, x, S = this.options.blocks.join("|"), B = new RegExp("^</?(" + S + ")(?=(\\s|/?>|$))", "i"), T = t.length, w = 0, k = [[a, s, !0], [l, c, !0], [p, D, !0], [d, f, !0], [m, g, !0], [B, h, !0], [E, h, !1]]; w < T && ((A = t.charAt(w)) === n || A === u);)w++; if (t.charAt(w) === o) { for (y = -1 === (y = t.indexOf(i, w + 1)) ? T : y, C = t.slice(w, y), F = -1, v = k.length; ++F < v;)if (k[F][0].test(C)) { b = k[F]; break } if (b) { if (r) return b[2]; if (w = y, !b[1].test(C)) for (; w < T;) { if (y = -1 === (y = t.indexOf(i, w + 1)) ? T : y, C = t.slice(w + 1, y), b[1].test(C)) { C && (w = y); break } w = y } return e(x = t.slice(0, w))({ type: "html", value: x }) } } } } }), se = d({ "node_modules/is-whitespace-character/index.js"(e, t) { y(), t.exports = u; var r = String.fromCharCode, n = /\s/; function u(e) { return n.test("number" == typeof e ? r(e) : e.charAt(0)) } } }), le = d({ "node_modules/collapse-white-space/index.js"(e, t) { function r(e) { return String(e).replace(/\s+/g, " ") } y(), t.exports = r } }), ce = d({ "node_modules/remark-parse/lib/util/normalize.js"(e, t) { y(); var r = le(); function n(e) { return r(e).toLowerCase() } t.exports = n } }), pe = d({ "node_modules/remark-parse/lib/tokenize/definition.js"(e, t) { y(); var r = se(), n = ce(); t.exports = h; var u = '"', i = "'", o = "\\", a = "\n", s = "\t", l = " ", c = "[", p = "]", D = "(", d = ")", f = ":", m = "<", g = ">"; function h(e, t, r) { for (var g, h, y, F, A, v, b, x, S = this, B = S.options.commonmark, T = 0, w = t.length, k = ""; T < w && ((F = t.charAt(T)) === l || F === s);)k += F, T++; if ((F = t.charAt(T)) === c) { for (T++, k += F, y = ""; T < w && (F = t.charAt(T)) !== p;)F === o && (y += F, T++, F = t.charAt(T)), y += F, T++; if (y && t.charAt(T) === p && t.charAt(T + 1) === f) { for (v = y, T = (k += y + p + f).length, y = ""; T < w && ((F = t.charAt(T)) === s || F === l || F === a);)k += F, T++; if (y = "", g = k, (F = t.charAt(T)) === m) { for (T++; T < w && E(F = t.charAt(T));)y += F, T++; if ((F = t.charAt(T)) === E.delimiter) k += m + y + F, T++; else { if (B) return; T -= y.length + 1, y = "" } } if (!y) { for (; T < w && C(F = t.charAt(T));)y += F, T++; k += y } if (y) { for (b = y, y = ""; T < w && ((F = t.charAt(T)) === s || F === l || F === a);)y += F, T++; if (A = null, (F = t.charAt(T)) === u ? A = u : F === i ? A = i : F === D && (A = d), A) { if (!y) return; for (T = (k += y + F).length, y = ""; T < w && (F = t.charAt(T)) !== A;) { if (F === a) { if (T++, (F = t.charAt(T)) === a || F === A) return; y += a } y += F, T++ } if ((F = t.charAt(T)) !== A) return; h = k, k += y + F, T++, x = y, y = "" } else y = "", T = k.length; for (; T < w && ((F = t.charAt(T)) === s || F === l);)k += F, T++; if (!(F = t.charAt(T)) || F === a) return !!r || (g = e(g).test().end, b = S.decode.raw(S.unescape(b), g, { nonTerminated: !1 }), x && (h = e(h).test().end, x = S.decode.raw(S.unescape(x), h)), e(k)({ type: "definition", identifier: n(v), label: v, title: x || null, url: b })) } } } } function E(e) { return e !== g && e !== c && e !== p } function C(e) { return e !== c && e !== p && !r(e) } E.delimiter = g } }), De = d({ "node_modules/remark-parse/lib/tokenize/table.js"(e, t) { y(); var r = se(); t.exports = m; var n = "\t", u = "\n", i = " ", o = "-", a = ":", s = "\\", l = "|", c = 1, p = 2, D = "left", d = "center", f = "right"; function m(e, t, m) { var g, h, y, E, C, F, A, v, b, x, S, B, T, w, k, N, j, O, I, P, L, _, R = this; if (R.options.gfm) { for (g = 0, N = 0, F = t.length + 1, A = []; g < F;) { if (P = t.indexOf(u, g), L = t.indexOf(l, g + 1), -1 === P && (P = t.length), -1 === L || L > P) { if (N < p) return; break } A.push(t.slice(g, P)), N++, g = P + 1 } for (E = A.join(u), g = 0, F = (h = A.splice(1, 1)[0] || []).length, N--, y = !1, S = []; g < F;) { if ((b = h.charAt(g)) === l) { if (x = null, !1 === y) { if (!1 === _) return } else S.push(y), y = !1; _ = !1 } else if (b === o) x = !0, y = y || null; else if (b === a) y = y === D ? d : x && null === y ? f : D; else if (!r(b)) return; g++ } if (!1 !== y && S.push(y), !(S.length < c)) { if (m) return !0; for (k = -1, O = [], I = e(E).reset({ type: "table", align: S, children: O }); ++k < N;) { for (j = A[k], C = { type: "tableRow", children: [] }, k && e(u), e(j).reset(C, I), F = j.length + 1, g = 0, v = "", B = "", T = !0; g < F;)(b = j.charAt(g)) !== n && b !== i ? ("" === b || b === l ? T ? e(b) : ((B || b) && !T && (E = B, v.length > 1 && (b ? (E += v.slice(0, -1), v = v.charAt(v.length - 1)) : (E += v, v = "")), w = e.now(), e(E)({ type: "tableCell", children: R.tokenizeInline(B, w) }, C)), e(v + b), v = "", B = "") : (v && (B += v, v = ""), B += b, b === s && g !== F - 2 && (B += j.charAt(g + 1), g++)), T = !1, g++) : (B ? v += b : e(b), g++); k || e(u + h) } return I } } } } }), de = d({ "node_modules/remark-parse/lib/tokenize/paragraph.js"(e, t) { y(); var r = Y(), n = J(), u = Q(); t.exports = l; var i = "\t", o = "\n", a = " ", s = 4; function l(e, t, l) { for (var c, p, D, d, f, m = this, g = m.options.commonmark, h = m.blockTokenizers, y = m.interruptParagraph, E = t.indexOf(o), C = t.length; E < C;) { if (-1 === E) { E = C; break } if (t.charAt(E + 1) === o) break; if (g) { for (d = 0, c = E + 1; c < C;) { if ((D = t.charAt(c)) === i) { d = s; break } if (D !== a) break; d++, c++ } if (d >= s && D !== o) { E = t.indexOf(o, E + 1); continue } } if (p = t.slice(E + 1), u(y, h, m, [e, p, !0])) break; if (c = E, -1 !== (E = t.indexOf(o, E + 1)) && "" === r(t.slice(c, E))) { E = c; break } } return p = t.slice(0, E), !!l || (f = e.now(), e(p = n(p))({ type: "paragraph", children: m.tokenizeInline(p, f) })) } } }), fe = d({ "node_modules/remark-parse/lib/locate/escape.js"(e, t) { function r(e, t) { return e.indexOf("\\", t) } y(), t.exports = r } }), me = d({ "node_modules/remark-parse/lib/tokenize/escape.js"(e, t) { y(); var r = fe(); t.exports = i, i.locator = r; var n = "\n", u = "\\"; function i(e, t, r) { var i, o, a = this; if (t.charAt(0) === u && (i = t.charAt(1), -1 !== a.escape.indexOf(i))) return !!r || (o = i === n ? { type: "break" } : { type: "text", value: i }, e(u + i)(o)) } } }), ge = d({ "node_modules/remark-parse/lib/locate/tag.js"(e, t) { function r(e, t) { return e.indexOf("<", t) } y(), t.exports = r } }), he = d({ "node_modules/remark-parse/lib/tokenize/auto-link.js"(e, t) { y(); var r = se(), n = O(), u = ge(); t.exports = p, p.locator = u, p.notInLink = !0; var i = "<", o = ">", a = "@", s = "/", l = "mailto:", c = l.length; function p(e, t, u) { var p, D, d, f, m, g = this, h = "", y = t.length, E = 0, C = "", F = !1, A = ""; if (t.charAt(0) === i) { for (E++, h = i; E < y && (p = t.charAt(E), !(r(p) || p === o || p === a || ":" === p && t.charAt(E + 1) === s));)C += p, E++; if (C) { if (A += C, C = "", A += p = t.charAt(E), E++, p === a) F = !0; else { if (":" !== p || t.charAt(E + 1) !== s) return; A += s, E++ } for (; E < y && (p = t.charAt(E), !r(p) && p !== o);)C += p, E++; if (p = t.charAt(E), C && p === o) return !!u || (d = A += C, h += A + p, (D = e.now()).column++, D.offset++, F && (A.slice(0, c).toLowerCase() === l ? (d = d.slice(c), D.column += c, D.offset += c) : A = l + A), f = g.inlineTokenizers, g.inlineTokenizers = { text: f.text }, m = g.enterLink(), d = g.tokenizeInline(d, D), g.inlineTokenizers = f, m(), e(h)({ type: "link", title: null, url: n(A, { nonTerminated: !1 }), children: d })) } } } } }), ye = d({ "node_modules/ccount/index.js"(e, t) { function r(e, t) { var r, n = String(e), u = 0; if ("string" != typeof t) throw new Error("Expected character"); for (r = n.indexOf(t); -1 !== r;)u++, r = n.indexOf(t, r + t.length); return u } y(), t.exports = r } }), Ee = d({ "node_modules/remark-parse/lib/locate/url.js"(e, t) { y(), t.exports = n; var r = ["www.", "http://", "https://"]; function n(e, t) { var n, u, i, o = -1; if (!this.options.gfm) return o; for (u = r.length, n = -1; ++n < u;)-1 !== (i = e.indexOf(r[n], t)) && (-1 === o || i < o) && (o = i); return o } } }), Ce = d({ "node_modules/remark-parse/lib/tokenize/url.js"(e, t) { y(); var r = ye(), n = O(), u = B(), i = w(), o = se(), a = Ee(); t.exports = b, b.locator = a, b.notInLink = !0; var s = 33, l = 38, c = 41, p = 42, D = 44, d = 45, f = 46, m = 58, g = 59, h = 63, E = 60, C = 95, F = 126, A = "(", v = ")"; function b(e, t, a) { var y, b, x, S, B, T, w, k, N, j, O, I, P, L, _ = this, R = _.options.gfm, M = _.inlineTokenizers, $ = t.length, q = -1, V = !1; if (R) { if ("www." === t.slice(0, 4)) V = !0, S = 4; else if ("http://" === t.slice(0, 7).toLowerCase()) S = 7; else { if ("https://" !== t.slice(0, 8).toLowerCase()) return; S = 8 } for (q = S - 1, x = S, y = []; S < $;)if ((w = t.charCodeAt(S)) !== f) { if (!u(w) && !i(w) && w !== d && w !== C) break; S++ } else { if (q === S - 1) break; y.push(S), q = S, S++ } if (w === f && (y.pop(), S--), void 0 !== y[0] && (b = y.length < 2 ? x : y[y.length - 2] + 1, -1 === t.slice(b, S).indexOf("_"))) { if (a) return !0; for (k = S, B = S; S < $ && (w = t.charCodeAt(S), !o(w) && w !== E);)S++, w === s || w === p || w === D || w === f || w === m || w === h || w === C || w === F || (k = S); if (S = k, t.charCodeAt(S - 1) === c) for (T = t.slice(B, S), N = r(T, A), j = r(T, v); j > N;)S = B + T.lastIndexOf(v), T = t.slice(B, S), j--; if (t.charCodeAt(S - 1) === g && (S--, i(t.charCodeAt(S - 1)))) { for (k = S - 2; i(t.charCodeAt(k));)k--; t.charCodeAt(k) === l && (S = k) } return O = t.slice(0, S), P = n(O, { nonTerminated: !1 }), V && (P = "http://" + P), L = _.enterLink(), _.inlineTokenizers = { text: M.text }, I = _.tokenizeInline(O, e.now()), _.inlineTokenizers = M, L(), e(O)({ type: "link", title: null, url: P, children: I }) } } } } }), Fe = d({ "node_modules/remark-parse/lib/locate/email.js"(e, t) { y(); var r = B(), n = w(), u = 43, i = 45, o = 46, a = 95; function s(e, t) { var r, n, u = this; if (!this.options.gfm || -1 === (r = e.indexOf("@", t))) return -1; if ((n = r) === t || !l(e.charCodeAt(n - 1))) return s.call(u, e, r + 1); for (; n > t && l(e.charCodeAt(n - 1));)n--; return n } function l(e) { return r(e) || n(e) || e === u || e === i || e === o || e === a } t.exports = s } }), Ae = d({ "node_modules/remark-parse/lib/tokenize/email.js"(e, t) { y(); var r = O(), n = B(), u = w(), i = Fe(); t.exports = p, p.locator = i, p.notInLink = !0; var o = 43, a = 45, s = 46, l = 64, c = 95; function p(e, t, i) { var p, D, d, f, m = this, g = m.options.gfm, h = m.inlineTokenizers, y = 0, E = t.length, C = -1; if (g) { for (p = t.charCodeAt(y); n(p) || u(p) || p === o || p === a || p === s || p === c;)p = t.charCodeAt(++y); if (0 !== y && p === l) { for (y++; y < E && (p = t.charCodeAt(y), n(p) || u(p) || p === a || p === s || p === c);)y++, -1 === C && p === s && (C = y); if (-1 !== C && C !== y && p !== a && p !== c) return p === s && y--, D = t.slice(0, y), !!i || (f = m.enterLink(), m.inlineTokenizers = { text: h.text }, d = m.tokenizeInline(D, e.now()), m.inlineTokenizers = h, f(), e(D)({ type: "link", title: null, url: "mailto:" + r(D, { nonTerminated: !1 }), children: d })) } } } } }), ve = d({ "node_modules/remark-parse/lib/tokenize/html-inline.js"(e, t) { y(); var r = w(), n = ge(), u = oe().tag; t.exports = p, p.locator = n; var i = "<", o = "?", a = "!", s = "/", l = /^<a /i, c = /^<\/a>/i; function p(e, t, n) { var p, D, d = this, f = t.length; if (!(t.charAt(0) !== i || f < 3) && (p = t.charAt(1), (r(p) || p === o || p === a || p === s) && (D = t.match(u)))) return !!n || (D = D[0], !d.inLink && l.test(D) ? d.inLink = !0 : d.inLink && c.test(D) && (d.inLink = !1), e(D)({ type: "html", value: D })) } } }), xe = d({ "node_modules/remark-parse/lib/locate/link.js"(e, t) { function r(e, t) { var r = e.indexOf("[", t), n = e.indexOf("![", t); return -1 === n || r < n ? r : n } y(), t.exports = r } }), Se = d({ "node_modules/remark-parse/lib/tokenize/link.js"(e, t) { y(); var r = se(), n = xe(); t.exports = g, g.locator = n; var u = "\n", i = "!", o = '"', a = "'", s = "(", l = ")", c = "<", p = ">", D = "[", d = "\\", f = "]", m = "`"; function g(e, t, n) { var g, h, y, E, C, F, A, v, b, x, S, B, T, w, k, N, j, O, I = this, P = "", L = 0, _ = t.charAt(0), R = I.options.pedantic, M = I.options.commonmark, $ = I.options.gfm; if (_ === i && (v = !0, P = _, _ = t.charAt(++L)), _ === D && (v || !I.inLink)) { for (P += _, w = "", L++, S = t.length, T = 0, (N = e.now()).column += L, N.offset += L; L < S;) { if (F = _ = t.charAt(L), _ === m) { for (h = 1; t.charAt(L + 1) === m;)F += _, L++, h++; y ? h >= y && (y = 0) : y = h } else if (_ === d) L++, F += t.charAt(L); else if (y && !$ || _ !== D) { if ((!y || $) && _ === f) { if (!T) { if (t.charAt(L + 1) !== s) return; F += s, g = !0, L++; break } T-- } } else T++; w += F, F = "", L++ } if (g) { for (b = w, P += w + F, L++; L < S && (_ = t.charAt(L), r(_));)P += _, L++; if (w = "", E = P, (_ = t.charAt(L)) === c) { for (L++, E += c; L < S && (_ = t.charAt(L)) !== p;) { if (M && _ === u) return; w += _, L++ } if (t.charAt(L) !== p) return; P += c + w + p, k = w, L++ } else { for (_ = null, F = ""; L < S && (_ = t.charAt(L), !F || !(_ === o || _ === a || M && _ === s));) { if (r(_)) { if (!R) break; F += _ } else { if (_ === s) T++; else if (_ === l) { if (0 === T) break; T-- } w += F, F = "", _ === d && (w += d, _ = t.charAt(++L)), w += _ } L++ } k = w, L = (P += w).length } for (w = ""; L < S && (_ = t.charAt(L), r(_));)w += _, L++; if (_ = t.charAt(L), P += w, w && (_ === o || _ === a || M && _ === s)) if (L++, w = "", x = _ === s ? l : _, C = P += _, M) { for (; L < S && (_ = t.charAt(L)) !== x;)_ === d && (w += d, _ = t.charAt(++L)), L++, w += _; if ((_ = t.charAt(L)) !== x) return; for (B = w, P += w + _, L++; L < S && (_ = t.charAt(L), r(_));)P += _, L++ } else for (F = ""; L < S;) { if ((_ = t.charAt(L)) === x) A && (w += x + F, F = ""), A = !0; else if (A) { if (_ === l) { P += w + x + F, B = w; break } r(_) ? F += _ : (w += x + F + _, F = "", A = !1) } else w += _; L++ } if (t.charAt(L) === l) return !!n || (P += l, k = I.decode.raw(I.unescape(k), e(E).test().end, { nonTerminated: !1 }), B && (C = e(C).test().end, B = I.decode.raw(I.unescape(B), C)), O = { type: v ? "image" : "link", title: B || null, url: k }, v ? O.alt = I.decode.raw(I.unescape(b), N) || null : (j = I.enterLink(), O.children = I.tokenizeInline(b, N), j()), e(P)(O)) } } } } }), Be = d({ "node_modules/remark-parse/lib/tokenize/reference.js"(e, t) { y(); var r = se(), n = xe(), u = ce(); t.exports = f, f.locator = n; var i = "link", o = "image", a = "shortcut", s = "collapsed", l = "full", c = "!", p = "[", D = "\\", d = "]"; function f(e, t, n) { var f, m, g, h, y, E, C, F, A = this, v = A.options.commonmark, b = t.charAt(0), x = 0, S = t.length, B = "", T = "", w = i, k = a; if (b === c && (w = o, T = b, b = t.charAt(++x)), b === p) { for (x++, T += b, E = "", F = 0; x < S;) { if ((b = t.charAt(x)) === p) C = !0, F++; else if (b === d) { if (!F) break; F-- } b === D && (E += D, b = t.charAt(++x)), E += b, x++ } if (B = E, f = E, (b = t.charAt(x)) === d) { if (x++, B += b, E = "", !v) for (; x < S && (b = t.charAt(x), r(b));)E += b, x++; if ((b = t.charAt(x)) === p) { for (m = "", E += b, x++; x < S && (b = t.charAt(x)) !== p && b !== d;)b === D && (m += D, b = t.charAt(++x)), m += b, x++; (b = t.charAt(x)) === d ? (k = m ? l : s, E += m + b, x++) : m = "", B += E, E = "" } else { if (!f) return; m = f } if (k === l || !C) return B = T + B, w === i && A.inLink ? null : !!n || ((g = e.now()).column += T.length, g.offset += T.length, h = { type: w + "Reference", identifier: u(m = k === l ? m : f), label: m, referenceType: k }, w === i ? (y = A.enterLink(), h.children = A.tokenizeInline(f, g), y()) : h.alt = A.decode.raw(A.unescape(f), g) || null, e(B)(h)) } } } } }), Te = d({ "node_modules/remark-parse/lib/locate/strong.js"(e, t) { function r(e, t) { var r = e.indexOf("**", t), n = e.indexOf("__", t); return -1 === n ? r : -1 === r || n < r ? n : r } y(), t.exports = r } }), we = d({ "node_modules/remark-parse/lib/tokenize/strong.js"(e, t) { y(); var r = Y(), n = se(), u = Te(); t.exports = s, s.locator = u; var i = "\\", o = "*", a = "_"; function s(e, t, u) { var s, l, c, p, D, d, f, m = this, g = 0, h = t.charAt(g); if (!(h !== o && h !== a || t.charAt(++g) !== h || (l = m.options.pedantic, c = h, D = c + c, d = t.length, g++, p = "", h = "", l && n(t.charAt(g))))) for (; g < d;) { if (f = h, !((h = t.charAt(g)) !== c || t.charAt(g + 1) !== c || l && n(f) || (h = t.charAt(g + 2), h === c))) return r(p) ? !!u || ((s = e.now()).column += 2, s.offset += 2, e(D + p + D)({ type: "strong", children: m.tokenizeInline(p, s) })) : void 0; !l && h === i && (p += h, h = t.charAt(++g)), p += h, g++ } } } }), ke = d({ "node_modules/is-word-character/index.js"(e, t) { y(), t.exports = u; var r = String.fromCharCode, n = /\w/; function u(e) { return n.test("number" == typeof e ? r(e) : e.charAt(0)) } } }), Ne = d({ "node_modules/remark-parse/lib/locate/emphasis.js"(e, t) { function r(e, t) { var r = e.indexOf("*", t), n = e.indexOf("_", t); return -1 === n ? r : -1 === r || n < r ? n : r } y(), t.exports = r } }), Oe = d({ "node_modules/remark-parse/lib/tokenize/emphasis.js"(e, t) { y(); var r = Y(), n = ke(), u = se(), i = Ne(); t.exports = l, l.locator = i; var o = "*", a = "_", s = "\\"; function l(e, t, i) { var l, c, p, D, d, f, m, g = this, h = 0, y = t.charAt(h); if (!(y !== o && y !== a || (c = g.options.pedantic, d = y, p = y, f = t.length, h++, D = "", y = "", c && u(t.charAt(h))))) for (; h < f;) { if (m = y, !((y = t.charAt(h)) !== p || c && u(m))) { if ((y = t.charAt(++h)) !== p) { if (!r(D) || m === p) return; if (!c && p === a && n(y)) { D += p; continue } return !!i || ((l = e.now()).column++, l.offset++, e(d + D + p)({ type: "emphasis", children: g.tokenizeInline(D, l) })) } D += p } !c && y === s && (D += y, y = t.charAt(++h)), D += y, h++ } } } }), Ie = d({ "node_modules/remark-parse/lib/locate/delete.js"(e, t) { function r(e, t) { return e.indexOf("~~", t) } y(), t.exports = r } }), Pe = d({ "node_modules/remark-parse/lib/tokenize/delete.js"(e, t) { y(); var r = se(), n = Ie(); t.exports = o, o.locator = n; var u = "~", i = "~~"; function o(e, t, n) { var o, a, s, l = this, c = "", p = "", D = "", d = ""; if (l.options.gfm && t.charAt(0) === u && t.charAt(1) === u && !r(t.charAt(2))) for (o = 1, a = t.length, (s = e.now()).column += 2, s.offset += 2; ++o < a;) { if (!((c = t.charAt(o)) !== u || p !== u || D && r(D))) return !!n || e(i + d + i)({ type: "delete", children: l.tokenizeInline(d, s) }); d += p, D = p, p = c } } } }), Le = d({ "node_modules/remark-parse/lib/locate/code-inline.js"(e, t) { function r(e, t) { return e.indexOf("`", t) } y(), t.exports = r } }), _e = d({ "node_modules/remark-parse/lib/tokenize/code-inline.js"(e, t) { y(); var r = Le(); t.exports = o, o.locator = r; var n = 10, u = 32, i = 96; function o(e, t, r) { for (var o, a, s, l, c, p, D = t.length, d = 0; d < D && t.charCodeAt(d) === i;)d++; if (0 !== d && d !== D) { for (o = d, c = t.charCodeAt(d); d < D;) { if (l = c, c = t.charCodeAt(d + 1), l === i) { if (void 0 === a && (a = d), s = d + 1, c !== i && s - a === o) { p = !0; break } } else void 0 !== a && (a = void 0, s = void 0); d++ } if (p) { if (r) return !0; if (d = o, D = a, l = t.charCodeAt(d), c = t.charCodeAt(D - 1), p = !1, D - d > 2 && (l === u || l === n) && (c === u || c === n)) { for (d++, D--; d < D;) { if ((l = t.charCodeAt(d)) !== u && l !== n) { p = !0; break } d++ } !0 === p && (o++, a--) } return e(t.slice(0, s))({ type: "inlineCode", value: t.slice(o, a) }) } } } } }), Re = d({ "node_modules/remark-parse/lib/locate/break.js"(e, t) { function r(e, t) { for (var r = e.indexOf("\n", t); r > t && " " === e.charAt(r - 1);)r--; return r } y(), t.exports = r } }), Me = d({ "node_modules/remark-parse/lib/tokenize/break.js"(e, t) { y(); var r = Re(); t.exports = o, o.locator = r; var n = " ", u = "\n", i = 2; function o(e, t, r) { for (var o, a = t.length, s = -1, l = ""; ++s < a;) { if ((o = t.charAt(s)) === u) return s < i ? void 0 : !!r || e(l += o)({ type: "break" }); if (o !== n) return; l += o } } } }), $e = d({ "node_modules/remark-parse/lib/tokenize/text.js"(e, t) { function r(e, t, r) { var n, u, i, o, a, s, l, c, p, D, d = this; if (r) return !0; for (o = (n = d.inlineMethods).length, u = d.inlineTokenizers, i = -1, p = t.length; ++i < o;)"text" !== (c = n[i]) && u[c] && ((l = u[c].locator) || e.file.fail("Missing locator: `" + c + "`"), -1 !== (s = l.call(d, t, 1)) && s < p && (p = s)); function f(t, r, n) { e(n || t)({ type: "text", value: t }) } a = t.slice(0, p), D = e.now(), d.decode(a, D, f) } y(), t.exports = r } }), qe = d({ "node_modules/remark-parse/lib/parser.js"(e, t) { y(); var r = E(), n = A(), u = v(), i = b(), o = I(), a = P(); function s(e, t) { this.file = t, this.offset = {}, this.options = r(this.options), this.setOptions({}), this.inList = !1, this.inBlock = !1, this.inLink = !1, this.atStart = !0, this.toOffset = u(t).toOffset, this.unescape = i(this, "escape"), this.decode = o(this) } t.exports = s; var l = s.prototype; function c(e) { var t, r = []; for (t in e) r.push(t); return r } l.setOptions = M(), l.parse = G(), l.options = R(), l.exitStart = n("atStart", !0), l.enterList = n("inList", !1), l.enterLink = n("inLink", !1), l.enterBlock = n("inBlock", !1), l.interruptParagraph = [["thematicBreak"], ["list"], ["atxHeading"], ["fencedCode"], ["blockquote"], ["html"], ["setextHeading", { commonmark: !1 }], ["definition", { commonmark: !1 }]], l.interruptList = [["atxHeading", { pedantic: !1 }], ["fencedCode", { pedantic: !1 }], ["thematicBreak", { pedantic: !1 }], ["definition", { commonmark: !1 }]], l.interruptBlockquote = [["indentedCode", { commonmark: !0 }], ["fencedCode", { commonmark: !0 }], ["atxHeading", { commonmark: !0 }], ["setextHeading", { commonmark: !0 }], ["thematicBreak", { commonmark: !0 }], ["html", { commonmark: !0 }], ["list", { commonmark: !0 }], ["definition", { commonmark: !1 }]], l.blockTokenizers = { blankLine: z(), indentedCode: X(), fencedCode: K(), blockquote: Z(), atxHeading: ee(), thematicBreak: te(), list: ue(), setextHeading: ie(), html: ae(), definition: pe(), table: De(), paragraph: de() }, l.inlineTokenizers = { escape: me(), autoLink: he(), url: Ce(), email: Ae(), html: ve(), link: Se(), reference: Be(), strong: we(), emphasis: Oe(), deletion: Pe(), code: _e(), break: Me(), text: $e() }, l.blockMethods = c(l.blockTokenizers), l.inlineMethods = c(l.inlineTokenizers), l.tokenizeBlock = a("block"), l.tokenizeInline = a("inline"), l.tokenizeFactory = a } }), Ve = d({ "node_modules/remark-parse/index.js"(e, t) { y(); var r = F(), n = E(), u = qe(); function i(e) { var t = this.data("settings"), i = r(u); i.prototype.options = n(i.prototype.options, t, e), this.Parser = i } t.exports = i, i.Parser = u } }), Ue = d({ "node_modules/bail/index.js"(e, t) { function r(e) { if (e) throw e } y(), t.exports = r } }), We = d({ "node_modules/is-buffer/index.js"(e, t) { y(), t.exports = function (e) { return null != e && null != e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e) } } }), Ge = d({ "node_modules/extend/index.js"(e, t) { y(); var r = Object.prototype.hasOwnProperty, n = Object.prototype.toString, u = Object.defineProperty, i = Object.getOwnPropertyDescriptor, o = function (e) { return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === n.call(e) }, a = function (e) { if (!e || "[object Object]" !== n.call(e)) return !1; var t, u = r.call(e, "constructor"), i = e.constructor && e.constructor.prototype && r.call(e.constructor.prototype, "isPrototypeOf"); if (e.constructor && !u && !i) return !1; for (t in e); return typeof t > "u" || r.call(e, t) }, s = function (e, t) { u && "__proto__" === t.name ? u(e, t.name, { enumerable: !0, configurable: !0, value: t.newValue, writable: !0 }) : e[t.name] = t.newValue }, l = function (e, t) { if ("__proto__" === t) { if (!r.call(e, t)) return; if (i) return i(e, t).value } return e[t] }; t.exports = function e() { var t, r, n, u, i, c, p = arguments[0], D = 1, d = arguments.length, f = !1; for ("boolean" == typeof p && (f = p, p = arguments[1] || {}, D = 2), (null == p || "object" != typeof p && "function" != typeof p) && (p = {}); D < d; ++D)if (null != (t = arguments[D])) for (r in t) n = l(p, r), p !== (u = l(t, r)) && (f && u && (a(u) || (i = o(u))) ? (i ? (i = !1, c = n && o(n) ? n : []) : c = n && a(n) ? n : {}, s(p, { name: r, newValue: e(f, c, u) })) : typeof u < "u" && s(p, { name: r, newValue: u })); return p } } }), ze = d({ "node_modules/is-plain-obj/index.js"(e, t) { y(), t.exports = e => { if ("[object Object]" !== Object.prototype.toString.call(e)) return !1; let t = Object.getPrototypeOf(e); return null === t || t === Object.prototype } } }), He = d({ "node_modules/trough/wrap.js"(e, t) { y(); var r = [].slice; function n(e, t) { var n; return u; function u() { var t, u = r.call(arguments, 0), a = e.length > u.length; a && u.push(i); try { t = e.apply(null, u) } catch (s) { if (a && n) throw s; return i(s) } a || (t && "function" == typeof t.then ? t.then(o, i) : t instanceof Error ? i(t) : o(t)) } function i() { n || (n = !0, t.apply(null, arguments)) } function o(e) { i(null, e) } } t.exports = n } }), Je = d({ "node_modules/trough/index.js"(e, t) { y(); var r = He(); t.exports = u, u.wrap = r; var n = [].slice; function u() { var e = [], t = {}; return t.run = u, t.use = i, t; function u() { var t = -1, u = n.call(arguments, 0, -1), i = arguments[arguments.length - 1]; if ("function" != typeof i) throw new Error("Expected function as last argument, not " + i); function o(a) { var s = e[++t], l = n.call(arguments, 0).slice(1), c = u.length, p = -1; if (a) i(a); else { for (; ++p < c;)(null === l[p] || void 0 === l[p]) && (l[p] = u[p]); u = l, s ? r(s, o).apply(null, u) : i.apply(null, [null].concat(u)) } } o.apply(null, [null].concat(u)) } function i(r) { if ("function" != typeof r) throw new Error("Expected `fn` to be a function, not " + r); return e.push(r), t } } } }), Xe = d({ "node_modules/unist-util-stringify-position/index.js"(e, t) { y(); var r = {}.hasOwnProperty; function n(e) { return e && "object" == typeof e ? r.call(e, "position") || r.call(e, "type") ? i(e.position) : r.call(e, "start") || r.call(e, "end") ? i(e) : r.call(e, "line") || r.call(e, "column") ? u(e) : "" : "" } function u(e) { return (!e || "object" != typeof e) && (e = {}), o(e.line) + ":" + o(e.column) } function i(e) { return (!e || "object" != typeof e) && (e = {}), u(e.start) + "-" + u(e.end) } function o(e) { return e && "number" == typeof e ? e : 1 } t.exports = n } }), Ke = d({ "node_modules/vfile-message/index.js"(e, t) { y(); var r = Xe(); function n() { } t.exports = i, n.prototype = Error.prototype, i.prototype = new n; var u = i.prototype; function i(e, t, n) { var u, i, a; "string" == typeof t && (n = t, t = null), u = o(n), i = r(t) || "1:1", a = { start: { line: null, column: null }, end: { line: null, column: null } }, t && t.position && (t = t.position), t && (t.start ? (a = t, t = t.start) : a.start = t), e.stack && (this.stack = e.stack, e = e.message), this.message = e, this.name = i, this.reason = e, this.line = t ? t.line : null, this.column = t ? t.column : null, this.location = a, this.source = u[0], this.ruleId = u[1] } function o(e) { var t, r = [null, null]; return "string" == typeof e && (-1 === (t = e.indexOf(":")) ? r[1] = e : (r[0] = e.slice(0, t), r[1] = e.slice(t + 1))), r } u.file = "", u.name = "", u.reason = "", u.message = "", u.stack = "", u.fatal = null, u.column = null, u.line = null } }), Ye = d({ "node_modules/vfile/lib/minpath.browser.js"(e) { function t(e, t) { var r, n, u, i, o = 0, s = -1; if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string'); if (a(e), r = e.length, void 0 === t || !t.length || t.length > e.length) { for (; r--;)if (47 === e.charCodeAt(r)) { if (u) { o = r + 1; break } } else s < 0 && (u = !0, s = r + 1); return s < 0 ? "" : e.slice(o, s) } if (t === e) return ""; for (n = -1, i = t.length - 1; r--;)if (47 === e.charCodeAt(r)) { if (u) { o = r + 1; break } } else n < 0 && (u = !0, n = r + 1), i > -1 && (e.charCodeAt(r) === t.charCodeAt(i--) ? i < 0 && (s = r) : (i = -1, s = n)); return o === s ? s = n : s < 0 && (s = e.length), e.slice(o, s) } function r(e) { var t, r, n; if (a(e), !e.length) return "."; for (t = -1, n = e.length; --n;)if (47 === e.charCodeAt(n)) { if (r) { t = n; break } } else r || (r = !0); return t < 0 ? 47 === e.charCodeAt(0) ? "/" : "." : 1 === t && 47 === e.charCodeAt(0) ? "//" : e.slice(0, t) } function n(e) { var t, r, n, u = -1, i = 0, o = -1, s = 0; for (a(e), n = e.length; n--;)if (47 !== (r = e.charCodeAt(n))) o < 0 && (t = !0, o = n + 1), 46 === r ? u < 0 ? u = n : 1 !== s && (s = 1) : u > -1 && (s = -1); else if (t) { i = n + 1; break } return u < 0 || o < 0 || 0 === s || 1 === s && u === o - 1 && u === i + 1 ? "" : e.slice(u, o) } function u() { for (var e, t = -1; ++t < arguments.length;)a(arguments[t]), arguments[t] && (e = void 0 === e ? arguments[t] : e + "/" + arguments[t]); return void 0 === e ? "." : i(e) } function i(e) { var t, r; return a(e), t = 47 === e.charCodeAt(0), !(r = o(e, !t)).length && !t && (r = "."), r.length && 47 === e.charCodeAt(e.length - 1) && (r += "/"), t ? "/" + r : r } function o(e, t) { for (var r, n, u = "", i = 0, o = -1, a = 0, s = -1; ++s <= e.length;) { if (s < e.length) r = e.charCodeAt(s); else { if (47 === r) break; r = 47 } if (47 === r) { if (o !== s - 1 && 1 !== a) if (o !== s - 1 && 2 === a) { if (u.length < 2 || 2 !== i || 46 !== u.charCodeAt(u.length - 1) || 46 !== u.charCodeAt(u.length - 2)) if (u.length > 2) { if ((n = u.lastIndexOf("/")) !== u.length - 1) { n < 0 ? (u = "", i = 0) : i = (u = u.slice(0, n)).length - 1 - u.lastIndexOf("/"), o = s, a = 0; continue } } else if (u.length) { u = "", i = 0, o = s, a = 0; continue } t && (u = u.length ? u + "/.." : "..", i = 2) } else u.length ? u += "/" + e.slice(o + 1, s) : u = e.slice(o + 1, s), i = s - o - 1; o = s, a = 0 } else 46 === r && a > -1 ? a++ : a = -1 } return u } function a(e) { if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } y(), e.basename = t, e.dirname = r, e.extname = n, e.join = u, e.sep = "/" } }), Qe = d({ "node_modules/vfile/lib/minproc.browser.js"(e) { function t() { return "/" } y(), e.cwd = t } }), Ze = d({ "node_modules/vfile/lib/core.js"(e, t) { y(); var r = Ye(), n = Qe(), u = We(); t.exports = a; var i = {}.hasOwnProperty, o = ["history", "path", "basename", "stem", "extname", "dirname"]; function a(e) { var t, r; if (e) { if ("string" == typeof e || u(e)) e = { contents: e }; else if ("message" in e && "messages" in e) return e } else e = {}; if (!(this instanceof a)) return new a(e); for (this.data = {}, this.messages = [], this.history = [], this.cwd = n.cwd(), r = -1; ++r < o.length;)t = o[r], i.call(e, t) && (this[t] = e[t]); for (t in e) o.indexOf(t) < 0 && (this[t] = e[t]) } function s() { return this.history[this.history.length - 1] } function l(e) { F(e, "path"), this.path !== e && this.history.push(e) } function c() { return "string" == typeof this.path ? r.dirname(this.path) : void 0 } function p(e) { A(this.path, "dirname"), this.path = r.join(e || "", this.basename) } function D() { return "string" == typeof this.path ? r.basename(this.path) : void 0 } function d(e) { F(e, "basename"), C(e, "basename"), this.path = r.join(this.dirname || "", e) } function f() { return "string" == typeof this.path ? r.extname(this.path) : void 0 } function m(e) { if (C(e, "extname"), A(this.path, "extname"), e) { if (46 !== e.charCodeAt(0)) throw new Error("`extname` must start with `.`"); if (e.indexOf(".", 1) > -1) throw new Error("`extname` cannot contain multiple dots") } this.path = r.join(this.dirname, this.stem + (e || "")) } function g() { return "string" == typeof this.path ? r.basename(this.path, this.extname) : void 0 } function h(e) { F(e, "stem"), C(e, "stem"), this.path = r.join(this.dirname || "", e + (this.extname || "")) } function E(e) { return (this.contents || "").toString(e) } function C(e, t) { if (e && e.indexOf(r.sep) > -1) throw new Error("`" + t + "` cannot be a path: did not expect `" + r.sep + "`") } function F(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function A(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } a.prototype.toString = E, Object.defineProperty(a.prototype, "path", { get: s, set: l }), Object.defineProperty(a.prototype, "dirname", { get: c, set: p }), Object.defineProperty(a.prototype, "basename", { get: D, set: d }), Object.defineProperty(a.prototype, "extname", { get: f, set: m }), Object.defineProperty(a.prototype, "stem", { get: g, set: h }) } }), et = d({ "node_modules/vfile/lib/index.js"(e, t) { y(); var r = Ke(), n = Ze(); function u(e, t, n) { var u = new r(e, t, n); return this.path && (u.name = this.path + ":" + u.name, u.file = this.path), u.fatal = !1, this.messages.push(u), u } function i() { var e = this.message.apply(this, arguments); throw e.fatal = !0, e } function o() { var e = this.message.apply(this, arguments); return e.fatal = null, e } t.exports = n, n.prototype.message = u, n.prototype.info = o, n.prototype.fail = i } }), tt = d({ "node_modules/vfile/index.js"(e, t) { y(), t.exports = et() } }), rt = d({ "node_modules/unified/index.js"(e, t) { y(); var r = Ue(), n = We(), u = Ge(), i = ze(), o = Je(), a = tt(); t.exports = f().freeze(); var s = [].slice, l = {}.hasOwnProperty, c = o().use(p).use(D).use(d); function p(e, t) { t.tree = e.parse(t.file) } function D(e, t, r) { function n(e, n, u) { e ? r(e) : (t.tree = n, t.file = u, r()) } e.run(t.tree, t.file, n) } function d(e, t) { var r = e.stringify(t.tree, t.file); null == r || ("string" == typeof r || n(r) ? t.file.contents = r : t.file.result = r) } function f() { var e, t = [], n = o(), p = {}, D = -1; return d.data = y, d.freeze = g, d.attachers = t, d.use = v, d.parse = x, d.stringify = T, d.run = S, d.runSync = B, d.process = w, d.processSync = k, d; function d() { for (var e = f(), r = -1; ++r < t.length;)e.use.apply(null, t[r]); return e.data(u(!0, {}, p)), e } function g() { var r, u; if (e) return d; for (; ++D < t.length;)!1 !== (r = t[D])[1] && (!0 === r[1] && (r[1] = void 0), "function" == typeof (u = r[0].apply(d, r.slice(1))) && n.use(u)); return e = !0, D = 1 / 0, d } function y(t, r) { return "string" == typeof t ? 2 === arguments.length ? (C("data", e), p[t] = r, d) : l.call(p, t) && p[t] || null : t ? (C("data", e), p = t, d) : p } function v(r) { var n; if (C("use", e), null != r) if ("function" == typeof r) c.apply(null, arguments); else { if ("object" != typeof r) throw new Error("Expected usable value, not `" + r + "`"); "length" in r ? l(r) : o(r) } return n && (p.settings = u(p.settings || {}, n)), d; function o(e) { l(e.plugins), e.settings && (n = u(n || {}, e.settings)) } function a(e) { if ("function" == typeof e) c(e); else { if ("object" != typeof e) throw new Error("Expected usable value, not `" + e + "`"); "length" in e ? c.apply(null, e) : o(e) } } function l(e) { var t = -1; if (null != e) { if ("object" != typeof e || !("length" in e)) throw new Error("Expected a list of plugins, not `" + e + "`"); for (; ++t < e.length;)a(e[t]) } } function c(e, r) { var n = b(e); n ? (i(n[1]) && i(r) && (r = u(!0, n[1], r)), n[1] = r) : t.push(s.call(arguments)) } } function b(e) { for (var r = -1; ++r < t.length;)if (t[r][0] === e) return t[r] } function x(e) { var t, r = a(e); return g(), h("parse", t = d.Parser), m(t, "parse") ? new t(String(r), r).parse() : t(String(r), r) } function S(e, t, r) { if (F(e), g(), !r && "function" == typeof t && (r = t, t = null), !r) return new Promise(u); function u(u, i) { function o(t, n, o) { n = n || e, t ? i(t) : u ? u(n) : r(null, n, o) } n.run(e, a(t), o) } u(null, r) } function B(e, t) { var n, u; return S(e, t, i), A("runSync", "run", u), n; function i(e, t) { u = !0, n = t, r(e) } } function T(e, t) { var r, n = a(t); return g(), E("stringify", r = d.Compiler), F(e), m(r, "compile") ? new r(e, n).compile() : r(e, n) } function w(e, t) { if (g(), h("process", d.Parser), E("process", d.Compiler), !t) return new Promise(r); function r(r, n) { var u = a(e); function i(e) { e ? n(e) : r ? r(u) : t(null, u) } c.run(d, { file: u }, i) } r(null, t) } function k(e) { var t, n; return g(), h("processSync", d.Parser), E("processSync", d.Compiler), w(t = a(e), u), A("processSync", "process", n), t; function u(e) { n = !0, r(e) } } } function m(e, t) { return "function" == typeof e && e.prototype && (g(e.prototype) || t in e.prototype) } function g(e) { var t; for (t in e) return !0; return !1 } function h(e, t) { if ("function" != typeof t) throw new Error("Cannot `" + e + "` without `Parser`") } function E(e, t) { if ("function" != typeof t) throw new Error("Cannot `" + e + "` without `Compiler`") } function C(e, t) { if (t) throw new Error("Cannot invoke `" + e + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.") } function F(e) { if (!e || "string" != typeof e.type) throw new Error("Expected node, got `" + e + "`") } function A(e, t, r) { if (!r) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } } }), nt = d({ "node_modules/remark-math/util.js"(e) { function t(e) { return Boolean(e && e.prototype && e.prototype.blockTokenizers) } function r(e) { return Boolean(e && e.prototype && e.prototype.visitors) } y(), e.isRemarkParser = t, e.isRemarkCompiler = r } }), ut = d({ "node_modules/remark-math/inline.js"(e, t) { y(); var r = nt(); t.exports = p; var n = 9, u = 32, i = 36, o = 48, a = 57, s = 92, l = ["math", "math-inline"], c = "math-display"; function p(e) { let t = this.Parser, n = this.Compiler; r.isRemarkParser(t) && D(t, e), r.isRemarkCompiler(n) && d(n) } function D(e, t) { let r = e.prototype, p = r.inlineMethods; function D(e, t) { return e.indexOf("$", t) } function d(e, r, p) { let D, d, f, m, g, h, y, E = r.length, C = !1, F = !1, A = 0; if (r.charCodeAt(A) === s && (F = !0, A++), r.charCodeAt(A) === i) { if (A++, F) return !!p || e(r.slice(0, A))({ type: "text", value: "$" }); if (r.charCodeAt(A) === i && (C = !0, A++), f = r.charCodeAt(A), f !== u && f !== n) { for (m = A; A < E;) { if (d = f, f = r.charCodeAt(A + 1), d === i) { if (D = r.charCodeAt(A - 1), D !== u && D !== n && (f != f || f < o || f > a) && (!C || f === i)) { g = A - 1, A++, C && A++, h = A; break } } else d === s && (A++, f = r.charCodeAt(A + 1)); A++ } if (void 0 !== h) return !!p || (y = r.slice(m, g + 1), e(r.slice(0, h))({ type: "inlineMath", value: y, data: { hName: "span", hProperties: { className: l.concat(C && t.inlineMathDouble ? [c] : []) }, hChildren: [{ type: "text", value: y }] } })) } } } d.locator = D, r.inlineTokenizers.math = d, p.splice(p.indexOf("text"), 0, "math") } function d(e) { function t(e) { let t = "$"; return (e.data && e.data.hProperties && e.data.hProperties.className || []).includes(c) && (t = "$$"), t + e.value + t } e.prototype.visitors.inlineMath = t } } }), it = d({ "node_modules/remark-math/block.js"(e, t) { y(); var r = nt(); t.exports = c; var n = 10, u = 32, i = 36, o = "\n", a = "$", s = 2, l = ["math", "math-display"]; function c() { let e = this.Parser, t = this.Compiler; r.isRemarkParser(e) && p(e), r.isRemarkCompiler(t) && D(t) } function p(e) { let t = e.prototype, r = t.blockMethods, c = t.interruptParagraph, p = t.interruptList, D = t.interruptBlockquote; function d(e, t, r) { var c = t.length, p = 0; let D, d, f, m, g, h, y, E, C, F, A; for (; p < c && t.charCodeAt(p) === u;)p++; for (g = p; p < c && t.charCodeAt(p) === i;)p++; if (h = p - g, !(h < s)) { for (; p < c && t.charCodeAt(p) === u;)p++; for (y = p; p < c;) { if (D = t.charCodeAt(p), D === i) return; if (D === n) break; p++ } if (t.charCodeAt(p) === n) { if (r) return !0; for (d = [], y !== p && d.push(t.slice(y, p)), p++, f = t.indexOf(o, p + 1), f = -1 === f ? c : f; p < c;) { for (E = !1, F = p, A = f, m = f, C = 0; m > F && t.charCodeAt(m - 1) === u;)m--; for (; m > F && t.charCodeAt(m - 1) === i;)C++, m--; for (h <= C && t.indexOf(a, F) === m && (E = !0, A = m); F <= A && F - p < g && t.charCodeAt(F) === u;)F++; if (E) for (; A > F && t.charCodeAt(A - 1) === u;)A--; if ((!E || F !== A) && d.push(t.slice(F, A)), E) break; p = f + 1, f = t.indexOf(o, p + 1), f = -1 === f ? c : f } return d = d.join("\n"), e(t.slice(0, f))({ type: "math", value: d, data: { hName: "div", hProperties: { className: l.concat() }, hChildren: [{ type: "text", value: d }] } }) } } } t.blockTokenizers.math = d, r.splice(r.indexOf("fencedCode") + 1, 0, "math"), c.splice(c.indexOf("fencedCode") + 1, 0, ["math"]), p.splice(p.indexOf("fencedCode") + 1, 0, ["math"]), D.splice(D.indexOf("fencedCode") + 1, 0, ["math"]) } function D(e) { function t(e) { return "$$\n" + e.value + "\n$$" } e.prototype.visitors.math = t } } }), ot = d({ "node_modules/remark-math/index.js"(e, t) { y(); var r = ut(), n = it(); function u(e) { var t = e || {}; n.call(this, t), r.call(this, t) } t.exports = u } }), at = d({ "node_modules/remark-footnotes/index.js"(e, t) { y(), t.exports = f; var r = 9, n = 10, u = 32, i = 33, o = 58, a = 91, s = 92, l = 93, c = 94, p = 96, D = 4, d = 1024; function f(e) { var t = this.Parser, r = this.Compiler; m(t) && h(t, e), g(r) && E(r) } function m(e) { return Boolean(e && e.prototype && e.prototype.blockTokenizers) } function g(e) { return Boolean(e && e.prototype && e.prototype.visitors) } function h(e, t) { for (var f, m = t || {}, g = e.prototype, h = g.blockTokenizers, y = g.inlineTokenizers, E = g.blockMethods, A = g.inlineMethods, v = h.definition, b = y.reference, x = [], S = -1, B = E.length; ++S < B;)"newline" !== (f = E[S]) && "indentedCode" !== f && "paragraph" !== f && "footnoteDefinition" !== f && x.push([f]); function T(e, t, i) { for (var s, p, f, m, g, y, E, C, A, v, b, x, S, B = this, T = B.interruptFootnoteDefinition, w = B.offset, k = t.length + 1, N = 0, j = []; N < k && ((m = t.charCodeAt(N)) === r || m === u);)N++; if (t.charCodeAt(N++) === a && t.charCodeAt(N++) === c) { for (p = N; N < k;) { if ((m = t.charCodeAt(N)) != m || m === n || m === r || m === u) return; if (m === l) { f = N, N++; break } N++ } if (void 0 !== f && p !== f && t.charCodeAt(N++) === o) { if (i) return !0; for (s = t.slice(p, f), g = e.now(), A = 0, v = 0, b = N, x = []; N < k;) { if ((m = t.charCodeAt(N)) != m || m === n) S = { start: A, contentStart: b || N, contentEnd: N, end: N }, x.push(S), m === n && (A = N + 1, v = 0, b = void 0, S.end = A); else if (void 0 !== v) if (m === u || m === r) (v += m === u ? 1 : D - v % D) > D && (v = void 0, b = N); else { if (v < D && S && (S.contentStart === S.contentEnd || F(T, h, B, [e, t.slice(N, d), !0]))) break; v = void 0, b = N } N++ } for (N = -1, k = x.length; k > 0 && (S = x[k - 1]).contentStart === S.contentEnd;)k--; for (y = e(t.slice(0, S.contentEnd)); ++N < k;)S = x[N], w[g.line + N] = (w[g.line + N] || 0) + (S.contentStart - S.start), j.push(t.slice(S.contentStart, S.end)); return E = B.enterBlock(), C = B.tokenizeBlock(j.join(""), g), E(), y({ type: "footnoteDefinition", identifier: s.toLowerCase(), label: s, children: C }) } } } function w(e, t, i) { var o, s, p, D, d = t.length + 1, f = 0; if (t.charCodeAt(f++) === a && t.charCodeAt(f++) === c) { for (s = f; f < d;) { if ((D = t.charCodeAt(f)) != D || D === n || D === r || D === u) return; if (D === l) { p = f, f++; break } f++ } if (void 0 !== p && s !== p) return !!i || (o = t.slice(s, p), e(t.slice(0, f))({ type: "footnoteReference", identifier: o.toLowerCase(), label: o })) } } function k(e, t, r) { var n, u, i, o, D, d, f, m = this, g = t.length + 1, h = 0, y = 0; if (t.charCodeAt(h++) === c && t.charCodeAt(h++) === a) { for (i = h; h < g;) { if ((u = t.charCodeAt(h)) != u) return; if (void 0 === d) if (u === s) h += 2; else if (u === a) y++, h++; else if (u === l) { if (0 === y) { o = h, h++; break } y--, h++ } else if (u === p) { for (D = h, d = 1; t.charCodeAt(D + d) === p;)d++; h += d } else h++; else if (u === p) { for (D = h, f = 1; t.charCodeAt(D + f) === p;)f++; h += f, d === f && (d = void 0), f = void 0 } else h++ } if (void 0 !== o) return !!r || ((n = e.now()).column += 2, n.offset += 2, e(t.slice(0, h))({ type: "footnote", children: m.tokenizeInline(t.slice(i, o), n) })) } } function N(e, t, r) { var n = 0; if (t.charCodeAt(n) === i && n++, t.charCodeAt(n) === a && t.charCodeAt(n + 1) !== c) return b.call(this, e, t, r) } function j(e, t, n) { for (var i = 0, o = t.charCodeAt(i); o === u || o === r;)o = t.charCodeAt(++i); if (o === a && t.charCodeAt(i + 1) !== c) return v.call(this, e, t, n) } function O(e, t) { return e.indexOf("[", t) } function I(e, t) { return e.indexOf("^[", t) } x.push(["footnoteDefinition"]), m.inlineNotes && (C(A, "reference", "inlineNote"), y.inlineNote = k), C(E, "definition", "footnoteDefinition"), C(A, "reference", "footnoteCall"), h.definition = j, h.footnoteDefinition = T, y.footnoteCall = w, y.reference = N, g.interruptFootnoteDefinition = x, N.locator = b.locator, w.locator = O, k.locator = I } function E(e) { var t = e.prototype.visitors, r = "    "; function n(e) { return "^[" + this.all(e).join("") + "]" } function u(e) { return "[^" + (e.label || e.identifier) + "]" } function i(e) { for (var t, n = this.all(e).join("\n\n").split("\n"), u = 0, i = n.length; ++u < i;)"" !== (t = n[u]) && (n[u] = r + t); return "[^" + (e.label || e.identifier) + "]: " + n.join("\n") } t.footnote = n, t.footnoteReference = u, t.footnoteDefinition = i } function C(e, t, r) { e.splice(e.indexOf(t), 0, r) } function F(e, t, r, n) { for (var u = e.length, i = -1; ++i < u;)if (t[e[i][0]].apply(r, n)) return !0; return !1 } } }), st = d({ "src/utils/front-matter/parse.js"(e, t) { y(); var r = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s"); function n(e) { let t = e.match(r); if (!t) return { content: e }; let { startDelimiter: n, language: u, value: i = "", endDelimiter: o } = t.groups, a = u.trim() || "yaml"; if ("+++" === n && (a = "toml"), "yaml" !== a && n !== o) return { content: e }; let [s] = t; return { frontMatter: { type: "front-matter", lang: a, value: i, startDelimiter: n, endDelimiter: o, raw: s.replace(/\n$/, "") }, content: s.replace(/[^\n]/g, " ") + e.slice(s.length) } } t.exports = n } }), lt = d({ "src/language-markdown/pragma.js"(e, t) { y(); var r = st(), n = ["format", "prettier"]; function u(e) { let t = `@(${n.join("|")})`, r = new RegExp([`\x3c!--\\s*${t}\\s*--\x3e`, `{\\s*\\/\\*\\s*${t}\\s*\\*\\/\\s*}`, `\x3c!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*${t}[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e`].join("|"), "m"), u = e.match(r); return 0 === (null == u ? void 0 : u.index) } t.exports = { startWithPragma: u, hasPragma: e => u(r(e).content.trimStart()), insertPragma: e => { let t = r(e), u = `\x3c!-- @${n[0]} --\x3e`; return t.frontMatter ? `${t.frontMatter.raw}\n\n${u}\n\n${t.content}` : `${u}\n\n${t.content}` } } } }), ct = d({ "src/language-markdown/loc.js"(e, t) { function r(e) { return e.position.start.offset } function n(e) { return e.position.end.offset } y(), t.exports = { locStart: r, locEnd: n } } }), pt = d({ "src/language-markdown/mdx.js"(e, t) { y(); var r = /^import\s/, n = /^export\s/, u = "[a-z][a-z0-9]*(\\.[a-z][a-z0-9]*)*|", i = /<!---->|<!---?[^>-](?:-?[^-])*-->/, o = /^{\s*\/\*(.*)\*\/\s*}/, a = "\n\n", s = e => r.test(e), l = e => n.test(e), c = (e, t) => { let r = t.indexOf(a), n = t.slice(0, r); if (l(n) || s(n)) return e(n)({ type: l(n) ? "export" : "import", value: n }) }, p = (e, t) => { let r = o.exec(t); if (r) return e(r[0])({ type: "esComment", value: r[1].trim() }) }; function D() { let { Parser: e } = this, { blockTokenizers: t, blockMethods: r, inlineTokenizers: n, inlineMethods: u } = e.prototype; t.esSyntax = c, n.esComment = p, r.splice(r.indexOf("paragraph"), 0, "esSyntax"), u.splice(u.indexOf("text"), 0, "esComment") } c.locator = e => l(e) || s(e) ? -1 : 1, p.locator = (e, t) => e.indexOf("{", t), t.exports = { esSyntax: D, BLOCKS_REGEX: u, COMMENT_REGEX: i } } }), Dt = {}; function dt(e) { if ("string" != typeof e) throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } f(Dt, { default: () => dt }); var ft = D({ "node_modules/escape-string-regexp/index.js"() { y() } }), mt = d({ "src/utils/get-last.js"(e, t) { y(); var r = e => e[e.length - 1]; t.exports = r } }), gt = d({ "node_modules/semver/internal/debug.js"(e, t) { y(); var r = "object" == typeof i && i.env && i.env.NODE_DEBUG && /\bsemver\b/i.test(i.env.NODE_DEBUG) ? function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return console.error("SEMVER", ...t) } : () => { }; t.exports = r } }), ht = d({ "node_modules/semver/internal/constants.js"(e, t) { y(); var r = "2.0.0", n = 256, u = Number.MAX_SAFE_INTEGER || 9007199254740991, i = 16; t.exports = { SEMVER_SPEC_VERSION: r, MAX_LENGTH: n, MAX_SAFE_INTEGER: u, MAX_SAFE_COMPONENT_LENGTH: i } } }), yt = d({ "node_modules/semver/internal/re.js"(e, t) { y(); var { MAX_SAFE_COMPONENT_LENGTH: r } = ht(), n = gt(), u = (e = t.exports = {}).re = [], i = e.src = [], o = e.t = {}, a = 0, s = (e, t, r) => { let s = a++; n(e, s, t), o[e] = s, i[s] = t, u[s] = new RegExp(t, r ? "g" : void 0) }; s("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s("MAINVERSION", `(${i[o.NUMERICIDENTIFIER]})\\.(${i[o.NUMERICIDENTIFIER]})\\.(${i[o.NUMERICIDENTIFIER]})`), s("MAINVERSIONLOOSE", `(${i[o.NUMERICIDENTIFIERLOOSE]})\\.(${i[o.NUMERICIDENTIFIERLOOSE]})\\.(${i[o.NUMERICIDENTIFIERLOOSE]})`), s("PRERELEASEIDENTIFIER", `(?:${i[o.NUMERICIDENTIFIER]}|${i[o.NONNUMERICIDENTIFIER]})`), s("PRERELEASEIDENTIFIERLOOSE", `(?:${i[o.NUMERICIDENTIFIERLOOSE]}|${i[o.NONNUMERICIDENTIFIER]})`), s("PRERELEASE", `(?:-(${i[o.PRERELEASEIDENTIFIER]}(?:\\.${i[o.PRERELEASEIDENTIFIER]})*))`), s("PRERELEASELOOSE", `(?:-?(${i[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i[o.PRERELEASEIDENTIFIERLOOSE]})*))`), s("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s("BUILD", `(?:\\+(${i[o.BUILDIDENTIFIER]}(?:\\.${i[o.BUILDIDENTIFIER]})*))`), s("FULLPLAIN", `v?${i[o.MAINVERSION]}${i[o.PRERELEASE]}?${i[o.BUILD]}?`), s("FULL", `^${i[o.FULLPLAIN]}$`), s("LOOSEPLAIN", `[v=\\s]*${i[o.MAINVERSIONLOOSE]}${i[o.PRERELEASELOOSE]}?${i[o.BUILD]}?`), s("LOOSE", `^${i[o.LOOSEPLAIN]}$`), s("GTLT", "((?:<|>)?=?)"), s("XRANGEIDENTIFIERLOOSE", `${i[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s("XRANGEIDENTIFIER", `${i[o.NUMERICIDENTIFIER]}|x|X|\\*`), s("XRANGEPLAIN", `[v=\\s]*(${i[o.XRANGEIDENTIFIER]})(?:\\.(${i[o.XRANGEIDENTIFIER]})(?:\\.(${i[o.XRANGEIDENTIFIER]})(?:${i[o.PRERELEASE]})?${i[o.BUILD]}?)?)?`), s("XRANGEPLAINLOOSE", `[v=\\s]*(${i[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[o.XRANGEIDENTIFIERLOOSE]})(?:${i[o.PRERELEASELOOSE]})?${i[o.BUILD]}?)?)?`), s("XRANGE", `^${i[o.GTLT]}\\s*${i[o.XRANGEPLAIN]}$`), s("XRANGELOOSE", `^${i[o.GTLT]}\\s*${i[o.XRANGEPLAINLOOSE]}$`), s("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), s("COERCERTL", i[o.COERCE], !0), s("LONETILDE", "(?:~>?)"), s("TILDETRIM", `(\\s*)${i[o.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", s("TILDE", `^${i[o.LONETILDE]}${i[o.XRANGEPLAIN]}$`), s("TILDELOOSE", `^${i[o.LONETILDE]}${i[o.XRANGEPLAINLOOSE]}$`), s("LONECARET", "(?:\\^)"), s("CARETTRIM", `(\\s*)${i[o.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", s("CARET", `^${i[o.LONECARET]}${i[o.XRANGEPLAIN]}$`), s("CARETLOOSE", `^${i[o.LONECARET]}${i[o.XRANGEPLAINLOOSE]}$`), s("COMPARATORLOOSE", `^${i[o.GTLT]}\\s*(${i[o.LOOSEPLAIN]})$|^$`), s("COMPARATOR", `^${i[o.GTLT]}\\s*(${i[o.FULLPLAIN]})$|^$`), s("COMPARATORTRIM", `(\\s*)${i[o.GTLT]}\\s*(${i[o.LOOSEPLAIN]}|${i[o.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", s("HYPHENRANGE", `^\\s*(${i[o.XRANGEPLAIN]})\\s+-\\s+(${i[o.XRANGEPLAIN]})\\s*$`), s("HYPHENRANGELOOSE", `^\\s*(${i[o.XRANGEPLAINLOOSE]})\\s+-\\s+(${i[o.XRANGEPLAINLOOSE]})\\s*$`), s("STAR", "(<|>)?=?\\s*\\*"), s("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), s("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$") } }), Et = d({ "node_modules/semver/internal/parse-options.js"(e, t) { y(); var r = ["includePrerelease", "loose", "rtl"], n = e => e ? "object" != typeof e ? { loose: !0 } : r.filter((t => e[t])).reduce(((e, t) => (e[t] = !0, e)), {}) : {}; t.exports = n } }), Ct = d({ "node_modules/semver/internal/identifiers.js"(e, t) { y(); var r = /^[0-9]+$/, n = (e, t) => { let n = r.test(e), u = r.test(t); return n && u && (e = +e, t = +t), e === t ? 0 : n && !u ? -1 : u && !n ? 1 : e < t ? -1 : 1 }, u = (e, t) => n(t, e); t.exports = { compareIdentifiers: n, rcompareIdentifiers: u } } }), Ft = d({ "node_modules/semver/classes/semver.js"(e, t) { y(); var r = gt(), { MAX_LENGTH: n, MAX_SAFE_INTEGER: u } = ht(), { re: i, t: o } = yt(), a = Et(), { compareIdentifiers: s } = Ct(), l = class { constructor(e, t) { if (t = a(t), e instanceof l) { if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease) return e; e = e.version } else if ("string" != typeof e) throw new TypeError(`Invalid Version: ${e}`); if (e.length > n) throw new TypeError(`version is longer than ${n} characters`); r("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease; let s = e.trim().match(t.loose ? i[o.LOOSE] : i[o.FULL]); if (!s) throw new TypeError(`Invalid Version: ${e}`); if (this.raw = e, this.major = +s[1], this.minor = +s[2], this.patch = +s[3], this.major > u || this.major < 0) throw new TypeError("Invalid major version"); if (this.minor > u || this.minor < 0) throw new TypeError("Invalid minor version"); if (this.patch > u || this.patch < 0) throw new TypeError("Invalid patch version"); s[4] ? this.prerelease = s[4].split(".").map((e => { if (/^[0-9]+$/.test(e)) { let t = +e; if (t >= 0 && t < u) return t } return e })) : this.prerelease = [], this.build = s[5] ? s[5].split(".") : [], this.format() } format() { return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version } toString() { return this.version } compare(e) { if (r("SemVer.compare", this.version, this.options, e), !(e instanceof l)) { if ("string" == typeof e && e === this.version) return 0; e = new l(e, this.options) } return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e) } compareMain(e) { return e instanceof l || (e = new l(e, this.options)), s(this.major, e.major) || s(this.minor, e.minor) || s(this.patch, e.patch) } comparePre(e) { if (e instanceof l || (e = new l(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1; if (!this.prerelease.length && e.prerelease.length) return 1; if (!this.prerelease.length && !e.prerelease.length) return 0; let t = 0; do { let n = this.prerelease[t], u = e.prerelease[t]; if (r("prerelease compare", t, n, u), void 0 === n && void 0 === u) return 0; if (void 0 === u) return 1; if (void 0 === n) return -1; if (n !== u) return s(n, u) } while (++t) } compareBuild(e) { e instanceof l || (e = new l(e, this.options)); let t = 0; do { let n = this.build[t], u = e.build[t]; if (r("prerelease compare", t, n, u), void 0 === n && void 0 === u) return 0; if (void 0 === u) return 1; if (void 0 === n) return -1; if (n !== u) return s(n, u) } while (++t) } inc(e, t) { switch (e) { case "premajor": this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t); break; case "preminor": this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t); break; case "prepatch": this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t); break; case "prerelease": 0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t); break; case "major": (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = []; break; case "minor": (0 !== this.patch || 0 === this.prerelease.length) && this.minor++, this.patch = 0, this.prerelease = []; break; case "patch": 0 === this.prerelease.length && this.patch++, this.prerelease = []; break; case "pre": if (0 === this.prerelease.length) this.prerelease = [0]; else { let e = this.prerelease.length; for (; --e >= 0;)"number" == typeof this.prerelease[e] && (this.prerelease[e]++, e = -2); -1 === e && this.prerelease.push(0) } t && (0 === s(this.prerelease[0], t) ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]); break; default: throw new Error(`invalid increment argument: ${e}`) }return this.format(), this.raw = this.version, this } }; t.exports = l } }), At = d({ "node_modules/semver/functions/compare.js"(e, t) { y(); var r = Ft(), n = (e, t, n) => new r(e, n).compare(new r(t, n)); t.exports = n } }), vt = d({ "node_modules/semver/functions/lt.js"(e, t) { y(); var r = At(), n = (e, t, n) => r(e, t, n) < 0; t.exports = n } }), bt = d({ "node_modules/semver/functions/gte.js"(e, t) { y(); var r = At(), n = (e, t, n) => r(e, t, n) >= 0; t.exports = n } }), xt = d({ "src/utils/arrayify.js"(e, t) { y(), t.exports = (e, t) => Object.entries(e).map((e => { let [r, n] = e; return Object.assign({ [t]: r }, n) })) } }), St = d({ "package.json"(e, t) { t.exports = { version: "2.8.8" } } }), Bt = d({ "node_modules/outdent/lib/index.js"(e, t) { function r() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t] } function n() { return typeof WeakMap < "u" ? new WeakMap : u() } function u() { return { add: r, delete: r, get: r, set: r, has: function (e) { return !1 } } } y(), Object.defineProperty(e, "__esModule", { value: !0 }), e.outdent = void 0; var i = Object.prototype.hasOwnProperty, o = function (e, t) { return i.call(e, t) }; function a(e, t) { for (var r in t) o(t, r) && (e[r] = t[r]); return e } var s = /^[ \t]*(?:\r\n|\r|\n)/, l = /(?:\r\n|\r|\n)[ \t]*$/, c = /^(?:[\r\n]|$)/, p = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, D = /^[ \t]*[\r\n][ \t\r\n]*$/; function d(e, t, r) { var n = 0, u = e[0].match(p); u && (n = u[1].length); var i = new RegExp("(\\r\\n|\\r|\\n).{0," + n + "}", "g"); t && (e = e.slice(1)); var o = r.newline, a = r.trimLeadingNewline, c = r.trimTrailingNewline, D = "string" == typeof o, d = e.length; return e.map((function (e, t) { return e = e.replace(i, "$1"), 0 === t && a && (e = e.replace(s, "")), t === d - 1 && c && (e = e.replace(l, "")), D && (e = e.replace(/\r\n|\n|\r/g, (function (e) { return o }))), e })) } function f(e, t) { for (var r = "", n = 0, u = e.length; n < u; n++)r += e[n], n < u - 1 && (r += t[n]); return r } function m(e) { return o(e, "raw") && o(e, "length") } function g(e) { var t = n(), r = n(); function u(n) { for (var i = [], o = 1; o < arguments.length; o++)i[o - 1] = arguments[o]; if (m(n)) { var s = n, l = (i[0] === u || i[0] === h) && D.test(s[0]) && c.test(s[1]), p = l ? r : t, y = p.get(s); return y || (y = d(s, l, e), p.set(s, y)), 0 === i.length ? y[0] : f(y, l ? i.slice(1) : i) } return g(a(a({}, e), n || {})) } return a(u, { string: function (t) { return d([t], !1, e)[0] } }) } var h = g({ trimLeadingNewline: !0, trimTrailingNewline: !0 }); if (e.outdent = h, e.default = h, typeof t < "u") try { t.exports = h, Object.defineProperty(h, "__esModule", { value: !0 }), h.default = h, h.outdent = h } catch { } } }), Tt = d({
                    "src/main/core-options.js"(e, t) {
                        y(); var { outdent: r } = Bt(), n = "Config", u = "Editor", i = "Format", o = "Other", a = "Output", s = "Global", l = "Special", c = {
                            cursorOffset: {
                                since: "1.4.0", category: l, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: r`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: u
                            }, endOfLine: {
                                since: "1.15.0", category: s, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, {
                                    value: "auto", description: r`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]
                            }, filepath: { since: "1.4.0", category: l, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: o, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: l, type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: o }, parser: { since: "0.0.10", category: s, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: e => "string" == typeof e || "function" == typeof e, choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: !0, default: [{ value: [] }], category: s, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: e => "string" == typeof e || "object" == typeof e, cliName: "plugin", cliCategory: n }, pluginSearchDirs: {
                                since: "1.13.0", type: "path", array: !0, default: [{ value: [] }], category: s, description: r`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: e => "string" == typeof e || "object" == typeof e, cliName: "plugin-search-dir", cliCategory: n
                            }, printWidth: { since: "0.0.0", category: s, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: {
                                since: "1.4.0", category: l, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: r`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: u
                            }, rangeStart: {
                                since: "1.4.0", category: l, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: r`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: u
                            }, requirePragma: {
                                since: "1.7.0", category: l, type: "boolean", default: !1, description: r`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: o
                            }, tabWidth: { type: "int", category: s, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: s, type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: s, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] }
                        }; t.exports = { CATEGORY_CONFIG: n, CATEGORY_EDITOR: u, CATEGORY_FORMAT: i, CATEGORY_OTHER: o, CATEGORY_OUTPUT: a, CATEGORY_GLOBAL: s, CATEGORY_SPECIAL: l, options: c }
                    }
                }), wt = d({ "src/main/support.js"(e, t) { y(); var u = { compare: At(), lt: vt(), gte: bt() }, i = xt(), o = St().version, a = Tt().options; function s() { let { plugins: e = [], showUnreleased: t = !1, showDeprecated: s = !1, showInternal: c = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, p = o.split("-", 1)[0], D = e.flatMap((e => e.languages || [])).filter(f), d = i(Object.assign({}, ...e.map((e => { let { options: t } = e; return t })), a), "name").filter((e => f(e) && m(e))).sort(((e, t) => e.name === t.name ? 0 : e.name < t.name ? -1 : 1)).map(g).map((t => { t = Object.assign({}, t), Array.isArray(t.default) && (t.default = 1 === t.default.length ? t.default[0].value : t.default.filter(f).sort(((e, t) => u.compare(t.since, e.since)))[0].value), Array.isArray(t.choices) && (t.choices = t.choices.filter((e => f(e) && m(e))), "parser" === t.name && l(t, D, e)); let r = Object.fromEntries(e.filter((e => e.defaultOptions && void 0 !== e.defaultOptions[t.name])).map((e => [e.name, e.defaultOptions[t.name]]))); return Object.assign(Object.assign({}, t), {}, { pluginDefaults: r }) })); return { languages: D, options: d }; function f(e) { return t || !("since" in e) || e.since && u.gte(p, e.since) } function m(e) { return s || !("deprecated" in e) || e.deprecated && u.lt(p, e.deprecated) } function g(e) { return c ? e : n(e, r) } } function l(e, t, r) { let n = new Set(e.choices.map((e => e.value))); for (let u of t) if (u.parsers) for (let t of u.parsers) if (!n.has(t)) { n.add(t); let i = r.find((e => e.parsers && e.parsers[t])), o = u.name; i && i.name && (o += ` (plugin: ${i.name})`), e.choices.push({ value: t, description: o }) } } t.exports = { getSupportInfo: s } } }), kt = d({ "src/utils/is-non-empty-array.js"(e, t) { function r(e) { return Array.isArray(e) && e.length > 0 } y(), t.exports = r } }); function Nt() { let { onlyFirst: e = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"); return new RegExp(t, e ? void 0 : "g") } var jt = D({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() { y() } }); function Ot(e) { if ("string" != typeof e) throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``); return e.replace(Nt(), "") } var It = D({ "node_modules/strip-ansi/index.js"() { y(), jt() } }); function Pt(e) { return !!Number.isInteger(e) && e >= 4352 && (e <= 4447 || 9001 === e || 9002 === e || 11904 <= e && e <= 12871 && 12351 !== e || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) } var Lt = D({ "node_modules/is-fullwidth-code-point/index.js"() { y() } }), _t = d({ "node_modules/emoji-regex/index.js"(e, t) { y(), t.exports = function () { return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g } } }), Rt = {}; function Mt(e) { if ("string" != typeof e || 0 === e.length || 0 === (e = Ot(e)).length) return 0; e = e.replace((0, $t.default)(), "  "); let t = 0; for (let r = 0; r < e.length; r++) { let n = e.codePointAt(r); n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (n > 65535 && r++, t += Pt(n) ? 2 : 1) } return t } f(Rt, { default: () => Mt }); var $t, qt = D({ "node_modules/string-width/index.js"() { y(), It(), Lt(), $t = g(_t()) } }), Vt = d({ "src/utils/get-string-width.js"(e, t) { y(); var r = (qt(), h(Rt)).default, n = /[^\x20-\x7F]/; function u(e) { return e ? n.test(e) ? r(e) : e.length : 0 } t.exports = u } }), Ut = d({ "src/utils/text/skip.js"(e, t) { function r(e) { return (t, r, n) => { let u = n && n.backwards; if (!1 === r) return !1; let { length: i } = t, o = r; for (; o >= 0 && o < i;) { let r = t.charAt(o); if (e instanceof RegExp) { if (!e.test(r)) return o } else if (!e.includes(r)) return o; u ? o-- : o++ } return (-1 === o || o === i) && o } } y(); var n = r(/\s/), u = r(" \t"), i = r(",; \t"), o = r(/[^\n\r]/); t.exports = { skipWhitespace: n, skipSpaces: u, skipToLineEnd: i, skipEverythingButNewLine: o } } }), Wt = d({ "src/utils/text/skip-inline-comment.js"(e, t) { function r(e, t) { if (!1 === t) return !1; if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r)if ("*" === e.charAt(r) && "/" === e.charAt(r + 1)) return r + 2; return t } y(), t.exports = r } }), Gt = d({ "src/utils/text/skip-trailing-comment.js"(e, t) { y(); var { skipEverythingButNewLine: r } = Ut(); function n(e, t) { return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? r(e, t) : t) } t.exports = n } }), zt = d({ "src/utils/text/skip-newline.js"(e, t) { function r(e, t, r) { let n = r && r.backwards; if (!1 === t) return !1; let u = e.charAt(t); if (n) { if ("\r" === e.charAt(t - 1) && "\n" === u) return t - 2; if ("\n" === u || "\r" === u || "\u2028" === u || "\u2029" === u) return t - 1 } else { if ("\r" === u && "\n" === e.charAt(t + 1)) return t + 2; if ("\n" === u || "\r" === u || "\u2028" === u || "\u2029" === u) return t + 1 } return t } y(), t.exports = r } }), Ht = d({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, t) { y(); var r = Wt(), n = zt(), u = Gt(), { skipSpaces: i } = Ut(); function o(e, t) { let o = null, a = t; for (; a !== o;)o = a, a = i(e, a), a = r(e, a), a = u(e, a), a = n(e, a); return a } t.exports = o } }), Jt = d({ "src/common/util.js"(e, t) { y(); var { default: r } = (ft(), h(Dt)), n = mt(), { getSupportInfo: u } = wt(), i = kt(), o = Vt(), { skipWhitespace: a, skipSpaces: s, skipToLineEnd: l, skipEverythingButNewLine: c } = Ut(), p = Wt(), D = Gt(), d = zt(), f = Ht(), m = e => e[e.length - 2]; function g(e) { return (t, r, n) => { let u = n && n.backwards; if (!1 === r) return !1; let { length: i } = t, o = r; for (; o >= 0 && o < i;) { let r = t.charAt(o); if (e instanceof RegExp) { if (!e.test(r)) return o } else if (!e.includes(r)) return o; u ? o-- : o++ } return (-1 === o || o === i) && o } } function E(e, t) { let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = s(e, r.backwards ? t - 1 : t, r); return n !== d(e, n, r) } function C(e, t, r) { for (let n = t; n < r; ++n)if ("\n" === e.charAt(n)) return !0; return !1 } function F(e, t, r) { let n = r(t) - 1; return n = s(e, n, { backwards: !0 }), n = d(e, n, { backwards: !0 }), n = s(e, n, { backwards: !0 }), n !== d(e, n, { backwards: !0 }) } function A(e, t) { let r = null, n = t; for (; n !== r;)r = n, n = l(e, n), n = p(e, n), n = s(e, n); return n = D(e, n), n = d(e, n), !1 !== n && E(e, n) } function v(e, t, r) { return A(e, r(t)) } function b(e, t, r) { return f(e, r(t)) } function x(e, t, r) { return e.charAt(b(e, t, r)) } function S(e, t) { let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return s(e, r.backwards ? t - 1 : t, r) !== t } function B(e, t) { let r = 0; for (let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; n < e.length; ++n)"\t" === e[n] ? r = r + t - r % t : r++; return r } function T(e, t) { let r = e.lastIndexOf("\n"); return -1 === r ? 0 : B(e.slice(r + 1).match(/^[\t ]*/)[0], t) } function w(e, t) { let r = { quote: '"', regex: /"/g, escaped: "&quot;" }, n = { quote: "'", regex: /'/g, escaped: "&apos;" }, u = "'" === t ? n : r, i = u === n ? r : n, o = u; return (e.includes(u.quote) || e.includes(i.quote)) && (o = (e.match(u.regex) || []).length > (e.match(i.regex) || []).length ? i : u), o } function k(e, t) { let r = e.slice(1, -1); return N(r, "json" === t.parser || "json5" === t.parser && "preserve" === t.quoteProps && !t.singleQuote ? '"' : t.__isInHtmlAttribute ? "'" : w(r, t.singleQuote ? "'" : '"').quote, !("css" === t.parser || "less" === t.parser || "scss" === t.parser || t.__embeddedInHtml)) } function N(e, t, r) { let n = '"' === t ? "'" : '"', u = /\\(.)|(["'])/gs, i = e.replace(u, ((e, u, i) => u === n ? u : i === t ? "\\" + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(u) ? u : "\\" + u))); return t + i + t } function j(e) { return e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "") } function O(e, t) { let n = e.match(new RegExp(`(${r(t)})+`, "g")); return null === n ? 0 : n.reduce(((e, r) => Math.max(e, r.length / t.length)), 0) } function I(e, t) { let n = e.match(new RegExp(`(${r(t)})+`, "g")); if (null === n) return 0; let u = new Map, i = 0; for (let r of n) { let e = r.length / t.length; u.set(e, !0), e > i && (i = e) } for (let r = 1; r < i; r++)if (!u.get(r)) return r; return i + 1 } function P(e, t) { (e.comments || (e.comments = [])).push(t), t.printed = !1, t.nodeDescription = V(e) } function L(e, t) { t.leading = !0, t.trailing = !1, P(e, t) } function _(e, t, r) { t.leading = !1, t.trailing = !1, r && (t.marker = r), P(e, t) } function R(e, t) { t.leading = !1, t.trailing = !0, P(e, t) } function M(e, t) { let { languages: r } = u({ plugins: t.plugins }), n = r.find((t => { let { name: r } = t; return r.toLowerCase() === e })) || r.find((t => { let { aliases: r } = t; return Array.isArray(r) && r.includes(e) })) || r.find((t => { let { extensions: r } = t; return Array.isArray(r) && r.includes(`.${e}`) })); return n && n.parsers[0] } function $(e) { return e && "front-matter" === e.type } function q(e) { let t = new WeakMap; return function (r) { return t.has(r) || t.set(r, Symbol(e)), t.get(r) } } function V(e) { let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && ("object" == typeof e.id ? e.id.name : e.id) || e.key && ("object" == typeof e.key ? e.key.name : e.key) || e.value && ("object" == typeof e.value ? "" : String(e.value)) || e.operator || ""); return r.length > 20 && (r = r.slice(0, 19) + "â¦"), t + (r ? " " + r : "") } t.exports = { inferParserByLanguage: M, getStringWidth: o, getMaxContinuousCount: O, getMinNotPresentContinuousCount: I, getPenultimate: m, getLast: n, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: b, getNextNonSpaceNonCommentCharacter: x, skip: g, skipWhitespace: a, skipSpaces: s, skipToLineEnd: l, skipEverythingButNewLine: c, skipInlineComment: p, skipTrailingComment: D, skipNewline: d, isNextLineEmptyAfterIndex: A, isNextLineEmpty: v, isPreviousLineEmpty: F, hasNewline: E, hasNewlineInRange: C, hasSpaces: S, getAlignmentSize: B, getIndentSize: T, getPreferredQuote: w, printString: k, printNumber: j, makeString: N, addLeadingComment: L, addDanglingComment: _, addTrailingComment: R, isFrontMatterNode: $, isNonEmptyArray: i, createGroupIdMapper: q } } }), Xt = d({ "src/language-markdown/constants.evaluate.js"(e, t) { t.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" } } }), Kt = d({ "src/language-markdown/utils.js"(e, t) { y(); var { getLast: r } = Jt(), { locStart: n, locEnd: u } = ct(), { cjkPattern: i, kPattern: o, punctuationPattern: a } = Xt(), s = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], l = [...s, "tableCell", "paragraph", "heading"], c = new RegExp(o), p = new RegExp(a); function D(e, t) { let n = "non-cjk", u = "cj-letter", o = "k-letter", a = "cjk-punctuation", s = [], l = ("preserve" === t.proseWrap ? e : e.replace(new RegExp(`(${i})\n(${i})`, "g"), "$1$2")).split(/([\t\n ]+)/); for (let [d, f] of l.entries()) { if (d % 2 == 1) { s.push({ type: "whitespace", value: /\n/.test(f) ? "\n" : " " }); continue } if ((0 === d || d === l.length - 1) && "" === f) continue; let e = f.split(new RegExp(`(${i})`)); for (let [t, i] of e.entries()) if (0 !== t && t !== e.length - 1 || "" !== i) { if (t % 2 == 0) { "" !== i && D({ type: "word", value: i, kind: n, hasLeadingPunctuation: p.test(i[0]), hasTrailingPunctuation: p.test(r(i)) }); continue } D(p.test(i) ? { type: "word", value: i, kind: a, hasLeadingPunctuation: !0, hasTrailingPunctuation: !0 } : { type: "word", value: i, kind: c.test(i) ? o : u, hasLeadingPunctuation: !1, hasTrailingPunctuation: !1 }) } } return s; function D(e) { let t = r(s); function i(r, n) { return t.kind === r && e.kind === n || t.kind === n && e.kind === r } t && "word" === t.type && (t.kind === n && e.kind === u && !t.hasTrailingPunctuation || t.kind === u && e.kind === n && !e.hasLeadingPunctuation ? s.push({ type: "whitespace", value: " " }) : !i(n, a) && ![t.value, e.value].some((e => /\u3000/.test(e))) && s.push({ type: "whitespace", value: "" })), s.push(e) } } function d(e, t) { let [, r, n, u] = t.slice(e.position.start.offset, e.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/); return { numberText: r, marker: n, leadingSpaces: u } } function f(e, t) { if (!e.ordered || e.children.length < 2) return !1; let r = Number(d(e.children[0], t.originalText).numberText), n = Number(d(e.children[1], t.originalText).numberText); if (0 === r && e.children.length > 2) { let r = Number(d(e.children[2], t.originalText).numberText); return 1 === n && 1 === r } return 1 === n } function m(e, t) { let { value: r } = e; return e.position.end.offset === t.length && r.endsWith("\n") && t.endsWith("\n") ? r.slice(0, -1) : r } function g(e, t) { return function e(r, n, u) { let i = Object.assign({}, t(r, n, u)); return i.children && (i.children = i.children.map(((t, r) => e(t, r, [i, ...u])))), i }(e, null, []) } function h(e) { if ("link" !== (null == e ? void 0 : e.type) || 1 !== e.children.length) return !1; let [t] = e.children; return n(e) === n(t) && u(e) === u(t) } t.exports = { mapAst: g, splitText: D, punctuationPattern: a, getFencedCodeBlockValue: m, getOrderedListItemInfo: d, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: s, INLINE_NODE_WRAPPER_TYPES: l, isAutolink: h } } }), Yt = d({ "src/language-markdown/unified-plugins/html-to-jsx.js"(e, t) { y(); var r = pt(), { mapAst: n, INLINE_NODE_WRAPPER_TYPES: u } = Kt(); function i() { return e => n(e, ((e, t, n) => { let [i] = n; return "html" !== e.type || r.COMMENT_REGEX.test(e.value) || u.includes(i.type) ? e : Object.assign(Object.assign({}, e), {}, { type: "jsx" }) })) } t.exports = i } }), Qt = d({ "src/language-markdown/unified-plugins/front-matter.js"(e, t) { y(); var r = st(); function n() { let e = this.Parser.prototype; function t(e, t) { let n = r(t); if (n.frontMatter) return e(n.frontMatter.raw)(n.frontMatter) } e.blockMethods = ["frontMatter", ...e.blockMethods], e.blockTokenizers.frontMatter = t, t.onlyAtStart = !0 } t.exports = n } }), Zt = d({ "src/language-markdown/unified-plugins/liquid.js"(e, t) { function r() { let e = this.Parser.prototype, t = e.inlineMethods; function r(e, t) { let r = t.match(/^({%.*?%}|{{.*?}})/s); if (r) return e(r[0])({ type: "liquidNode", value: r[0] }) } t.splice(t.indexOf("text"), 0, "liquid"), e.inlineTokenizers.liquid = r, r.locator = function (e, t) { return e.indexOf("{", t) } } y(), t.exports = r } }), er = d({ "src/language-markdown/unified-plugins/wiki-link.js"(e, t) { function r() { let e = "wikiLink", t = /^\[\[(?<linkContents>.+?)]]/s, r = this.Parser.prototype, n = r.inlineMethods; function u(r, n) { let u = t.exec(n); if (u) { let t = u.groups.linkContents.trim(); return r(u[0])({ type: e, value: t }) } } n.splice(n.indexOf("link"), 0, e), r.inlineTokenizers.wikiLink = u, u.locator = function (e, t) { return e.indexOf("[", t) } } y(), t.exports = r } }), tr = d({ "src/language-markdown/unified-plugins/loose-items.js"(e, t) { function r() { let e = this.Parser.prototype, t = e.blockTokenizers.list; function r(e, t, r) { return "listItem" === t.type && (t.loose = t.spread || "\n" === e.charAt(e.length - 1), t.loose && (r.loose = !0)), t } e.blockTokenizers.list = function (e, n, u) { function i(t) { let n = e(t); function u(e, u) { return n(r(t, e, u), u) } return u.reset = function (e, u) { return n.reset(r(t, e, u), u) }, u } return i.now = e.now, t.call(this, i, n, u) } } y(), t.exports = r } }); y(); var rr = Ve(), nr = rt(), ur = ot(), ir = at(), or = lt(), { locStart: ar, locEnd: sr } = ct(), lr = pt(), cr = Yt(), pr = Qt(), Dr = Zt(), dr = er(), fr = tr(); function mr(e) { let { isMDX: t } = e; return e => { let r = nr().use(rr, Object.assign({ commonmark: !0 }, t && { blocks: [lr.BLOCKS_REGEX] })).use(ir).use(pr).use(ur).use(t ? lr.esSyntax : gr).use(Dr).use(t ? cr : gr).use(dr).use(fr); return r.runSync(r.parse(e)) } } function gr(e) { return e } var hr = { astFormat: "mdast", hasPragma: or.hasPragma, locStart: ar, locEnd: sr }, yr = Object.assign(Object.assign({}, hr), {}, { parse: mr({ isMDX: !1 }) }), Er = Object.assign(Object.assign({}, hr), {}, { parse: mr({ isMDX: !0 }) }); t.exports = { parsers: { remark: yr, markdown: yr, mdx: Er } }
            })); return Oe()
        }()
    }(Ue); const We = t(Ue.exports), Ge = "plugin.markdown-prettier.format-on-save"; var ze; ze = { name: "@yank-note/extension-markdown-prettier", register: e => { function t(e, t) { return Ve.format(e, { parser: "markdown", plugins: [We], ...t }) } const r = e.i18n.createI18n({ en: { "format-markdown": "Format Markdown", "format-on-save": "Format on Save - Markdown Prettier" }, "zh-CN": { "format-markdown": "æ ¼å¼å Markdown", "format-on-save": "ä¿å­æ¶æ ¼å¼å - Markdown Prettier" } }); e.editor.whenEditorReady().then((({ monaco: e }) => { e.editor.addKeybindingRules([{ keybinding: e.KeyMod.Alt | e.KeyMod.Shift | e.KeyCode.KeyF, command: "-editor.action.formatDocument" }, { keybinding: e.KeyMod.Alt | e.KeyMod.Shift | e.KeyCode.KeyL, command: "editor.action.formatDocument" }]), e.languages.registerDocumentFormattingEditProvider("markdown", { provideDocumentFormattingEdits: (e, r) => { const n = t(e.getValue(), { tabWidth: r.tabSize, useTabs: !r.insertSpaces }); return [{ range: e.getFullModelRange(), text: n }] } }), e.languages.registerDocumentRangeFormattingEditProvider("markdown", { provideDocumentRangeFormattingEdits: (e, r, n) => [{ range: r, text: t(e.getValueInRange(r), { tabWidth: n.tabSize, useTabs: !n.insertSpaces }) }] }) })), e.lib.semver.satisfies(e.version, ">=3.35.0") && (e.setting.changeSchema((e => { e.properties[Ge] = { title: r.$$t("format-on-save"), type: "boolean", defaultValue: !1, format: "checkbox", group: "editor", required: !0 } })), e.registerHook("DOC_BEFORE_SAVE", (async t => { var r, n; if (!e.setting.getSetting(Ge)) return; if (e.doc.toUri(t.doc) !== (null == (r = e.editor.getEditor().getModel()) ? void 0 : r.uri.toString())) return; const u = e.editor.getEditor(); await (null == (n = u.getAction("editor.action.formatDocument")) ? void 0 : n.run()), u.focus(), t.content = e.editor.getValue() }))) } }, globalThis.registerPlugin(ze)
}();
